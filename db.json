{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/next-reloaded/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/avatar.jpg","path":"images/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/next-reloaded/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/avatar1.jpg","path":"images/avatar1.jpg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/next-reloaded/.bowerrc","hash":"334da94ca6f024d60d012cc26ea655681e724ad8","modified":1532913596211},{"_id":"themes/next-reloaded/.eslintrc.json","hash":"d3c11de434171d55d70daadd3914bc33544b74b8","modified":1532913596215},{"_id":"themes/next-reloaded/.gitignore","hash":"0378adb9c2dc4855b3198184df4863cb30e4059c","modified":1532913596231},{"_id":"themes/next-reloaded/LICENSE.md","hash":"f0190c7d83a98464549a6b3a51bb206148d88e1b","modified":1532913596236},{"_id":"themes/next-reloaded/bower.json","hash":"72d7f5ef565cca1da30ba64fc04075b9ac99e319","modified":1532913596242},{"_id":"themes/next-reloaded/.editorconfig","hash":"211d2c92bfdddb3e81ea946f4ca7a539f150f4da","modified":1532913596213},{"_id":"themes/next-reloaded/.gitattributes","hash":"8454b9313cb1a97b63fb87e2d29daee497ce6249","modified":1532913596217},{"_id":"themes/next-reloaded/.stylintrc","hash":"3b7f9785e9ad0dab764e1c535b40df02f4ff5fd6","modified":1532913596233},{"_id":"themes/next-reloaded/.travis.yml","hash":"fb9ac54e875f6ea16d5c83db497f6bd70ae83198","modified":1532913596234},{"_id":"themes/next-reloaded/README.md","hash":"2d142fa1bdfab00abf8e99f972346e15572c9b12","modified":1532913596238},{"_id":"themes/next-reloaded/crowdin.yml","hash":"4a53f5985e545c635cb56b2a57ed290cb8cf8942","modified":1532913596244},{"_id":"themes/next-reloaded/package.json","hash":"735ace0b7fe3b1171c220c5424fcd4fe3aadd7f8","modified":1532913596498},{"_id":"themes/next-reloaded/_config.yml","hash":"bfa42f00053466222d1967fed215a6fa7c1b1eae","modified":1532914368650},{"_id":"themes/next-reloaded/gulpfile.coffee","hash":"67eaf2515100971f6195b60eeebbfe5e8de895ab","modified":1532913596291},{"_id":"source/_posts/clone.md","hash":"a835566c7d801425d237a825afc57379bb73f34c","modified":1532585541138},{"_id":"source/_posts/docker.md","hash":"3af994f7789e8bfe479b5775aeaf0c64076f2ce4","modified":1532079025763},{"_id":"source/_posts/p2p1.md","hash":"3e9edfdb2d57c47df99fafe12b2b017896c3ba1d","modified":1536226134953},{"_id":"source/_posts/p2p2.md","hash":"1fb1d381f3d3831a82a81989eb13bf606bfc92de","modified":1536226185604},{"_id":"source/_posts/p2p3.md","hash":"135ddad1c4f328627992888f9a1f697229d47b1e","modified":1536226210030},{"_id":"source/tags/index.md","hash":"5040eff406a842b0ac1fd1f782cb9c08f5449307","modified":1532914138425},{"_id":"source/_posts/error.md","hash":"fd130d5a99fbfe9d307c027eccbb6a8280bedded","modified":1532675790024},{"_id":"source/_posts/Golang的调度模型概览.md","hash":"0e574e4eebe4c66b02f6c9c84d1e46785c79103c","modified":1533261863526},{"_id":"source/_posts/zero-copy.md","hash":"f610f6f07321302d6d64af8ea6fb738be38cd6a8","modified":1534727176237},{"_id":"source/_posts/RUN vs CMD vs ENTRYPOINT.md","hash":"50b06b9dfb5d1bcba569e3404f752dbf35a60ee1","modified":1534468545554},{"_id":"source/_posts/slice.md","hash":"783985d43be110d0a403723ec8581764b5a5225d","modified":1532675035446},{"_id":"themes/next-reloaded/docs/DATA-FILES.md","hash":"9a1895c0a0db705c4c48f512e86917f9af1ec3fb","modified":1532913596253},{"_id":"themes/next-reloaded/docs/AUTHORS.md","hash":"51a0a13da55ff3d596970b2f9ab4531c6b2211f2","modified":1532913596251},{"_id":"themes/next-reloaded/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"f2fd611a84dd6f9ed5395b63e187e29e9effbcd3","modified":1532913596257},{"_id":"themes/next-reloaded/docs/AGPL3.md","hash":"f463f95b169d64983f59fa6f3e4b6760290a0e6b","modified":1532913596247},{"_id":"themes/next-reloaded/docs/UPDATE-FROM-5.1.X.md","hash":"c9f2ed8e15c137b1885d9ca8b7197d9f457971e9","modified":1532913596262},{"_id":"themes/next-reloaded/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1532913596295},{"_id":"themes/next-reloaded/languages/de.yml","hash":"641e49587d41bb87e4d5932dc3d975754ded7953","modified":1532913596293},{"_id":"themes/next-reloaded/docs/INSTALLATION.md","hash":"b74ef6fedf76cdb156e2265759ee0a789ddd49cc","modified":1532913596255},{"_id":"themes/next-reloaded/docs/ALGOLIA-SEARCH.md","hash":"1dada3c3404445a00367882b8f97cdf092b7943d","modified":1532913596250},{"_id":"themes/next-reloaded/docs/LICENSE","hash":"5b702310012d480b40529fd10cf1872f687277a0","modified":1532913596259},{"_id":"themes/next-reloaded/languages/en.yml","hash":"d66b8b48840443a4f9c72c7696a21e292f685a47","modified":1532913596296},{"_id":"themes/next-reloaded/languages/id.yml","hash":"9709a4dbacc56a1571a96b139b872128d6959e90","modified":1532913596300},{"_id":"themes/next-reloaded/languages/it.yml","hash":"4e3adeb10c0fa627935d69ae1783ce0894f5dee5","modified":1532913596302},{"_id":"themes/next-reloaded/languages/fr.yml","hash":"ebcd1f188af8c3f5ef1f0923e794c839fbfae2d4","modified":1532913596298},{"_id":"themes/next-reloaded/languages/ko.yml","hash":"33e065ceb21590b8eb32430a69e76c2f057eb758","modified":1532913596305},{"_id":"themes/next-reloaded/languages/pt-BR.yml","hash":"dc09e290e908744ca28e093dbdd859ca2a20290e","modified":1532913596309},{"_id":"themes/next-reloaded/languages/ja.yml","hash":"7836f1de1f383d3a53770a03498cc39a37674f0c","modified":1532913596304},{"_id":"themes/next-reloaded/languages/pt.yml","hash":"53e2a52b9d5dc20c04080acd4f5b954e8699780f","modified":1532913596310},{"_id":"themes/next-reloaded/languages/ru.yml","hash":"720b92a9ec075b68737d296b1f29ad8e01151c85","modified":1532913596312},{"_id":"themes/next-reloaded/languages/nl.yml","hash":"060efc260c1c529469d739d97dcee79683e8f411","modified":1532913596307},{"_id":"themes/next-reloaded/languages/tr.yml","hash":"6d2f53d3687a7a46c67c78ab47908accd8812add","modified":1532913596314},{"_id":"themes/next-reloaded/languages/vi.yml","hash":"e2b3b18359ab41d58c64b2002acfedd60a7505a4","modified":1532913596316},{"_id":"themes/next-reloaded/languages/zh-HK.yml","hash":"c22113c4a6c748c18093dae56da5a9e8c5b963cd","modified":1532913596319},{"_id":"themes/next-reloaded/languages/zh-CN.yml","hash":"069f15da910d6f9756be448167c07ea5aa5dc346","modified":1532913596318},{"_id":"themes/next-reloaded/languages/zh-TW.yml","hash":"dbf4dd87716babb2db4f5332fae9ec190a6f636a","modified":1532913596321},{"_id":"themes/next-reloaded/layout/_layout.swig","hash":"2db9b03efc68be842b8f79fe2f0fd7fb09e8885a","modified":1532913596328},{"_id":"themes/next-reloaded/docs/MATH.md","hash":"34a46ca9a05b4570903beaadd4807e6759afb52e","modified":1532913596261},{"_id":"themes/next-reloaded/layout/category.swig","hash":"f0e3338bfa5efb205d2c28e635e9611f1fff3b55","modified":1532913596496},{"_id":"themes/next-reloaded/layout/index.swig","hash":"bdcc9f57adef49706b16b107791cacecbc23c1dc","modified":1532913596498},{"_id":"themes/next-reloaded/layout/page.swig","hash":"9ddf40303f82e3db76d59dc82b6d4eadfed203c6","modified":1532913596498},{"_id":"themes/next-reloaded/layout/archive.swig","hash":"4b53070008775ecfd03953bd1b4adfcb0fabcaac","modified":1532913596495},{"_id":"themes/next-reloaded/layout/post.swig","hash":"0554f42f90f4a524666c2b520be30b689c1d6a87","modified":1532913596498},{"_id":"themes/next-reloaded/scripts/merge-configs.js","hash":"5f96f63e86825fd7028c2522e4111103e261a758","modified":1532913596512},{"_id":"themes/next-reloaded/scripts/helpers.js","hash":"7849f9b9a86fc82d6e186e32a5e26e1f27c49b47","modified":1532913596498},{"_id":"themes/next-reloaded/scripts/merge.js","hash":"39b84b937b2a9608b94e5872349a47200e1800ff","modified":1532913596514},{"_id":"themes/next-reloaded/layout/schedule.swig","hash":"d99b9eff0cff38caf095445f27c08aaf11a5b862","modified":1532913596498},{"_id":"themes/next-reloaded/layout/tag.swig","hash":"7cda2822e50b9fee9848a6b81e6c2d1aca830aeb","modified":1532913596498},{"_id":"themes/next-reloaded/test/.jshintrc","hash":"c9fca43ae0d99718e45a6f5ce736a18ba5fc8fb6","modified":1532913596820},{"_id":"themes/next-reloaded/test/intern.js","hash":"db90b1063356727d72be0d77054fdc32fa882a66","modified":1532913596820},{"_id":"themes/next-reloaded/test/helpers.js","hash":"f25e7f3265eb5a6e1ccbb5e5012fa9bebf134105","modified":1532913596820},{"_id":"themes/next-reloaded/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1532913596726},{"_id":"themes/next-reloaded/docs/ru/INSTALLATION.md","hash":"7b2963daac19b0c14f98ebef375d5fbce8fc3f44","modified":1532913596267},{"_id":"themes/next-reloaded/docs/ru/UPDATE-FROM-5.1.X.md","hash":"1a4e41adcf5831057f3f7b3025ed4a5ef7c442b4","modified":1532913596271},{"_id":"themes/next-reloaded/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"9b512cb820627fcc45c9f77c7a122aa99e021bd5","modified":1532913596275},{"_id":"themes/next-reloaded/docs/ru/DATA-FILES.md","hash":"a51de08657f5946f4028b11373280ddc04639525","modified":1532913596265},{"_id":"themes/next-reloaded/docs/zh-CN/DATA-FILES.md","hash":"67f4a987e7db0ab1ce1ea4c311f2961df07b6681","modified":1532913596280},{"_id":"themes/next-reloaded/docs/ru/README.md","hash":"bbe7ac3ef6352b7fedbba2ab800915e33251adf8","modified":1532913596269},{"_id":"themes/next-reloaded/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"e771c5b745608c6fb5ae2fa1c06c61b3699627ec","modified":1532913596274},{"_id":"themes/next-reloaded/docs/zh-CN/INSTALLATION.md","hash":"baca12cc24be082f1db28c7f283493569666321c","modified":1532913596282},{"_id":"themes/next-reloaded/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"7214fcd1b5830e62b3ac0836ad2d1b0fa391ae12","modified":1532913596284},{"_id":"themes/next-reloaded/docs/zh-CN/CONTRIBUTING.md","hash":"f2a2d6e68c5f65e27303b40f5285a8a4a5adae4c","modified":1532913596277},{"_id":"themes/next-reloaded/docs/zh-CN/MATH.md","hash":"4d68054b062b3c8404b146a155d9624d2d25dd9b","modified":1532913596286},{"_id":"themes/next-reloaded/docs/zh-CN/README.md","hash":"74547943ee6cba2e2bbbd67d306ee4de9db1a2bd","modified":1532913596287},{"_id":"themes/next-reloaded/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"2095d1214a4e519a1d31b67b41c89080fa3285d3","modified":1532913596289},{"_id":"themes/next-reloaded/layout/_custom/sidebar.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1532913596326},{"_id":"themes/next-reloaded/layout/_custom/header.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1532913596325},{"_id":"themes/next-reloaded/layout/_custom/head.swig","hash":"a223919d2e1bf17ca4d6abb2c86f2efca9883dc1","modified":1532913596324},{"_id":"themes/next-reloaded/layout/_macro/post-copyright.swig","hash":"8ff97c3f4eb888207bdc50066053c97d890e0202","modified":1532913596337},{"_id":"themes/next-reloaded/layout/_macro/post-collapse.swig","hash":"8c56dd26157cbc580ae41d97ac34b90ab48ced3f","modified":1532913596335},{"_id":"themes/next-reloaded/layout/_macro/post-related.swig","hash":"e8dfb86eb62b9c2bc1435d6d1afa95d3b4c7b931","modified":1532913596339},{"_id":"themes/next-reloaded/layout/_partials/breadcrumb.swig","hash":"4b48fdbfe3bf41ddeda4ff74c1ff17ab9f15c14e","modified":1532913596348},{"_id":"themes/next-reloaded/layout/_macro/reward.swig","hash":"56733f92352b891b0bb1baca293f68f6c8928b0b","modified":1532913596342},{"_id":"themes/next-reloaded/layout/_partials/comments.swig","hash":"412d2a0e18a237e490e1b8bce5547558768b9da3","modified":1532913596350},{"_id":"themes/next-reloaded/layout/_macro/post.swig","hash":"00cd242c032341ab0fb5d7f66d4a9aa652eab183","modified":1532913596341},{"_id":"themes/next-reloaded/layout/_macro/wechat-subscriber.swig","hash":"7a9b687087793bf5e218cbc345214f927fa5601a","modified":1532913596346},{"_id":"themes/next-reloaded/layout/_partials/page-header.swig","hash":"206cbd6ac9ca6a219a8516f59beae25b3c770199","modified":1532913596367},{"_id":"themes/next-reloaded/layout/_partials/footer.swig","hash":"0d815fc14e58f9ec00b310f7b1d32cc460254610","modified":1532913596352},{"_id":"themes/next-reloaded/layout/_macro/sidebar.swig","hash":"a9519b4f82aa516e516317d0447bf5c5c7ffb544","modified":1532913596344},{"_id":"themes/next-reloaded/layout/_partials/pagination.swig","hash":"914155d5d758306cff405beefd4a07973fd8fc77","modified":1532913596369},{"_id":"themes/next-reloaded/layout/_third-party/bookmark.swig","hash":"ed62ea83d3f2c9db2ea57bf23a7d765ed82504c2","modified":1532913596411},{"_id":"themes/next-reloaded/layout/_third-party/exturl.swig","hash":"53861f78a1fb52e96a43cf6909e1530dcf6cbff8","modified":1532913596458},{"_id":"themes/next-reloaded/layout/_third-party/github-banner.swig","hash":"736cb278fa09d3b4ed6f305b56353941ea918793","modified":1532913596458},{"_id":"themes/next-reloaded/layout/_third-party/pangu.swig","hash":"ccf0035086e14dcefa24c2907301edf4c37d5448","modified":1532913596474},{"_id":"themes/next-reloaded/layout/_third-party/needsharebutton.swig","hash":"debba9b7110f635204a15df148194d4c2fd2668b","modified":1532913596458},{"_id":"themes/next-reloaded/layout/_third-party/rating.swig","hash":"554ec568e9d2c71e4a624a8de3cb5929050811d6","modified":1532913596474},{"_id":"themes/next-reloaded/layout/_third-party/scroll-cookie.swig","hash":"a174d4a0c9188f9c4a2652f49bfa7a60ad0a83e3","modified":1532913596480},{"_id":"themes/next-reloaded/layout/_third-party/copy-code.swig","hash":"c62c37474c8de78cf34e54c6219b503ec28d9815","modified":1532913596443},{"_id":"themes/next-reloaded/layout/_scripts/boostrap.swig","hash":"27fb1d81151b9b79683e488579df19eee7e654d6","modified":1532913596380},{"_id":"themes/next-reloaded/scripts/tags/full-image.js","hash":"ef2c2985a3edb9f69740740c5bc42d4b692c86fd","modified":1532913596522},{"_id":"themes/next-reloaded/scripts/tags/button.js","hash":"510f3711a9c9d3e2a844250647d90e8359e7d130","modified":1532913596516},{"_id":"themes/next-reloaded/layout/_scripts/commons.swig","hash":"f544e21883d249d5a341c684c97bd25831008f07","modified":1532913596380},{"_id":"themes/next-reloaded/scripts/tags/center-quote.js","hash":"4519ab8e6898f2ee90d05cde060375462b937a7d","modified":1532913596518},{"_id":"themes/next-reloaded/scripts/tags/group-pictures.js","hash":"2b969ca830862b2bc119b69ede4bd971e27a6ff8","modified":1532913596524},{"_id":"themes/next-reloaded/scripts/tags/exturl.js","hash":"83e48148d2f4f8543f6833effa8a26eb0b60f2f0","modified":1532913596520},{"_id":"themes/next-reloaded/scripts/tags/include-raw.js","hash":"c68b1e6d4a8236d6731e4175ef3ddc284255d63b","modified":1532913596526},{"_id":"themes/next-reloaded/scripts/tags/note.js","hash":"bd3310a5890bded1bda9ba3ad6f98ee44ecb101a","modified":1532913596530},{"_id":"themes/next-reloaded/scripts/tags/label.js","hash":"bb502616bfabe85de5de903074ec6afe627f8413","modified":1532913596528},{"_id":"themes/next-reloaded/layout/_scripts/noscript.swig","hash":"f8c7e729ad6e72b4c705a2c5d5041589c2b4cc52","modified":1532913596380},{"_id":"themes/next-reloaded/scripts/tags/tabs.js","hash":"2d257e26718d4011509fd6f530d2ea37e50e3e66","modified":1532913596531},{"_id":"themes/next-reloaded/layout/_scripts/vendors.swig","hash":"f134aeb8d5bee351e5277edb92ac694af314b75f","modified":1532913596396},{"_id":"themes/next-reloaded/layout/_third-party/schedule.swig","hash":"db15d7e1552aa2d2386a6b8a33b3b3a40bf9e43d","modified":1532913596474},{"_id":"themes/next-reloaded/source/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1532913596726},{"_id":"themes/next-reloaded/source/css/main.styl","hash":"2a62e2a11e9cdcc69e538d856d6f9ce228a07c93","modified":1532913596726},{"_id":"themes/next-reloaded/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1532913596742},{"_id":"themes/next-reloaded/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1532913596742},{"_id":"themes/next-reloaded/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1532913596726},{"_id":"themes/next-reloaded/source/images/avatar.jpg","hash":"abeef73a074adf043ede2795088e057b243771e5","modified":1534751281035},{"_id":"themes/next-reloaded/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1532913596742},{"_id":"themes/next-reloaded/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1532913596742},{"_id":"themes/next-reloaded/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1532913596742},{"_id":"themes/next-reloaded/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1532913596742},{"_id":"themes/next-reloaded/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1532913596757},{"_id":"themes/next-reloaded/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1532913596742},{"_id":"themes/next-reloaded/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1532913596757},{"_id":"themes/next-reloaded/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1532913596742},{"_id":"themes/next-reloaded/source/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1532913596757},{"_id":"themes/next-reloaded/source/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1532913596757},{"_id":"themes/next-reloaded/source/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1532913596757},{"_id":"themes/next-reloaded/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1532913596742},{"_id":"themes/next-reloaded/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1532913596726},{"_id":"themes/next-reloaded/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1532913596757},{"_id":"themes/next-reloaded/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1532913596380},{"_id":"themes/next-reloaded/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1532913596380},{"_id":"themes/next-reloaded/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1532913596664},{"_id":"themes/next-reloaded/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1532913596664},{"_id":"themes/next-reloaded/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1532913596679},{"_id":"themes/next-reloaded/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1532913596726},{"_id":"themes/next-reloaded/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1532913596726},{"_id":"themes/next-reloaded/source/images/_avatar.jpg","hash":"427a2fbf06958e47005a559f9a4d0dfef320bdf3","modified":1532325708499},{"_id":"themes/next-reloaded/layout/_macro/menu/menu-badge.swig","hash":"4eb8e222dc337211efb0d3bbdb5e29af3e6ecdb8","modified":1532913596332},{"_id":"themes/next-reloaded/layout/_partials/header/brand.swig","hash":"19050627bc23b0b2c2e65e7248c0f88468eb8ea5","modified":1532913596360},{"_id":"themes/next-reloaded/layout/_partials/head/external-fonts.swig","hash":"f5e487b0d213ca0bd94aa30bc23b240d65081627","modified":1532913596354},{"_id":"themes/next-reloaded/layout/_macro/menu/menu-item.swig","hash":"aab518204d3125e948796a9ba6b56b09cade2d92","modified":1532913596333},{"_id":"themes/next-reloaded/layout/_partials/head/head-unique.swig","hash":"0b8349710caf9691741a457aa746add35245048e","modified":1532913596356},{"_id":"themes/next-reloaded/layout/_partials/header/sub-menu.swig","hash":"3f11ae8e9084f39628cd2006931d39a2069b9dd6","modified":1532913596365},{"_id":"themes/next-reloaded/layout/_partials/header/index.swig","hash":"c909f6e96373c151dea325bcddfdd8c9522421b6","modified":1532913596361},{"_id":"themes/next-reloaded/layout/_partials/header/menu.swig","hash":"f3ae3168801304af3d80ec3b84264e1d4201cb89","modified":1532913596363},{"_id":"themes/next-reloaded/layout/_partials/head/head.swig","hash":"09109a5c5a301e7cc5e3c7aec32b0164739fc7d4","modified":1532913596358},{"_id":"themes/next-reloaded/layout/_partials/share/add-this.swig","hash":"9e3d133ac5bcc6cb51702c83b2611a49811abad1","modified":1532913596379},{"_id":"themes/next-reloaded/layout/_third-party/analytics/analytics-with-widget.swig","hash":"ff947f3561b229bc528cb1837d4ca19612219411","modified":1532913596396},{"_id":"themes/next-reloaded/layout/_partials/share/duoshuo_share.swig","hash":"d4fbffd7fa8f2090eb32a871872665d90a885fac","modified":1532913596380},{"_id":"themes/next-reloaded/layout/_third-party/analytics/application-insights.swig","hash":"71397a5823e8ec8aad3b68aace13150623b3e19d","modified":1532913596396},{"_id":"themes/next-reloaded/layout/_partials/share/baidushare.swig","hash":"d9e2d9282f9be6e04eae105964abb81e512bffed","modified":1532913596380},{"_id":"themes/next-reloaded/layout/_third-party/analytics/baidu-analytics.swig","hash":"753d262911c27baf663fcaf199267133528656af","modified":1532913596396},{"_id":"themes/next-reloaded/layout/_third-party/analytics/cnzz-analytics.swig","hash":"a10b7f19d7b5725527514622899df413a34a89db","modified":1532913596396},{"_id":"themes/next-reloaded/layout/_third-party/analytics/busuanzi-counter.swig","hash":"c43f41b7f3c0743d1e673af2e787ea34a67fc9cb","modified":1532913596396},{"_id":"themes/next-reloaded/layout/_third-party/analytics/index.swig","hash":"45f3f629c2aacc381095750e1c8649041a71a84b","modified":1532913596411},{"_id":"themes/next-reloaded/layout/_third-party/analytics/facebook-sdk.swig","hash":"7d94845f96197d9d84a405fa5d4ede75fb81b225","modified":1532913596396},{"_id":"themes/next-reloaded/layout/_third-party/analytics/google-analytics.swig","hash":"cfc932c5db04fef64cc56d3ba0b8ddf3a15a63bd","modified":1532913596411},{"_id":"themes/next-reloaded/layout/_partials/search/index.swig","hash":"f6454c452b2e90a8c760321bce7e3dc6119b71fa","modified":1532913596372},{"_id":"themes/next-reloaded/layout/_third-party/analytics/firestore.swig","hash":"d67d9a176a276cdab6f2bcb7eb3650fbca5459c4","modified":1532913596411},{"_id":"themes/next-reloaded/layout/_third-party/analytics/tencent-mta.swig","hash":"5a8027328f060f965b3014060bebec1d7cf149c1","modified":1532913596411},{"_id":"themes/next-reloaded/layout/_third-party/analytics/vkontakte-api.swig","hash":"f9a1647a8f1866deeb94052d1f87a5df99cb1e70","modified":1532913596411},{"_id":"themes/next-reloaded/layout/_third-party/analytics/tencent-analytics.swig","hash":"8a399df90dadba5ad4e781445b58f4765aeb701e","modified":1532913596411},{"_id":"themes/next-reloaded/layout/_partials/search/localsearch.swig","hash":"b2f0d247b213e4cf8de47af6a304d98070cc7256","modified":1532913596373},{"_id":"themes/next-reloaded/layout/_third-party/analytics/lean-analytics.swig","hash":"809f6d31c24ee0012e12631f5893a79f69e7bc84","modified":1532913596411},{"_id":"themes/next-reloaded/layout/_partials/search/tinysou.swig","hash":"b25002a83cbd2ca0c4a5df87ad5bff26477c0457","modified":1532913596377},{"_id":"themes/next-reloaded/layout/_partials/search/swiftype.swig","hash":"a8c7f9ca7c605d039a1f3bf4e4d3183700a3dd62","modified":1532913596375},{"_id":"themes/next-reloaded/layout/_third-party/comments/index.swig","hash":"34cc66d4dbada2d561ba6f70fd9a75207c5adbd4","modified":1532913596427},{"_id":"themes/next-reloaded/layout/_third-party/comments/changyan.swig","hash":"4c501ea0b9c494181eb3c607c5526a5754e7fbd8","modified":1532913596411},{"_id":"themes/next-reloaded/layout/_third-party/comments/gitment.swig","hash":"292cdd1059b76d3d10486b71c99d9afb3e59ea44","modified":1532913596427},{"_id":"themes/next-reloaded/layout/_third-party/comments/livere.swig","hash":"694483f2d853c65b87a6a70e38dbc40e40eb1332","modified":1532913596427},{"_id":"themes/next-reloaded/layout/_third-party/comments/disqus.swig","hash":"4a2d2269f23e90c1311bd867d22def0b4a092bf1","modified":1532913596427},{"_id":"themes/next-reloaded/layout/_third-party/math/katex.swig","hash":"860de4ce6fccc516d2f779a4b600a4214d8c18e2","modified":1532913596458},{"_id":"themes/next-reloaded/layout/_third-party/math/index.swig","hash":"30e9e55d9af2ced6e6b156a042026a8b480f0ab0","modified":1532913596458},{"_id":"themes/next-reloaded/layout/_third-party/search/index.swig","hash":"34599633658f3b0ffb487728b7766e1c7b551f5a","modified":1532913596488},{"_id":"themes/next-reloaded/layout/_third-party/math/mathjax.swig","hash":"c0c2fd87e71f0beb542aa50c0bc875da5aa5c44b","modified":1532913596458},{"_id":"themes/next-reloaded/layout/_third-party/comments/valine.swig","hash":"d05e70a416963023ee1978e4168d58bcfd956ed3","modified":1532913596427},{"_id":"themes/next-reloaded/layout/_third-party/search/tinysou.swig","hash":"fe95dd3d166634c466e19aa756e65ad6e8254d3e","modified":1532913596491},{"_id":"themes/next-reloaded/layout/_third-party/seo/baidu-push.swig","hash":"d8c98938719284fa06492c114d99a1904652a555","modified":1532913596493},{"_id":"themes/next-reloaded/layout/_scripts/pages/post-details.swig","hash":"580e9d9c4d8783ee6200d845ae16c98979bf1ea3","modified":1532913596380},{"_id":"themes/next-reloaded/layout/_scripts/schemes/pisces.swig","hash":"c381f638315a007b1baf5fea879161001fe50cd0","modified":1532913596396},{"_id":"themes/next-reloaded/layout/_scripts/schemes/gemini.swig","hash":"c381f638315a007b1baf5fea879161001fe50cd0","modified":1532913596380},{"_id":"themes/next-reloaded/source/lib/font-awesome/.npmignore","hash":"c31ff06a740955e44edd4403902e653ccabfd4db","modified":1532913596788},{"_id":"themes/next-reloaded/source/lib/font-awesome/bower.json","hash":"71e7183634dc1b9449f590f15ebd7201add22ca7","modified":1532913596788},{"_id":"themes/next-reloaded/source/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1532913596788},{"_id":"themes/next-reloaded/source/lib/font-awesome/.gitignore","hash":"03ddbf76c1dd1afb93eed0b670d2eee747472ef1","modified":1532913596788},{"_id":"themes/next-reloaded/layout/_third-party/search/localsearch.swig","hash":"71c897f9b107dd0de1b7f649633cf583c206a9db","modified":1532913596488},{"_id":"themes/next-reloaded/source/css/_custom/custom.styl","hash":"3403fdd8efde1a0afd11ae8a5a97673f5903087f","modified":1532913596664},{"_id":"themes/next-reloaded/source/lib/font-awesome/.bower.json","hash":"b4aefc910578d76b267e86dfffdd5121c8db9aec","modified":1532913596788},{"_id":"themes/next-reloaded/source/lib/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1532913596820},{"_id":"themes/next-reloaded/source/lib/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1532913596820},{"_id":"themes/next-reloaded/source/lib/velocity/velocity.ui.js","hash":"dbbfb50f6502f6b81dcc9fee7b31f1e812da3464","modified":1532913596820},{"_id":"themes/next-reloaded/source/css/_mixins/Gemini.styl","hash":"07f7da320689f828f6e36a6123807964a45157a0","modified":1532913596664},{"_id":"themes/next-reloaded/source/css/_mixins/Pisces.styl","hash":"8aa98ae349908736ba43196c42498fd5bdeb780a","modified":1532913596679},{"_id":"themes/next-reloaded/source/js/src/exturl.js","hash":"c48aa4b3c0e578a807fd3661e6cd4f3890777437","modified":1532913596773},{"_id":"themes/next-reloaded/source/js/src/affix.js","hash":"ad343aa406fd8181b5f310434817ce98fc2219e3","modified":1532913596757},{"_id":"themes/next-reloaded/source/js/src/algolia-search.js","hash":"84906eeae57bd06744dd20160b93eacf658f97e2","modified":1532913596757},{"_id":"themes/next-reloaded/source/js/src/motion.js","hash":"6b5a2646b775609630b9ff6221fa58b6823a25fa","modified":1532913596773},{"_id":"themes/next-reloaded/source/js/src/bootstrap.js","hash":"c7e2a588b679d46379124141bb2f30bc2f3210e2","modified":1532913596757},{"_id":"themes/next-reloaded/source/js/src/js.cookie.js","hash":"1512c751d219577d338ac0780fb2bbd9075d5298","modified":1532913596773},{"_id":"themes/next-reloaded/source/js/src/scroll-cookie.js","hash":"c4867626afab749404daf321367f9b6b8e223f69","modified":1532913596773},{"_id":"themes/next-reloaded/source/css/_variables/Mist.styl","hash":"a25408534f8fe6e321db4bbf9dd03335d648fe17","modified":1532913596726},{"_id":"themes/next-reloaded/source/css/_mixins/base.styl","hash":"0882d76333ab409e8d3362c284b91a0f0ae761ae","modified":1532913596679},{"_id":"themes/next-reloaded/source/css/_variables/Gemini.styl","hash":"8d6cf29f63c90364f4d3c336f7c9bb794b4c46cc","modified":1532913596726},{"_id":"themes/next-reloaded/source/js/src/post-details.js","hash":"7d309b771e86c7e22ce11cc25625481ef7d5985c","modified":1532913596773},{"_id":"themes/next-reloaded/source/js/src/utils.js","hash":"9cddff04f9ff64b1e3202e1726eff512a2ef8497","modified":1532913596773},{"_id":"themes/next-reloaded/source/css/_variables/base.styl","hash":"1625e3e1da6c453108526e027dae25e311b18adf","modified":1532913596726},{"_id":"themes/next-reloaded/source/js/src/scrollspy.js","hash":"68d3690152c89e7adb08bb35ec28dbda2bd93686","modified":1532913596773},{"_id":"themes/next-reloaded/source/css/_variables/Pisces.styl","hash":"72927abd51d3a607a6ba32cf882390792b34e834","modified":1532913596726},{"_id":"themes/next-reloaded/source/lib/jquery/index.js","hash":"17a740d68a1c330876c198b6a4d9319f379f3af2","modified":1532913596804},{"_id":"themes/next-reloaded/layout/_third-party/search/algolia-search/dom.swig","hash":"2530de0f3125a912756f6c0e9090cd012134a4c5","modified":1532913596486},{"_id":"themes/next-reloaded/layout/_third-party/search/algolia-search/assets.swig","hash":"6e076b5e183eedf425a445e99851f938789c3194","modified":1532913596484},{"_id":"themes/next-reloaded/source/lib/font-awesome/css/font-awesome.min.css","hash":"88af80502c44cd52ca81ffe7dc7276b7eccb06cf","modified":1532913596788},{"_id":"themes/next-reloaded/source/lib/font-awesome/css/font-awesome.css","hash":"3655f1fdf1e584c4d8e8d39026093ca306a5a341","modified":1532913596788},{"_id":"themes/next-reloaded/source/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1532913596788},{"_id":"themes/next-reloaded/source/css/_common/components/back-to-top.styl","hash":"237d185ac62ec9877e300947fa0109c44fb8db19","modified":1532913596538},{"_id":"themes/next-reloaded/source/css/_common/components/buttons.styl","hash":"8b32928686c327151e13d3ab100157f9a03cd59f","modified":1532913596540},{"_id":"themes/next-reloaded/source/css/_common/components/back-to-top-sidebar.styl","hash":"8f86f694c0749a18ab3ad6f6df75466ca137a4bc","modified":1532913596536},{"_id":"themes/next-reloaded/source/css/_common/components/comments.styl","hash":"ff4489cd582f518bba6909a301ac1292a38b4e96","modified":1532913596542},{"_id":"themes/next-reloaded/source/css/_common/components/components.styl","hash":"7ad4081466b397e2a6204141bb7768b7c01bd93c","modified":1532913596543},{"_id":"themes/next-reloaded/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"41ea797c68dbcff2f6fb3aba1d1043a22e7cc0f6","modified":1532913596804},{"_id":"themes/next-reloaded/source/css/_common/components/pagination.styl","hash":"4f2801fc4cf3f31bf2069f41db8c6ce0e3da9e39","modified":1532913596580},{"_id":"themes/next-reloaded/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"a817b6c158cbc5bab3582713de9fe18a18a80552","modified":1532913596804},{"_id":"themes/next-reloaded/source/css/_common/components/tag-cloud.styl","hash":"6eb4bcc3056bd279d000607e8b4dad50d368ca69","modified":1532913596627},{"_id":"themes/next-reloaded/source/css/_schemes/Mist/_base.styl","hash":"d0e9065b0dbbc01811259f0597d1790268b4881b","modified":1532913596679},{"_id":"themes/next-reloaded/source/css/_schemes/Gemini/index.styl","hash":"7e4e499964c2112d47e6f9d2b6e87c31ec8269e2","modified":1532913596679},{"_id":"themes/next-reloaded/source/css/_common/outline/outline.styl","hash":"fbb6be577529c750ef7c872fe7abdc7ab0faf0f8","modified":1532913596661},{"_id":"themes/next-reloaded/source/css/_schemes/Mist/_header.styl","hash":"d0bfd1bef988c76f7d7dd72d88af6f0908a8b0db","modified":1532913596679},{"_id":"themes/next-reloaded/source/css/_schemes/Mist/_logo.styl","hash":"b1025c421406d2c24cc92a02ae28c1915b01e240","modified":1532913596679},{"_id":"themes/next-reloaded/source/css/_schemes/Mist/_menu.styl","hash":"f3aa863adf972569b72f2df6bc6a914e7daace99","modified":1532913596679},{"_id":"themes/next-reloaded/source/css/_schemes/Mist/_posts-expanded.styl","hash":"fa6c00fdaf8f0ca3b690a5a556671745fb67e2c9","modified":1532913596679},{"_id":"themes/next-reloaded/source/css/_schemes/Mist/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1532913596695},{"_id":"themes/next-reloaded/source/css/_schemes/Muse/_logo.styl","hash":"748dbfbf9c08e719ddc775958003c64b00d39dab","modified":1532913596695},{"_id":"themes/next-reloaded/source/css/_schemes/Muse/_layout.styl","hash":"31127dcbf4c7b4ada53ffbf1638b5fe325b7cbc0","modified":1532913596695},{"_id":"themes/next-reloaded/source/css/_schemes/Muse/index.styl","hash":"b26f8a3394d8357a5bfd24d9f8bf62d7b4063ebb","modified":1532913596710},{"_id":"themes/next-reloaded/source/css/_schemes/Muse/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1532913596695},{"_id":"themes/next-reloaded/source/css/_schemes/Mist/index.styl","hash":"2ccb9bdc309b7c1ef183a3dbb0a4621bec54a328","modified":1532913596695},{"_id":"themes/next-reloaded/source/css/_schemes/Muse/_menu.styl","hash":"3cc7646583218d16925ced7b70865e63a901d4a7","modified":1532913596695},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/base.styl","hash":"97bb39756e85f5b27bba7f43270105ad01d736c9","modified":1532913596664},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/scaffolding.styl","hash":"a17e2b871a335f290afb392a08f94fd35f59c715","modified":1532913596664},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/mobile.styl","hash":"91ca75492cd51f2553f4d294ed2f48239fcd55eb","modified":1532913596664},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/tables.styl","hash":"52bc8ba71b91d954530b35dfc63b402a02b1321d","modified":1532913596664},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/normalize.styl","hash":"3f40e8a9fe8e7bd5cfc4cf4cbbbcb9539462e973","modified":1532913596664},{"_id":"themes/next-reloaded/source/css/_schemes/Pisces/_brand.styl","hash":"bce344d3a665b4c55230d2a91eac2ad16d6f32fd","modified":1532913596710},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/helpers.styl","hash":"1da5c800d025345f212a3bf1be035060f4e5e6ed","modified":1532913596664},{"_id":"themes/next-reloaded/source/css/_schemes/Pisces/_posts.styl","hash":"1f6e2ce674735269599acc6d77b3ea18d31967fc","modified":1532913596710},{"_id":"themes/next-reloaded/source/css/_schemes/Pisces/_layout.styl","hash":"ccf5a4761cb0ce451b5e994cfabf8769248a45c1","modified":1532913596710},{"_id":"themes/next-reloaded/source/css/_schemes/Pisces/_sub-menu.styl","hash":"be72740313a9a0477b8a22f62e4c8ffa6d23a2e5","modified":1532913596710},{"_id":"themes/next-reloaded/source/css/_schemes/Pisces/index.styl","hash":"a558803ca81cceae2bdc22c18ef638fcc023681b","modified":1532913596710},{"_id":"themes/next-reloaded/source/js/src/schemes/pisces.js","hash":"6ed3f2389457daa382de96a08633d9faaaaf53fb","modified":1532913596773},{"_id":"themes/next-reloaded/source/css/_schemes/Pisces/_menu.styl","hash":"cc961108b12ab97d9216606ceb1cd1cd31ab20f0","modified":1532913596710},{"_id":"themes/next-reloaded/source/css/_schemes/Pisces/_sidebar.styl","hash":"df16dc995eb9ad498df2edcfc3e20528fc9aa133","modified":1532913596710},{"_id":"themes/next-reloaded/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1532913596804},{"_id":"themes/next-reloaded/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1532913596804},{"_id":"themes/next-reloaded/source/lib/velocity/velocity.js","hash":"4237c6e9d59da349639de20e559e87c2c0218cfd","modified":1532913596820},{"_id":"themes/next-reloaded/source/css/_common/components/header/header.styl","hash":"34f5ac3c1ed2dd31e9297cc4c0733e71bc2e252f","modified":1532913596554},{"_id":"themes/next-reloaded/source/css/_common/components/header/headerband.styl","hash":"d63e0cacc53dd375fcc113465a4328c59ff5f2c1","modified":1532913596556},{"_id":"themes/next-reloaded/source/css/_common/components/header/github-banner.styl","hash":"3f3d2a43d1a326bad25b633c8ec9ddd87867224c","modified":1532913596552},{"_id":"themes/next-reloaded/source/css/_common/components/header/site-meta.styl","hash":"0656e753f182c9f47fef7304c847b7587a85ef0d","modified":1532913596560},{"_id":"themes/next-reloaded/source/css/_common/components/header/menu.styl","hash":"1a0d059799a298fe17c49a44298d32cebde93785","modified":1532913596558},{"_id":"themes/next-reloaded/source/css/_common/components/header/site-nav.styl","hash":"1727702eac5d326b5c81a667944a245016668231","modified":1532913596562},{"_id":"themes/next-reloaded/source/css/_common/components/footer/footer.styl","hash":"7dd247c8869fdefb5a007045d00f3ef8ceecf300","modified":1532913596546},{"_id":"themes/next-reloaded/source/css/_common/components/highlight/highlight.styl","hash":"835c1340571bd6c4ec263c482cf13283fb047e49","modified":1532913596566},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-button.styl","hash":"62fbbd32cf5a99ae550c45c763a2c4813a138d01","modified":1532913596580},{"_id":"themes/next-reloaded/source/css/_common/components/highlight/diff.styl","hash":"167986d0f649516671ddf7193eebba7b421cd115","modified":1532913596564},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-copyright.styl","hash":"caf263d1928496688c0e1419801eafd7e6919ce5","modified":1532913596580},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-collapse.styl","hash":"875cbe88d5c7f6248990e2beb97c9828920e7e24","modified":1532913596580},{"_id":"themes/next-reloaded/source/css/_common/components/highlight/theme.styl","hash":"7fe4d4d656e86276c17cb4e48a560cb6a4def703","modified":1532913596568},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-gallery.styl","hash":"cd9e214e502697f2f2db84eb721bac57a49b0fce","modified":1532913596580},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-reading_progress.styl","hash":"82bc7fa5d38d98e98cc25f9a73189024fda25e63","modified":1532913596596},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-eof.styl","hash":"a200c0a1c5a895ac9dc41e0641a5dfcd766be99b","modified":1532913596580},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-meta.styl","hash":"330c8884efb5612e7eb03986d87d29e8b0651974","modified":1532913596580},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-expand.styl","hash":"317c9ceda655e9dc373ce8e7b71d20b794fce9a4","modified":1532913596580},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-rtl.styl","hash":"b2495ae5e04dcca610aacadc47881d9e716cd440","modified":1532913596596},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-reward.styl","hash":"ca88ea6999a61fb905eb6e72eba5f92d4ee31e6e","modified":1532913596596},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-tags.styl","hash":"5a982d8ef3b3623ea5f59e63728990f5623c1b57","modified":1532913596596},{"_id":"themes/next-reloaded/source/css/_common/components/sidebar/sidebar-author.styl","hash":"debe322cc9e2688ecf38d0b6afcd6b71ad02fbd0","modified":1532913596612},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-type.styl","hash":"01567edaea6978628aa5521a122a85434c418bfd","modified":1532913596596},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-title.styl","hash":"adfd6d2d3b34adc4b476a0ea91e19020456a3b1a","modified":1532913596596},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-widgets.styl","hash":"5c3141d58970a0614896b6a62fd7a8a8caf4e401","modified":1532913596596},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-nav.styl","hash":"27deb3d3a243d30022055dac7dad851024099a8b","modified":1532913596580},{"_id":"themes/next-reloaded/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"8dd9a1c6f4f6baa00c2cf01837e7617120cf9660","modified":1532913596612},{"_id":"themes/next-reloaded/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"11c22f0fb3f6beb13e5a425ec064a4ff974c13b7","modified":1532913596612},{"_id":"themes/next-reloaded/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"61f8cea3c01acd600e90e1bc2a07def405503748","modified":1532913596612},{"_id":"themes/next-reloaded/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"fa57ec9a6f1943c0558856dfba2d6b8faca0cd4d","modified":1532913596596},{"_id":"themes/next-reloaded/source/css/_common/components/post/post.styl","hash":"bb8162bb7c7b0b255a0e8e234eb382a0879a4962","modified":1532913596596},{"_id":"themes/next-reloaded/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"1153bb71edf253765145559674390e16dd67c633","modified":1532913596612},{"_id":"themes/next-reloaded/source/css/_common/components/sidebar/sidebar.styl","hash":"94d76e6da600a36d80e2470326ebb6b3be447ccb","modified":1532913596612},{"_id":"themes/next-reloaded/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"9e05a2232faabb41bcebb51d545d897a76f077da","modified":1532913596612},{"_id":"themes/next-reloaded/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"a1521d48bb06d8d703753f52a198baa197af7da2","modified":1532913596612},{"_id":"themes/next-reloaded/source/css/_common/components/tags/full-image.styl","hash":"2d58ad90f148e845bc7023751a7a13260600f8d6","modified":1532913596634},{"_id":"themes/next-reloaded/source/css/_common/components/sidebar/site-state.styl","hash":"e71652d3216e289c8548b1ea2357822c1476a425","modified":1532913596612},{"_id":"themes/next-reloaded/source/css/_common/components/tags/exturl.styl","hash":"02ee0eb49c256ecb4e71bbc65072f9147418d7d7","modified":1532913596632},{"_id":"themes/next-reloaded/source/css/_common/components/tags/blockquote-center.styl","hash":"2fe76476432b31993338cb45cdb3b29a518b6379","modified":1532913596627},{"_id":"themes/next-reloaded/source/css/_common/components/tags/group-pictures.styl","hash":"2ad1a2a9bbf6742d1b0762c4c623b68113d1e0fe","modified":1532913596635},{"_id":"themes/next-reloaded/source/css/_common/components/tags/label.styl","hash":"2ab1322fe52ab5aafd49e68f5bd890e8380ee927","modified":1532913596637},{"_id":"themes/next-reloaded/source/css/_common/components/tags/note-modern.styl","hash":"b7076e58d647265ee0ad2b461fe8ce72c9373bc5","modified":1532913596639},{"_id":"themes/next-reloaded/source/css/_common/components/pages/archive.styl","hash":"b6f3a06a94a6ee5470c956663164d58eda818a64","modified":1532913596570},{"_id":"themes/next-reloaded/source/css/_common/components/tags/note.styl","hash":"9a409b798decdefdaf7a23f0b11004a8c27e82f3","modified":1532913596641},{"_id":"themes/next-reloaded/source/css/_common/components/pages/breadcrumb.styl","hash":"630be616447a982413030e561bbd3a80ac14b120","modified":1532913596572},{"_id":"themes/next-reloaded/source/css/_common/components/tags/tags.styl","hash":"b80604868e4f5cf20fccafd7ee415c20c804f700","modified":1532913596644},{"_id":"themes/next-reloaded/source/css/_common/components/tags/tabs.styl","hash":"154a87a32d2fead480d5e909c37f6c476671c5e6","modified":1532913596642},{"_id":"themes/next-reloaded/source/css/_common/components/pages/categories.styl","hash":"7fb593f90d74a99c21840679933b9ef6fdc16a61","modified":1532913596574},{"_id":"themes/next-reloaded/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"a6e7d698702c2e383dde3fde2abde27951679084","modified":1532913596648},{"_id":"themes/next-reloaded/source/css/_common/components/pages/pages.styl","hash":"ad4cae23c8e383f4fabc9a2a95bca6055020d22e","modified":1532913596576},{"_id":"themes/next-reloaded/source/css/_common/components/pages/post-detail.styl","hash":"4e3838d7ac81d9ad133960f0f7ed58a44a015285","modified":1532913596577},{"_id":"themes/next-reloaded/source/css/_common/components/pages/schedule.styl","hash":"8cf318644acc8b4978537c263290363e21c7f5af","modified":1532913596579},{"_id":"themes/next-reloaded/source/css/_common/components/third-party/gitment.styl","hash":"874278147115601d2abf15987f5f7a84ada1ac6b","modified":1532913596650},{"_id":"themes/next-reloaded/source/css/_common/components/third-party/algolia-search.styl","hash":"f4d8144c22544bdb89787c14ab9d39578dae4b7c","modified":1532913596646},{"_id":"themes/next-reloaded/source/css/_common/components/third-party/han.styl","hash":"10599e16414a8b7a76c4e79e6617b5fe3d4d1adf","modified":1532913596652},{"_id":"themes/next-reloaded/source/css/_common/components/third-party/needsharebutton.styl","hash":"28825ae15fa20ae3942cdaa7bcc1f3523ce59acc","modified":1532913596655},{"_id":"themes/next-reloaded/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1532913596804},{"_id":"themes/next-reloaded/source/css/_common/components/third-party/related-posts.styl","hash":"acfdd76b1c90d2e384affb3d0006a39b524609d2","modified":1532913596657},{"_id":"themes/next-reloaded/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1532913596695},{"_id":"themes/next-reloaded/source/css/_common/components/third-party/third-party.styl","hash":"c31fbaec7e6373ecfb8588500b972d451695a6ad","modified":1532913596658},{"_id":"themes/next-reloaded/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1532913596710},{"_id":"themes/next-reloaded/source/css/_schemes/Mist/outline/outline.styl","hash":"a07aa12cc36ac5c819670c2a3c17d07ed7a08986","modified":1532913596695},{"_id":"themes/next-reloaded/source/css/_common/components/third-party/localsearch.styl","hash":"16087276945fa038f199692e3eabb1c52b8ea633","modified":1532913596653},{"_id":"public/tags/index.html","hash":"7fdf486b4f31507379800671758c767556de7260","modified":1536226221608},{"_id":"public/2018/07/16/docker/index.html","hash":"f332aa24b97e9839a4ac1a298ce86b2e02f00cea","modified":1536226221755},{"_id":"public/archives/index.html","hash":"c199384c420fcb777c6eef8048a722dfbc956604","modified":1536226221755},{"_id":"public/archives/page/2/index.html","hash":"ee249d49646cdeff791e9d383f00b8c7a45bfae0","modified":1536226221755},{"_id":"public/archives/2018/index.html","hash":"e31801a8f27edbf80749ea356da6d9c03a892a02","modified":1536226221756},{"_id":"public/archives/2018/page/2/index.html","hash":"61087dd1410152c465faba96c43c91a4797c26ea","modified":1536226221756},{"_id":"public/archives/2018/08/index.html","hash":"09cffbc606336de24179030c47c43f213c291430","modified":1536226221756},{"_id":"public/tags/Java/index.html","hash":"c6a1e2a2c9a28da55dda097bd3ad22162a20ea85","modified":1536226221756},{"_id":"public/archives/2018/07/index.html","hash":"4ea980f86283cb75d51f8194eaf1590400888fb3","modified":1536226221756},{"_id":"public/tags/Go/index.html","hash":"de05f665a6a44aa3a0988252ca75fa73a58c8063","modified":1536226221756},{"_id":"public/tags/Docker/index.html","hash":"76bf57a185a0bd85f96b271be7f51145ddf21e4c","modified":1536226221756},{"_id":"public/tags/Netty/index.html","hash":"6f10c5e61415b3a27f38676a1ede91e23927a2f3","modified":1536226221756},{"_id":"public/2018/09/06/p2p3/index.html","hash":"28199da1cdfbe77a7d7b8950083fbabcea560035","modified":1536226221756},{"_id":"public/2018/09/06/p2p1/index.html","hash":"130ee0346718e96f576ab52a4adf505f2d75849e","modified":1536226221756},{"_id":"public/2018/07/27/error/index.html","hash":"9f8986c593653b4ebcf5f64e74452918bb05943a","modified":1536226221756},{"_id":"public/2018/07/26/clone/index.html","hash":"cd62fec2408e6f6f309aee6b578fbe4b1d25c49a","modified":1536226221756},{"_id":"public/2018/07/16/slice/index.html","hash":"a045c794834d8d4303ce639f46ca4d4c7a3a564b","modified":1536226221756},{"_id":"public/2018/08/17/RUN vs CMD vs ENTRYPOINT/index.html","hash":"49d173da3b85e46933a650e6a85d0705f999799a","modified":1536226221756},{"_id":"public/2018/08/03/Golang的调度模型概览/index.html","hash":"a4070d9883b91b03fbc52350628f31c29fef53a1","modified":1536226221757},{"_id":"public/2018/08/20/zero-copy/index.html","hash":"e34f5d24060f6b4c605865d069b124cc0136dc33","modified":1536226221757},{"_id":"public/index.html","hash":"7ad0759222919a6b4f6358af46089c673f327b30","modified":1536226221757},{"_id":"public/archives/2018/09/index.html","hash":"db697eb649b25ff91d45d9dfb8b45fce6aeeafd6","modified":1536226221762},{"_id":"public/tags/p2p/index.html","hash":"5d9d0f713f5119e0ac58e64679a5ab710c1d4a48","modified":1536226221762},{"_id":"public/2018/09/06/p2p2/index.html","hash":"897ea8b6852da4f283d6984829a9b827755b44ae","modified":1536226221762},{"_id":"public/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1536226221762},{"_id":"public/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1536226221762},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1536226221763},{"_id":"public/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1536226221763},{"_id":"public/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1536226221763},{"_id":"public/images/avatar.jpg","hash":"abeef73a074adf043ede2795088e057b243771e5","modified":1536226310060},{"_id":"public/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1536226221763},{"_id":"public/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1536226221763},{"_id":"public/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1536226221763},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1536226221763},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1536226221763},{"_id":"public/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1536226221763},{"_id":"public/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1536226221763},{"_id":"public/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1536226221763},{"_id":"public/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1536226221763},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1536226221763},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1536226221763},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1536226221763},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1536226221763},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1536226221763},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1536226221763},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1536226222747},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1536226222750},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1536226222752},{"_id":"public/js/src/motion.js","hash":"52fd093cb96b68229b38436c9b8ebcefc7e12cb2","modified":1536226222752},{"_id":"public/js/src/affix.js","hash":"a2aab233d99297435a5274bf512c3c753fe08e80","modified":1536226222752},{"_id":"public/js/src/exturl.js","hash":"54825acc8de4793feac415be227b965428f4e97d","modified":1536226222752},{"_id":"public/js/src/algolia-search.js","hash":"1f7f10c579e7703d0f6acb8b73f3d78a07d0c623","modified":1536226222752},{"_id":"public/js/src/bootstrap.js","hash":"1c41508b83cb0c4512e64b4d63afa1be954ce8ef","modified":1536226222752},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1536226222752},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1536226222752},{"_id":"public/js/src/post-details.js","hash":"0dde5e6d4547587662a3256317a9d5d1db507692","modified":1536226222752},{"_id":"public/js/src/scroll-cookie.js","hash":"d07b3776708d4ae79ed2037c4c7391d5c9b06b19","modified":1536226222752},{"_id":"public/js/src/scrollspy.js","hash":"fa3c92968bcdbcb8d95a1729f7659d9753cbd077","modified":1536226222752},{"_id":"public/js/src/utils.js","hash":"e829806d054991d0324a339993082206ca6026e5","modified":1536226222753},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1536226222753},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1536226222753},{"_id":"public/js/src/schemes/pisces.js","hash":"ab6f13fae0513a9b39f8d8c4c3a4e3928014f046","modified":1536226222753},{"_id":"public/css/main.css","hash":"46fc190ef474aa2f21f5d43f35cd4437b05300ab","modified":1536226222753},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1536226222753},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1536226222753},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1536226222753},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1536226222753},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1536226222753},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1536226222753},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1536226222756},{"_id":"themes/next-reloaded/source/images/avatar1.jpg","hash":"d808844328d91f9e6dd781110de936cd5bb66017","modified":1534750860557},{"_id":"public/images/avatar1.jpg","hash":"d808844328d91f9e6dd781110de936cd5bb66017","modified":1536226310060}],"Category":[],"Data":[],"Page":[{"title":"tags","date":"2018-07-30T01:28:29.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2018-07-30 09:28:29\ntype: \"tags\"\n---\n","updated":"2018-07-30T01:28:58.425Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjlqdfcw90001owv3abgqsbah","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"java的浅拷贝和深拷贝","date":"2018-07-26T06:11:52.000Z","_content":"\n> 浅拷贝\n\n所谓浅拷贝，是指原对象与拷贝对象公用一份实体，仅仅是对象名字不同而已（类似引用，即对原对象起别名），其中任何一个对象改变都会导致其他的对象也跟着它变。\n\n> 深拷贝\n\n所谓深拷贝，就是为新对象开辟一块新的空间，并将原对象的内容拷贝给新开的空间，释放时就不会牵扯到多次析构的问题。\n\n所有对象都继承了父类Object，Object有一个protected修饰的clone()方法：\n\n> protected native Object clone() throws CloneNotSupportedException;\n\n<!-- more -->\n\n当我们想实现一个类的浅拷贝，只需实现Cloneable接口，override父类的clone()方法\n\n```\nimport java.io.Serializable;\nimport java.util.List;\n\npublic class Man implements Cloneable, Serializable {\n    private int age;\n\n    private String name;\n\n    private List<Man> girls;\n\n    public Man(int age, String name, List<Man> girls) {\n        this.age = age;\n        this.name = name;\n        this.girls = girls;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public List<Man> getGirls() {\n        return girls;\n    }\n\n    public void setGirls(List<Man> girls) {\n        this.girls = girls;\n    }\n\n    @Override\n    protected Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n\n    @Override\n    public String toString() {\n        return \"Man{\" +\n                \"age=\" + age +\n                \", name='\" + name + '\\'' +\n                \", girls=\" + girls +\n                '}';\n    }\n}\n```\n\n> 测试如下\n\n```\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Man girl = new Man(18, \"美女\", null);\n        List<Man> girls = new ArrayList<>(1);\n        girls.add(girl);\n        Man man = new Man(25, \"帅哥\", girls);\n        Man clone = null;\n        try {\n            clone = (Man) man.clone();\n        } catch (CloneNotSupportedException e) {\n            e.printStackTrace();\n        }\n        man.setAge(20);\n        man.setName(\"美女\");\n        man.getGirls().get(0).setAge(20);\n        man.getGirls().get(0).setName(null);\n        System.out.println(man);\n        System.out.println(clone);\n    }\n}\n```\n\n> 运行结果如下\n\nMan{age=20, name='美女', girls=[Man{age=20, name='null', girls=null}]}\n\nMan{age=25, name='帅哥', girls=[Man{age=20, name='null', girls=null}]}\n\n> 分析一下，age是int基础数据类型，clone的时候应该是值传递，name是String类型对象，查看SString的源码,没有实现Cloneable接口，但按照运行结果来看对象clone的时候String类型的属性应该是new了一个新的String对象和原来的String属性一模一样，并指向clone对象的String类型的属性，但List<T>确实浅拷贝，只拷贝了原对象的引用，并没有拷贝原对象的值.\n\n```\npublic final class String\n    implements java.io.Serializable, Comparable<String>, CharSequence {\n```\n> 这里有个地方要注意：Arrays.asList(T... a)返回的的ArrayList对象并不是java.util.ArrayList,而是Arrays的一个一个静态内部类，\njava.util.ArrayList实现了Cloneable接口，而Arrays.asList(T... a)返回的的ArrayList没有实现Cloneable接口。\n\n```\n    public static <T> List<T> asList(T... a) {\n        return new ArrayList<>(a);\n    }\n    \n    private static class ArrayList<E> extends AbstractList<E>\n        implements RandomAccess, java.io.Serializable\n\n```\n\n> 从ArrayList的源码可以看出实现的是浅拷贝\n\n```\n    /**\n     * Returns a shallow copy of this <tt>ArrayList</tt> instance.  (The\n     * elements themselves are not copied.)\n     *\n     * @return a clone of this <tt>ArrayList</tt> instance\n     */\n    public Object clone() {\n        try {\n            ArrayList<?> v = (ArrayList<?>) super.clone();\n            v.elementData = Arrays.copyOf(elementData, size);\n            v.modCount = 0;\n            return v;\n        } catch (CloneNotSupportedException e) {\n            // this shouldn't happen, since we are Cloneable\n            throw new InternalError(e);\n        }\n    }\n```\n\n> 假如在开发环境的时候需要clone集合的时候，就很容易出现隐形的bug，下面给出集合的深拷贝的解决方案：就是使用序列化和反序列化，要考虑的对象要实现Serializable接口\n\n```\nimport java.io.*;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Man girl = new Man(18, \"美女\", null);\n        List<Man> girls = new ArrayList<>(2);\n        girls.add(girl);\n        Man man = new Man(25, \"帅哥\", girls);\n        Man clone = null;\n        try {\n            clone = (Man) man.clone();\n            clone.setGirls(depCopy(clone.getGirls()));\n        } catch (CloneNotSupportedException e) {\n            e.printStackTrace();\n        }\n        man.setAge(20);\n        man.setName(\"美女\");\n        man.getGirls().get(0).setAge(20);\n        man.getGirls().get(0).setName(null);\n        System.out.println(man);\n        System.out.println(clone);\n    }\n\n    public static <T> List<T> depCopy(List<T> srcList) {\n        ByteArrayOutputStream byteOut = new ByteArrayOutputStream();\n        try (ObjectOutputStream out = new ObjectOutputStream(byteOut)) {\n            out.writeObject(srcList);\n            ByteArrayInputStream byteIn = new ByteArrayInputStream(byteOut.toByteArray());\n            ObjectInputStream inStream = new ObjectInputStream(byteIn);\n            List<T> destList = (List<T>) inStream.readObject();\n            return destList;\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n}\n\n```\n> 测试结果如下\n\nMan{age=20, name='美女', girls=[Man{age=20, name='null', girls=null}]}\n\nMan{age=25, name='帅哥', girls=[Man{age=18, name='美女', girls=null}]}\n","source":"_posts/clone.md","raw":"---\ntitle: java的浅拷贝和深拷贝\ndate: 2018-7-26 14:11:52\ntags: Java\n---\n\n> 浅拷贝\n\n所谓浅拷贝，是指原对象与拷贝对象公用一份实体，仅仅是对象名字不同而已（类似引用，即对原对象起别名），其中任何一个对象改变都会导致其他的对象也跟着它变。\n\n> 深拷贝\n\n所谓深拷贝，就是为新对象开辟一块新的空间，并将原对象的内容拷贝给新开的空间，释放时就不会牵扯到多次析构的问题。\n\n所有对象都继承了父类Object，Object有一个protected修饰的clone()方法：\n\n> protected native Object clone() throws CloneNotSupportedException;\n\n<!-- more -->\n\n当我们想实现一个类的浅拷贝，只需实现Cloneable接口，override父类的clone()方法\n\n```\nimport java.io.Serializable;\nimport java.util.List;\n\npublic class Man implements Cloneable, Serializable {\n    private int age;\n\n    private String name;\n\n    private List<Man> girls;\n\n    public Man(int age, String name, List<Man> girls) {\n        this.age = age;\n        this.name = name;\n        this.girls = girls;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public List<Man> getGirls() {\n        return girls;\n    }\n\n    public void setGirls(List<Man> girls) {\n        this.girls = girls;\n    }\n\n    @Override\n    protected Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n\n    @Override\n    public String toString() {\n        return \"Man{\" +\n                \"age=\" + age +\n                \", name='\" + name + '\\'' +\n                \", girls=\" + girls +\n                '}';\n    }\n}\n```\n\n> 测试如下\n\n```\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Man girl = new Man(18, \"美女\", null);\n        List<Man> girls = new ArrayList<>(1);\n        girls.add(girl);\n        Man man = new Man(25, \"帅哥\", girls);\n        Man clone = null;\n        try {\n            clone = (Man) man.clone();\n        } catch (CloneNotSupportedException e) {\n            e.printStackTrace();\n        }\n        man.setAge(20);\n        man.setName(\"美女\");\n        man.getGirls().get(0).setAge(20);\n        man.getGirls().get(0).setName(null);\n        System.out.println(man);\n        System.out.println(clone);\n    }\n}\n```\n\n> 运行结果如下\n\nMan{age=20, name='美女', girls=[Man{age=20, name='null', girls=null}]}\n\nMan{age=25, name='帅哥', girls=[Man{age=20, name='null', girls=null}]}\n\n> 分析一下，age是int基础数据类型，clone的时候应该是值传递，name是String类型对象，查看SString的源码,没有实现Cloneable接口，但按照运行结果来看对象clone的时候String类型的属性应该是new了一个新的String对象和原来的String属性一模一样，并指向clone对象的String类型的属性，但List<T>确实浅拷贝，只拷贝了原对象的引用，并没有拷贝原对象的值.\n\n```\npublic final class String\n    implements java.io.Serializable, Comparable<String>, CharSequence {\n```\n> 这里有个地方要注意：Arrays.asList(T... a)返回的的ArrayList对象并不是java.util.ArrayList,而是Arrays的一个一个静态内部类，\njava.util.ArrayList实现了Cloneable接口，而Arrays.asList(T... a)返回的的ArrayList没有实现Cloneable接口。\n\n```\n    public static <T> List<T> asList(T... a) {\n        return new ArrayList<>(a);\n    }\n    \n    private static class ArrayList<E> extends AbstractList<E>\n        implements RandomAccess, java.io.Serializable\n\n```\n\n> 从ArrayList的源码可以看出实现的是浅拷贝\n\n```\n    /**\n     * Returns a shallow copy of this <tt>ArrayList</tt> instance.  (The\n     * elements themselves are not copied.)\n     *\n     * @return a clone of this <tt>ArrayList</tt> instance\n     */\n    public Object clone() {\n        try {\n            ArrayList<?> v = (ArrayList<?>) super.clone();\n            v.elementData = Arrays.copyOf(elementData, size);\n            v.modCount = 0;\n            return v;\n        } catch (CloneNotSupportedException e) {\n            // this shouldn't happen, since we are Cloneable\n            throw new InternalError(e);\n        }\n    }\n```\n\n> 假如在开发环境的时候需要clone集合的时候，就很容易出现隐形的bug，下面给出集合的深拷贝的解决方案：就是使用序列化和反序列化，要考虑的对象要实现Serializable接口\n\n```\nimport java.io.*;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Man girl = new Man(18, \"美女\", null);\n        List<Man> girls = new ArrayList<>(2);\n        girls.add(girl);\n        Man man = new Man(25, \"帅哥\", girls);\n        Man clone = null;\n        try {\n            clone = (Man) man.clone();\n            clone.setGirls(depCopy(clone.getGirls()));\n        } catch (CloneNotSupportedException e) {\n            e.printStackTrace();\n        }\n        man.setAge(20);\n        man.setName(\"美女\");\n        man.getGirls().get(0).setAge(20);\n        man.getGirls().get(0).setName(null);\n        System.out.println(man);\n        System.out.println(clone);\n    }\n\n    public static <T> List<T> depCopy(List<T> srcList) {\n        ByteArrayOutputStream byteOut = new ByteArrayOutputStream();\n        try (ObjectOutputStream out = new ObjectOutputStream(byteOut)) {\n            out.writeObject(srcList);\n            ByteArrayInputStream byteIn = new ByteArrayInputStream(byteOut.toByteArray());\n            ObjectInputStream inStream = new ObjectInputStream(byteIn);\n            List<T> destList = (List<T>) inStream.readObject();\n            return destList;\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n}\n\n```\n> 测试结果如下\n\nMan{age=20, name='美女', girls=[Man{age=20, name='null', girls=null}]}\n\nMan{age=25, name='帅哥', girls=[Man{age=18, name='美女', girls=null}]}\n","slug":"clone","published":1,"updated":"2018-07-26T06:12:21.138Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlqdfcw20000owv3q8mb2ixf","content":"<blockquote>\n<p>浅拷贝</p>\n</blockquote>\n<p>所谓浅拷贝，是指原对象与拷贝对象公用一份实体，仅仅是对象名字不同而已（类似引用，即对原对象起别名），其中任何一个对象改变都会导致其他的对象也跟着它变。</p>\n<blockquote>\n<p>深拷贝</p>\n</blockquote>\n<p>所谓深拷贝，就是为新对象开辟一块新的空间，并将原对象的内容拷贝给新开的空间，释放时就不会牵扯到多次析构的问题。</p>\n<p>所有对象都继承了父类Object，Object有一个protected修饰的clone()方法：</p>\n<blockquote>\n<p>protected native Object clone() throws CloneNotSupportedException;</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>当我们想实现一个类的浅拷贝，只需实现Cloneable接口，override父类的clone()方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.io.Serializable;</span><br><span class=\"line\">import java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Man implements Cloneable, Serializable &#123;</span><br><span class=\"line\">    private int age;</span><br><span class=\"line\"></span><br><span class=\"line\">    private String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    private List&lt;Man&gt; girls;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Man(int age, String name, List&lt;Man&gt; girls) &#123;</span><br><span class=\"line\">        this.age = age;</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">        this.girls = girls;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public int getAge() &#123;</span><br><span class=\"line\">        return age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setAge(int age) &#123;</span><br><span class=\"line\">        this.age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String getName() &#123;</span><br><span class=\"line\">        return name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setName(String name) &#123;</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public List&lt;Man&gt; getGirls() &#123;</span><br><span class=\"line\">        return girls;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setGirls(List&lt;Man&gt; girls) &#123;</span><br><span class=\"line\">        this.girls = girls;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected Object clone() throws CloneNotSupportedException &#123;</span><br><span class=\"line\">        return super.clone();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public String toString() &#123;</span><br><span class=\"line\">        return &quot;Man&#123;&quot; +</span><br><span class=\"line\">                &quot;age=&quot; + age +</span><br><span class=\"line\">                &quot;, name=&apos;&quot; + name + &apos;\\&apos;&apos; +</span><br><span class=\"line\">                &quot;, girls=&quot; + girls +</span><br><span class=\"line\">                &apos;&#125;&apos;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>测试如下</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.util.ArrayList;</span><br><span class=\"line\">import java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Main &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Man girl = new Man(18, &quot;美女&quot;, null);</span><br><span class=\"line\">        List&lt;Man&gt; girls = new ArrayList&lt;&gt;(1);</span><br><span class=\"line\">        girls.add(girl);</span><br><span class=\"line\">        Man man = new Man(25, &quot;帅哥&quot;, girls);</span><br><span class=\"line\">        Man clone = null;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            clone = (Man) man.clone();</span><br><span class=\"line\">        &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        man.setAge(20);</span><br><span class=\"line\">        man.setName(&quot;美女&quot;);</span><br><span class=\"line\">        man.getGirls().get(0).setAge(20);</span><br><span class=\"line\">        man.getGirls().get(0).setName(null);</span><br><span class=\"line\">        System.out.println(man);</span><br><span class=\"line\">        System.out.println(clone);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>运行结果如下</p>\n</blockquote>\n<p>Man{age=20, name=’美女’, girls=[Man{age=20, name=’null’, girls=null}]}</p>\n<p>Man{age=25, name=’帅哥’, girls=[Man{age=20, name=’null’, girls=null}]}</p>\n<blockquote>\n<p>分析一下，age是int基础数据类型，clone的时候应该是值传递，name是String类型对象，查看SString的源码,没有实现Cloneable接口，但按照运行结果来看对象clone的时候String类型的属性应该是new了一个新的String对象和原来的String属性一模一样，并指向clone对象的String类型的属性，但List<t>确实浅拷贝，只拷贝了原对象的引用，并没有拷贝原对象的值.</t></p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public final class String</span><br><span class=\"line\">    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这里有个地方要注意：Arrays.asList(T… a)返回的的ArrayList对象并不是java.util.ArrayList,而是Arrays的一个一个静态内部类，<br>java.util.ArrayList实现了Cloneable接口，而Arrays.asList(T… a)返回的的ArrayList没有实现Cloneable接口。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static &lt;T&gt; List&lt;T&gt; asList(T... a) &#123;</span><br><span class=\"line\">    return new ArrayList&lt;&gt;(a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span><br><span class=\"line\">    implements RandomAccess, java.io.Serializable</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>从ArrayList的源码可以看出实现的是浅拷贝</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Returns a shallow copy of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance.  (The</span><br><span class=\"line\"> * elements themselves are not copied.)</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @return a clone of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance</span><br><span class=\"line\"> */</span><br><span class=\"line\">public Object clone() &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) super.clone();</span><br><span class=\"line\">        v.elementData = Arrays.copyOf(elementData, size);</span><br><span class=\"line\">        v.modCount = 0;</span><br><span class=\"line\">        return v;</span><br><span class=\"line\">    &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class=\"line\">        // this shouldn&apos;t happen, since we are Cloneable</span><br><span class=\"line\">        throw new InternalError(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>假如在开发环境的时候需要clone集合的时候，就很容易出现隐形的bug，下面给出集合的深拷贝的解决方案：就是使用序列化和反序列化，要考虑的对象要实现Serializable接口</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.io.*;</span><br><span class=\"line\">import java.util.ArrayList;</span><br><span class=\"line\">import java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Main &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Man girl = new Man(18, &quot;美女&quot;, null);</span><br><span class=\"line\">        List&lt;Man&gt; girls = new ArrayList&lt;&gt;(2);</span><br><span class=\"line\">        girls.add(girl);</span><br><span class=\"line\">        Man man = new Man(25, &quot;帅哥&quot;, girls);</span><br><span class=\"line\">        Man clone = null;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            clone = (Man) man.clone();</span><br><span class=\"line\">            clone.setGirls(depCopy(clone.getGirls()));</span><br><span class=\"line\">        &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        man.setAge(20);</span><br><span class=\"line\">        man.setName(&quot;美女&quot;);</span><br><span class=\"line\">        man.getGirls().get(0).setAge(20);</span><br><span class=\"line\">        man.getGirls().get(0).setName(null);</span><br><span class=\"line\">        System.out.println(man);</span><br><span class=\"line\">        System.out.println(clone);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static &lt;T&gt; List&lt;T&gt; depCopy(List&lt;T&gt; srcList) &#123;</span><br><span class=\"line\">        ByteArrayOutputStream byteOut = new ByteArrayOutputStream();</span><br><span class=\"line\">        try (ObjectOutputStream out = new ObjectOutputStream(byteOut)) &#123;</span><br><span class=\"line\">            out.writeObject(srcList);</span><br><span class=\"line\">            ByteArrayInputStream byteIn = new ByteArrayInputStream(byteOut.toByteArray());</span><br><span class=\"line\">            ObjectInputStream inStream = new ObjectInputStream(byteIn);</span><br><span class=\"line\">            List&lt;T&gt; destList = (List&lt;T&gt;) inStream.readObject();</span><br><span class=\"line\">            return destList;</span><br><span class=\"line\">        &#125; catch (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>测试结果如下</p>\n</blockquote>\n<p>Man{age=20, name=’美女’, girls=[Man{age=20, name=’null’, girls=null}]}</p>\n<p>Man{age=25, name=’帅哥’, girls=[Man{age=18, name=’美女’, girls=null}]}</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>浅拷贝</p>\n</blockquote>\n<p>所谓浅拷贝，是指原对象与拷贝对象公用一份实体，仅仅是对象名字不同而已（类似引用，即对原对象起别名），其中任何一个对象改变都会导致其他的对象也跟着它变。</p>\n<blockquote>\n<p>深拷贝</p>\n</blockquote>\n<p>所谓深拷贝，就是为新对象开辟一块新的空间，并将原对象的内容拷贝给新开的空间，释放时就不会牵扯到多次析构的问题。</p>\n<p>所有对象都继承了父类Object，Object有一个protected修饰的clone()方法：</p>\n<blockquote>\n<p>protected native Object clone() throws CloneNotSupportedException;</p>\n</blockquote>","more":"<p>当我们想实现一个类的浅拷贝，只需实现Cloneable接口，override父类的clone()方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.io.Serializable;</span><br><span class=\"line\">import java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Man implements Cloneable, Serializable &#123;</span><br><span class=\"line\">    private int age;</span><br><span class=\"line\"></span><br><span class=\"line\">    private String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    private List&lt;Man&gt; girls;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Man(int age, String name, List&lt;Man&gt; girls) &#123;</span><br><span class=\"line\">        this.age = age;</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">        this.girls = girls;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public int getAge() &#123;</span><br><span class=\"line\">        return age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setAge(int age) &#123;</span><br><span class=\"line\">        this.age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String getName() &#123;</span><br><span class=\"line\">        return name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setName(String name) &#123;</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public List&lt;Man&gt; getGirls() &#123;</span><br><span class=\"line\">        return girls;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setGirls(List&lt;Man&gt; girls) &#123;</span><br><span class=\"line\">        this.girls = girls;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected Object clone() throws CloneNotSupportedException &#123;</span><br><span class=\"line\">        return super.clone();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public String toString() &#123;</span><br><span class=\"line\">        return &quot;Man&#123;&quot; +</span><br><span class=\"line\">                &quot;age=&quot; + age +</span><br><span class=\"line\">                &quot;, name=&apos;&quot; + name + &apos;\\&apos;&apos; +</span><br><span class=\"line\">                &quot;, girls=&quot; + girls +</span><br><span class=\"line\">                &apos;&#125;&apos;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>测试如下</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.util.ArrayList;</span><br><span class=\"line\">import java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Main &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Man girl = new Man(18, &quot;美女&quot;, null);</span><br><span class=\"line\">        List&lt;Man&gt; girls = new ArrayList&lt;&gt;(1);</span><br><span class=\"line\">        girls.add(girl);</span><br><span class=\"line\">        Man man = new Man(25, &quot;帅哥&quot;, girls);</span><br><span class=\"line\">        Man clone = null;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            clone = (Man) man.clone();</span><br><span class=\"line\">        &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        man.setAge(20);</span><br><span class=\"line\">        man.setName(&quot;美女&quot;);</span><br><span class=\"line\">        man.getGirls().get(0).setAge(20);</span><br><span class=\"line\">        man.getGirls().get(0).setName(null);</span><br><span class=\"line\">        System.out.println(man);</span><br><span class=\"line\">        System.out.println(clone);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>运行结果如下</p>\n</blockquote>\n<p>Man{age=20, name=’美女’, girls=[Man{age=20, name=’null’, girls=null}]}</p>\n<p>Man{age=25, name=’帅哥’, girls=[Man{age=20, name=’null’, girls=null}]}</p>\n<blockquote>\n<p>分析一下，age是int基础数据类型，clone的时候应该是值传递，name是String类型对象，查看SString的源码,没有实现Cloneable接口，但按照运行结果来看对象clone的时候String类型的属性应该是new了一个新的String对象和原来的String属性一模一样，并指向clone对象的String类型的属性，但List<t>确实浅拷贝，只拷贝了原对象的引用，并没有拷贝原对象的值.</t></p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public final class String</span><br><span class=\"line\">    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这里有个地方要注意：Arrays.asList(T… a)返回的的ArrayList对象并不是java.util.ArrayList,而是Arrays的一个一个静态内部类，<br>java.util.ArrayList实现了Cloneable接口，而Arrays.asList(T… a)返回的的ArrayList没有实现Cloneable接口。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static &lt;T&gt; List&lt;T&gt; asList(T... a) &#123;</span><br><span class=\"line\">    return new ArrayList&lt;&gt;(a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span><br><span class=\"line\">    implements RandomAccess, java.io.Serializable</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>从ArrayList的源码可以看出实现的是浅拷贝</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Returns a shallow copy of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance.  (The</span><br><span class=\"line\"> * elements themselves are not copied.)</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @return a clone of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance</span><br><span class=\"line\"> */</span><br><span class=\"line\">public Object clone() &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) super.clone();</span><br><span class=\"line\">        v.elementData = Arrays.copyOf(elementData, size);</span><br><span class=\"line\">        v.modCount = 0;</span><br><span class=\"line\">        return v;</span><br><span class=\"line\">    &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class=\"line\">        // this shouldn&apos;t happen, since we are Cloneable</span><br><span class=\"line\">        throw new InternalError(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>假如在开发环境的时候需要clone集合的时候，就很容易出现隐形的bug，下面给出集合的深拷贝的解决方案：就是使用序列化和反序列化，要考虑的对象要实现Serializable接口</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.io.*;</span><br><span class=\"line\">import java.util.ArrayList;</span><br><span class=\"line\">import java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Main &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Man girl = new Man(18, &quot;美女&quot;, null);</span><br><span class=\"line\">        List&lt;Man&gt; girls = new ArrayList&lt;&gt;(2);</span><br><span class=\"line\">        girls.add(girl);</span><br><span class=\"line\">        Man man = new Man(25, &quot;帅哥&quot;, girls);</span><br><span class=\"line\">        Man clone = null;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            clone = (Man) man.clone();</span><br><span class=\"line\">            clone.setGirls(depCopy(clone.getGirls()));</span><br><span class=\"line\">        &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        man.setAge(20);</span><br><span class=\"line\">        man.setName(&quot;美女&quot;);</span><br><span class=\"line\">        man.getGirls().get(0).setAge(20);</span><br><span class=\"line\">        man.getGirls().get(0).setName(null);</span><br><span class=\"line\">        System.out.println(man);</span><br><span class=\"line\">        System.out.println(clone);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static &lt;T&gt; List&lt;T&gt; depCopy(List&lt;T&gt; srcList) &#123;</span><br><span class=\"line\">        ByteArrayOutputStream byteOut = new ByteArrayOutputStream();</span><br><span class=\"line\">        try (ObjectOutputStream out = new ObjectOutputStream(byteOut)) &#123;</span><br><span class=\"line\">            out.writeObject(srcList);</span><br><span class=\"line\">            ByteArrayInputStream byteIn = new ByteArrayInputStream(byteOut.toByteArray());</span><br><span class=\"line\">            ObjectInputStream inStream = new ObjectInputStream(byteIn);</span><br><span class=\"line\">            List&lt;T&gt; destList = (List&lt;T&gt;) inStream.readObject();</span><br><span class=\"line\">            return destList;</span><br><span class=\"line\">        &#125; catch (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>测试结果如下</p>\n</blockquote>\n<p>Man{age=20, name=’美女’, girls=[Man{age=20, name=’null’, girls=null}]}</p>\n<p>Man{age=25, name=’帅哥’, girls=[Man{age=18, name=’美女’, girls=null}]}</p>"},{"title":"P2P技术详解(一)：NAT详解——详细原理、P2P简介","date":"2018-09-06T09:27:56.000Z","_content":"\n# 1. IPv4协议和NAT的由来\n\n今天，无数快乐的互联网用户在尽情享受Internet带来的乐趣。他们浏览新闻，搜索资料，下载软件，广交新朋，分享信息，甚至于足不出户获取一切日用所需。企业利用互联网发布信息，传递资料和订单，提供技术支持，完成日常办公。然而，Internet在给亿万用户带来便利的同时，自身却面临一个致命的问题：构建这个无所不能的Internet的基础IPv4协议已经不能再提供新的网络地址了。\n\n2011年2月3日中国农历新年， IANA对外宣布：IPv4地址空间最后5个地址块已经被分配给下属的5个地区委员会。2011年4月15日，亚太区委员会APNIC对外宣布，除了个别保留地址外，本区域所有的IPv4地址基本耗尽。一时之间，IPv4地址作为一种濒危资源身价陡增，各大网络公司出巨资收购剩余的空闲地址。其实，IPv4地址不足问题已不是新问题，早在20年以前，IPv4地址即将耗尽的问题就已经摆在Internet先驱们面前。这不禁让我们想去了解，是什么技术使这一危机延缓了尽20年。\n\n要找到问题的答案，让我们先来简略回顾一下IPv4协议。\n\nIPv4即网际网协议第4版——Internet Protocol Version 4的缩写。IPv4定义一个跨越异种网络互连的超级网，它为每个网际网的节点分配全球唯一IP地址。如果我们把Internet比作一个邮政系统，那么IP地址的作用就等同于包含城市、街区、门牌编号在内的完整地址。IPv4使用32bits整数表达一个地址，地址最大范围就是232 约为43亿。以IP创始时期可被联网的设备来看，这样的一个空间已经很大，很难被短时间用完。然而，事实远远超出人们的设想，计算机网络在此后的几十年里迅速壮大，网络终端数量呈爆炸性增长。\n\n更为糟糕的是，为了路由和管理方便，43亿的地址空间被按照不同前缀长度划分为A,B,C,D类地址网络和保留地址。其中，A类网络地址127段，每段包括主机地址约1678万个。B类网络地址16384段，每段包括65536个主机地址。\n\n![image](http://www.52im.net/data/attachment/forum/201509/06/200926crr724j68tledk1p.png)\n\nIANA向超大型企业/组织分配A类网络地址，一次一段。向中型企业或教育机构分配B类网络地址，一次一段。这样一种分配策略使得IP地址浪费很严重，很多被分配出去的地址没有真实被利用，地址消耗很快。以至于二十世纪90年代初，网络专家们意识到，这样大手大脚下去，IPv4地址很快就要耗光了。于是，人们开始考虑IPv4的替代方案，同时采取一系列的措施来减缓IPv4地址的消耗。正是在这样一个背景之下，本期的主角闪亮登场，它就是网络地址转换——NAT。\n\nNAT是一项神奇的技术，说它神奇在于它的出现几乎使IPv4起死回生。在IPv4已经被认为行将结束历史使命之后近20年时间里，人们几乎忘了IPv4的地址空间即将耗尽这样一个事实——在新技术日新月异的时代，20年可算一段漫长的历史。更不用说，在NAT产生以后，网络终端的数量呈加速上升趋势，对IP地址的需求剧烈增加。此足见NAT技术之成功，影响之深远。\n\n说它神奇，更因为NAT给IP网络模型带来了深远影响，其身影遍布网络每个角落。根据一份最近的研究报告，70%的P2P用户位于NAT网关以内。因为P2P主要运行在终端用户的个人电脑之上，这个数字意味着大多数PC通过NAT网关连接到Internet。如果加上2G和3G方式联网的智能手机等移动终端，在NAT网关之后的用户远远超过这个比例。\n\n然而当我们求本溯源时却发现一个很奇怪的事实：NAT这一意义重大的技术，竟然没有公认的发明者。NAT第一个版本的RFC作者，只是整理归纳了已被广泛采用的技术。\n\n<!-- more -->\n\n# 2. NAT的工作模型和特点\n\n> 2.1 NAT的概念模型\n\nNAT名字很准确，网络地址转换，就是替换IP报文头部的地址信息。NAT通常部署在一个组织的网络出口位置，通过将内部网络IP地址替换为出口的IP地址提供公网可达性和上层协议的连接能力。那么，什么是内部网络IP地址？\n\nRFC1918规定了三个保留地址段落：10.0.0.0-10.255.255.255；172.16.0.0-172.31.255.255；192.168.0.0-192.168.255.255。这三个范围分别处于A,B,C类的地址段，不向特定的用户分配，被IANA作为私有地址保留。这些地址可以在任何组织或企业内部使用，和其他Internet地址的区别就是，仅能在内部使用，不能作为全球路由地址。这就是说，出了组织的管理范围这些地址就不再有意义，无论是作为源地址，还是目的地址。对于一个封闭的组织，如果其网络不连接到Internet，就可以使用这些地址而不用向IANA提出申请，而在内部的路由管理和报文传递方式与其他网络没有差异。\n\n对于有Internet访问需求而内部又使用私有地址的网络，就要在组织的出口位置部署NAT网关，在报文离开私网进入Internet时，将源IP替换为公网地址，通常是出口设备的接口地址。一个对外的访问请求在到达目标以后，表现为由本组织出口设备发起，因此被请求的服务端可将响应由Internet发回出口网关。出口网关再将目的地址替换为私网的源主机地址，发回内部。这样一次由私网主机向公网服务端的请求和响应就在通信两端均无感知的情况下完成了。依据这种模型，数量庞大的内网主机就不再需要公有IP地址了。\n\n![image](http://www.52im.net/data/attachment/forum/201509/06/202518pip8a6h99c8xc6i6.png)\n\n虽然实际过程远比这个复杂，但上面的描述概括了NAT处理报文的几个关键特点：\n1. 网络被分为私网和公网两个部分，NAT网关设置在私网到公网的路由出口位置，双向流量必须都要经过NAT网关；\n2. 网络访问只能先由私网侧发起，公网无法主动访问私网主机； \n3. NAT网关在两个访问方向上完成两次地址的转换或翻译，出方向做源信息替换，入方向做目的信息替换； \n4. NAT网关的存在对通信双方是保持透明的； \n5. NAT网关为了实现双向翻译的功能，需要维护一张关联表，把会话的信息保存下来。\n\n随着后面对NAT的深入描述，读者会发现，这些特点是鲜明的，但又不是绝对的。其中第二个特点打破了IP协议架构中所有节点在通讯中的对等地位，这是NAT最大的弊端，为对等通讯带来了诸多问题，当然相应的克服手段也应运而生。事实上，第四点是NAT致力于达到的目标，但在很多情况下，NAT并没有做到，因为除了IP首部，上层通信协议经常在内部携带IP地址信息。这些我们稍后解释。\n\n> 2.2 一对一的NAT\n\n如果一个内部主机唯一占用一个公网IP，这种方式被称为一对一模型。此种方式下，转换上层协议就是不必要的，因为一个公网IP就能唯一对应一个内部主机。显然，这种方式对节约公网IP没有太大意义，主要是为了实现一些特殊的组网需求。比如用户希望隐藏内部主机的真实IP，或者实现两个IP地址重叠网络的通信。\n\n> 2.3 一对多的NAT\n\nNAT最典型的应用场景就如同图2描述的，一个组织网络，在出口位置部署NAT网关，所有对公网的访问表现为一台主机。这就是所谓的一对多模型。这种方式下，出口设备只占用一个由Internet服务提供商分配的公网IP地址。面对私网内部数量庞大的主机，如果NAT只进行IP地址的简单替换，就会产生一个问题：当有多个内部主机去访问同一个服务器时，从返回的信息不足以区分响应应该转发到哪个内部主机。此时，需要NAT设备根据传输层信息或其他上层协议去区分不同的会话，并且可能要对上层协议的标识进行转换，比如TCP或UDP端口号。这样NAT网关就可以将不同的内部连接访问映射到同一公网IP的不同传输层端口，通过这种方式实现公网IP的复用和解复用。这种方式也被称为端口转换PAT、NAPT或IP伪装，但更多时候直接被称为NAT，因为它是最典型的一种应用模式。\n\n> 2.4 按照NAT端口映射方式分类\n\n在一对多模型中，按照端口转换的工作方式不同，又可以进行更进一步的划分。为描述方便，以下将IP和端口标记为(nAddr:nPort)，其中n代表主机或NAT网关的不同角色。\n\n![image](http://www.52im.net/data/attachment/forum/201509/06/202751b5p2nmsj6nu5sujj.png)\n\n- 全锥形NAT\n\n其特点为：一旦内部主机端口对(iAddr:iPort)被NAT网关映射到(eAddr:ePort)，所有后续的(iAddr:iPort)报文都会被转换为(eAddr:ePort)；任何一个外部主机发送到(eAddr:ePort)的报文将会被转换后发到(iAddr:iPort)。\n\n- 限制锥形NAT\n\n其特点为：一旦内部主机端口对(iAddr:iPort)被映射到(eAddr:ePort)，所有后续的(iAddr:iPort)报文都会被转换为(eAddr:ePort)；只有 (iAddr:iPort)向特定的外部主机hAddr发送过数据，主机hAddr从任意端口发送到(eAddr:ePort)的报文将会被转发到(iAddr:iPort)。\n\n- 端口限制锥形NAT\n\n其特点为：一旦内部主机端口对(iAddr:iPort)被映射到(eAddr:ePort)，所有后续的(iAddr:iPort)报文都会被转换为(eAddr:ePort)；只有(iAddr:iPort)向特定的外部主机端口对(hAddr:hPort)发送过数据，由 (hAddr:hPort)发送到(eAddr:ePort)的报文将会被转发到(iAddr:iPort)。\n\n- 对称型NAT\n\n其特点为：NAT网关会把内部主机“地址端口对”和外部主机“地址端口对”完全相同的报文看作一个连接，在网关上创建一个公网“地址端口对”映射进行转换，只有收到报文的外部主机从对应的端口对发送回应的报文，才能被转换。即使内部主机使用之前用过的地址端口对去连接不同外部主机(或端口)时，NAT网关也会建立新的映射关系。\n\n事实上，这些术语的引入是很多混淆的起源。现实中的很多NAT设备是将这些转换方式混合在一起工作的，而不单单使用一种，所以这些术语只适合描述一种工作方式，而不是一个设备。比如，很多NAT设备对内部发出的连接使用对称型NAT方式，而同时支持静态的端口映射，后者可以被看作是全锥型NAT方式。而有些情况下，NAT设备的一个公网地址和端口可以同时映射到内部几个服务器上以实现负载分担，比如一个对外提供WEB服务器的站点可能是有成百上千个服务器在提供HTTP服务，但是对外却表现为一个或少数几个IP地址。\n\n# 3. NAT的限制与解决方案\n\n> 3.1 IP端到端服务模型\n\nIP协议的一个重要贡献是把世界变得平等。在理论上，具有IP地址的每个站点在协议层面有相当的获取服务和提供服务的能力，不同的IP地址之间没有差异。人们熟知的服务器和客户机实际是在应用协议层上的角色区分，而在网络层和传输层没有差异。一个具有IP地址的主机既可以是客户机，也可以是服务器，大部分情况下，既是客户机，也是服务器。端到端对等看起来是很平常的事情，而意义并不寻常。但在以往的技术中，很多协议体系下的网络限定了终端的能力。正是IP的这个开放性，使得TCP/IP协议族可以提供丰富的功能，为应用实现提供了广阔平台。因为所有的IP主机都可以服务器的形式出现，所以通讯设计可以更加灵活。使用UNIX/LINUX的系统充分利用了这个特性，使得任何一个主机都可以建立自己的HTTP、SMTP、POP3、DNS、DHCP等服务。与此同时，很多应用也是把客户端和服务器的角色组合起来完成功能。例如在VoIP应用中，用户端向注册服务器登录自己的IP地址和端口信息过程中，主机是客户端；而在呼叫到达时，呼叫处理服务器向用户端发送呼叫请求时，用户端实际工作在服务器模式下。在语音媒体流信道建立过程后，通讯双向发送语音数据，发送端是客户模式，接收端是服务器模式。而在P2P的应用中，一个用户的主机既为下载的客户，同时也向其他客户提供数据，是一种C/S混合的模型。上层应用之所以能这样设计，是因为IP协议栈定义了这样的能力。试想一下，如果IP提供的能力不对等，那么每个通信会话都只能是单方向发起的，这会极大限制通信的能力。细心的读者会发现，前面介绍NAT的一个特性正是这样一种限制。没错，NAT最大的弊端正在于此——破坏了IP端到端通信的能力。\n\n> 3.2 NAT的弊端\n\nNAT在解决IPv4地址短缺问题上，并非没有副作用，其实存在很多问题。\n\n首先，NAT使IP会话的保持时效变短。因为一个会话建立后会在NAT设备上建立一个关联表，在会话静默的这段时间，NAT网关会进行老化操作。这是任何一个NAT网关必须做的事情，因为IP和端口资源有限，通信的需求无限，所以必须在会话结束后回收资源。通常TCP会话通过协商的方式主动关闭连接，NAT网关可以跟踪这些报文，但总是存在例外的情况，要依赖自己的定时器去回收资源。而基于UDP的通信协议很难确定何时通信结束，所以NAT网关主要依赖超时机制回收外部端口。通过定时器老化回收会带来一个问题，如果应用需要维持连接的时间大于NAT网关的设置，通信就会意外中断。因为网关回收相关转换表资源以后，新的数据到达时就找不到相关的转换信息，必须建立新的连接。当这个新数据是由公网侧向私网侧发送时，就会发生无法触发新连接建立，也不能通知到私网侧的主机去重建连接的情况。这时候通信就会中断，不能自动恢复。即使新数据是从私网侧发向公网侧，因为重建的会话表往往使用不同于之前的公网IP和端口地址，公网侧主机也无法对应到之前的通信上，导致用户可感知的连接中断。NAT网关要把回收空闲连接的时间设置到不发生持续的资源流失，又维持大部分连接不被意外中断，是一件比较有难度的事情。在NAT已经普及化的时代，很多应用协议的设计者已经考虑到了这种情况，所以一般会设置一个连接保活的机制，即在一段时间没有数据需要发送时，主动发送一个NAT能感知到而又没有实际数据的保活消息，这么做的主要目的就是重置NAT的会话定时器。\n\n其次，NAT在实现上将多个内部主机发出的连接复用到一个IP上，这就使依赖IP进行主机跟踪的机制都失效了。如网络管理中需要的基于网络流量分析的应用无法跟踪到终端用户与流量的具体行为的关系。基于用户行为的日志分析也变得困难，因为一个IP被很多用户共享，如果存在恶意的用户行为，很难定位到发起连接的那个主机。即便有一些机制提供了在NAT网关上进行连接跟踪的方法，但是把这种变换关系接续起来也困难重重。基于IP的用户授权不再可靠，因为拥有一个IP的不等于一个用户或主机。一个服务器也不能简单把同一IP的访问视作同一主机发起的，不能进行关联。有些服务器设置有连接限制，同一时刻只接纳来自一个IP的有限访问(有时是仅一个访问)，这会造成不同用户之间的服务抢占和排队。有时服务器端这样做是出于DOS攻击防护的考虑，因为一个用户正常情况下不应该建立大量的连接请求，过度使用服务资源被理解为攻击行为。但是这在NAT存在时不能简单按照连接数判断。总之，因为NAT隐蔽了通信的一端，把简单的事情复杂化了。\n\n我们来深入理解NAT一下对IP端到端模型的破坏力。NAT通过修改IP首部的信息变换通信的地址。但是在这个转换过程中只能基于一个会话单位。当一个应用需要保持多个双向连接时，麻烦就很大。NAT不能理解多个会话之间的关联性，无法保证转换符合应用需要的规则。当NAT网关拥有多个公有IP地址时，一组关联会话可能被分配到不同的公网地址，这通常是服务器端无法接受的。更为严重的是，当公网侧的主机要主动向私网侧发送数据时，NAT网关没有转换这个连接需要的关联表，这个数据包无法到达私网侧的主机。这些反方向发送数据的连接总有应用协议的约定或在初始建立的会话中进行过协商。但是因为NAT工作在网络层和传输层，无法理解应用层协议的行为，对这些信息是无知的。NAT希望自己对通信双方是透明的，但是在这些情况下这是一种奢望。\n\n![image](http://www.52im.net/data/attachment/forum/201509/06/203015ak3kk90kyh4c8484.png)\n\n此外，NAT工作机制依赖于修改IP包头的信息，这会妨碍一些安全协议的工作。因为NAT篡改了IP地址、传输层端口号和校验和，这会导致认证协议彻底不能工作，因为认证目的就是要保证这些信息在传输过程中没有变化。对于一些隧道协议，NAT的存在也导致了额外的问题，因为隧道协议通常用外层地址标识隧道实体，穿过NAT的隧道会有IP复用关系，在另一端需要小心处理。ICMP是一种网络控制协议，它的工作原理也是在两个主机之间传递差错和控制消息，因为IP的对应关系被重新映射，ICMP也要进行复用和解复用处理，很多情况下因为ICMP报文载荷无法提供足够的信息，解复用会失败。IP分片机制是在信息源端或网络路径上，需要发送的IP报文尺寸大于路径实际能承载最大尺寸时，IP协议层会将一个报文分成多个片断发送，然后在接收端重组这些片断恢复原始报文。IP这样的分片机制会导致传输层的信息只包括在第一个分片中，NAT难以识别后续分片与关联表的对应关系，因此需要特殊处理。\n\n> 3.3 NAT穿越技术\n\n前面解释了NAT的弊端，为了解决IP端到端应用在NAT环境下遇到的问题，网络协议的设计者们创造了各种武器来进行应对。但遗憾的是，这里每一种方法都不完美，还需要在内部主机、应用程序或者NAT网关上增加额外的处理。\n\n- 应用层网关\n\n应用层网关(ALG)是解决NAT对应用层协议无感知的一个最常用方法，已经被NAT设备厂商广泛采用，成为NAT设备的一个必需功能。因为NAT不感知应用协议，所以有必要额外为每个应用协议定制协议分析功能，这样NAT网关就能理解并支持特定的协议。ALG与NAT形成互动关系，在一个NAT网关检测到新的连接请求时，需要判断是否为已知的应用类型，这通常是基于连接的传输层端口信息来识别的。在识别为已知应用时，再调用相应功能对报文的深层内容进行检查，当发现任何形式表达的IP地址和端口时，将会把这些信息同步转换，并且为这个新连接创建一个附加的转换表项。这样，当报文到达公网侧的目的主机时，应用层协议中携带的信息就是NAT网关提供的地址和端口。一旦公网侧主机开始发送数据或建立连接到此端口，NAT网关就可以根据关联表信息进行转换，再把数据转发到私网侧的主机。很多应用层协议实现不限于一个初始连接(通常为信令或控制通道)加一个数据连接，可能是一个初始连接对应很多后续的新连接。比较特别的协议，在一次协商中会产生一组相关连接，比如RTP/RTCP协议规定，一个RTP通道建立后占用连续的两个端口，一个服务于数据，另一个服务于控制消息。此时，就需要ALG分配连续的端口为应用服务。ALG能成功解决大部分协议的NAT穿越需求，但是这个方法也有很大的限制。因为应用协议的数量非常多而且在不断发展变化之中，添加到设备中的ALG功能都是为特定协议的特定规范版本而开发的，协议的创新和演进要求NAT设备制造商必须跟踪这些协议的最近标准，同时兼容旧标准。尽管有如Linux这种开放平台允许动态加载新的ALG特性，但是管理成本仍然很高，网络维护人员也不能随时了解用户都需要什么应用。因此为每个应用协议开发ALG代码并跟踪最新标准是不可行的，ALG只能解决用户最常用的需求。此外，出于安全性需要，有些应用类型报文从源端发出就已经加密，这种报文在网络中间无法进行分析，所以ALG无能为力。\n\n- 探针技术STUN和TURN\n\n所谓探针技术，是通过在所有参与通信的实体上安装探测插件，以检测网络中是否存在NAT网关，并对不同NAT模型实施不同穿越方法的一种技术。STUN服务器被部署在公网上，用于接收来自通信实体的探测请求，服务器会记录收到请求的报文地址和端口，并填写到回送的响应报文中。客户端根据接收到的响应消息中记录的地址和端口与本地选择的地址和端口进行比较，就能识别出是否存在NAT网关。如果存在NAT网关，客户端会使用之前的地址和端口向服务器的另外一个IP发起请求，重复前面的探测。然后再比较两次响应返回的结果判断出NAT工作的模式。由前述的一对多转换模型得知，除对称型NAT以外的模型，NAT网关对内部主机地址端口的映射都是相对固定的，所以比较容易实现NAT穿越。而对称型NAT为每个连接提供一个映射，使得转换后的公网地址和端口对不可预测。此时TURN可以与STUN绑定提供穿越NAT的服务，即在公网服务器上提供一个“地址端口对”，所有此“地址端口对”接收到的数据会经由探测建立的连接转发到内网主机上。TURN分配的这个映射“地址端口对”会通过STUN响应发给内部主机，后者将此信息放入建立连接的信令中通知通信的对端。这种探针技术是一种通用方法，不用在NAT设备上为每种应用协议开发功能，相对于ALG方式有一定普遍性。但是TURN中继服务会成为通信瓶颈。而且在客户端中增加探针功能要求每个应用都要增加代码才能支持。\n\n- 中间件技术\n\n这也是一种通过开发通用方法解决NAT穿越问题的努力。与前者不同之处是，NAT网关是这一解决方案的参与者。与ALG的不同在于，客户端会参与网关公网映射信息的维护，此时NAT网关只要理解客户端的请求并按照要求去分配转换表，不需要自己去分析客户端的应用层数据。其中UPnP就是这样一种方法。UPnP中文全称为通用即插即用，是一个通用的网络终端与网关的通信协议，具备信息发布和管理控制的能力。其中，网关映射请求可以为客户动态添加映射表项。此时，NAT不再需要理解应用层携带的信息，只转换IP地址和端口信息。而客户端通过控制消息或信令发到公网侧的信息中，直接携带公网映射的IP地址和端口，接收端可以按照此信息建立数据连接。NAT网关在收到数据或连接请求时，按照UPnP建立的表项只转换地址和端口信息，不关心内容，再将数据转发到内网。这种方案需要网关、内部主机和应用程序都支持UPnP技术，且组网允许内部主机和NAT网关之间可以直接交换UPnP信令才能实施。\n\n- 中继代理技术\n\n准确说它不是NAT穿越技术，而是NAT旁路技术。简单说，就是在NAT网关所在的位置旁边放置一个应用服务器，这个服务器在内部网络和外部公网分别有自己的网络连接。客户端特定的应用产生网络请求时，将定向发送到应用代理服务器。应用代理服务器根据代理协议解析客户端的请求，再从服务器的公网侧发起一个新的请求，把客户端请求的内容中继到外部网络上，返回的相应反方向中继。这项技术和ALG有很大的相似性，它要求为每个应用类型部署中继代理业务，中间服务器要理解这些请求。\n\n- 特定协议的自穿越技术\n\n在所有方法中最复杂也最可靠的就是自己解决自己的问题。比如IKE和IPsec技术，在设计时就考虑了到如何穿越NAT的问题。因为这个协议是一个自加密的协议并且具有报文防修改的鉴别能力，其他通用方法爱莫能助。因为实际应用的NAT网关基本都是NAPT方式，所有通过传输层协议承载的报文可以顺利通过NAT。IKE和IPsec采用的方案就是用UDP在报文外面再加一层封装，而内部的报文就不再受到影响。IKE中还专门增加了NAT网关是否存在的检查能力以及绕开NAT网关检测IKE协议的方法。\n\n# 4. NAT的应用和实现\n\n> 4.1 NAT的应用\n\nNAT在当代Internet中被广泛采用，小至家庭网关，大到企业广域网出口甚至运营商业务网络出口。其实NAT在用户身边随处可见，一般家庭宽带接入的ADSL Modem和SOHO路由器都内置了NAT功能，WindowsXP支持网络连接共享，一个用户连接到公网可能会经过多层NAT而对此一无所知。很多企业也为节约IP费用采用NAT接入Internet，但是相比家庭用户有更复杂的需求。\n\n- NAT多实例应用\n\n在VPN网络中，多实例路由意味着一个物理拓扑上承载多个逻辑拓扑，网络终端被分配到相互隔离的逻辑拓扑中，彼此之间没有路由的通路。但在访问Internet或者一些关键服务器资源时，被隔离的网络之间又存在共享资源的需求。NAT的多实例实现就是跨越这种逻辑拓扑的方法，把一个空间的网络地址映射到另一个空间。\n\n- NAT的高可靠性组网\n\n提高网络可靠性是一个广泛的需求，NAT作为私网到公网的关键路径自然也需要高可靠性。当一个设备提供多个公网接口时，在多接口上部署NAT可以提供更高带宽和多ISP就近访问的能力。但是，当部署多个出口时，访问的流量可能会从不匹配的接口返回，这就要求NAT方案有良好的路由规划和部署合适的策略保证这种流量能够正确处理。在多个物理设备承担NAT功能时，不同设备之间的信息备份和流量分担也是一个组网难题。\n\n- 同时转换源和目的地址的应用\n\n前面我们介绍的所有NAT应用中，由内网向外网访问过程中，都是将源地址进行转换而目的地址保持不变，报文反方向进入时则处理目的地址。但有一些特殊应用需要在由内向外的IP通路上，替换目的IP地址。通常，这种应用会同时替换源地址和目的地址，在经过NAT网关以后完成两次地址转换。当两个均规划使用私属IP地址范围的网络进行合并时，终端用户都不想调整自己的IP地址方案，又希望开放一些网络资源给彼此访问。这时就可以通过NAT的两次地址转换来解决路由和地址规划无法解决的问题。\n\n![image](http://www.52im.net/data/attachment/forum/201509/06/203248s85pmn8l0iicoc0c.png)\n\n> 4.2 NAT的设备实现\n\nNAT作为一个IP层业务特性，在产品实现中与防火墙、会话管理等特性有紧密联系，这是因为NAT判断一个进入设备的报文是否需要NAT处理，判断报文是否为一个新的连接，都需要通过匹配访问控制列表规则和查询会话关联表进行判断。为了满足不同应用场景的NAT需求， NAT的管理界面可提供用户多种配置策略。按照NAT的具体工作方式，又可以做如下分类。\n\n- 静态一对一地址映射\n\n这种工作方式下，NAT把一个私网地址和一个公网地址做静态关联，在从内而外的方向，将源IP匹配的私网IP替换为公网IP，反方向则将目的IP匹配公网IP的报文替换为私网IP。网络层以上的部分不进行替换处理，只修正校验和。\n\n- 静态多对多地址映射\n\n这种方式与上一种类似，只是把一段私网地址映射到一段公网地址。工作机制与前述的方式没有差别，只是简化配置工作量。\n\n- 动态端口映射\n\n这是最基本的工作方式，即前面多次介绍的将一段内网地址动态翻译为一个或多个公网IP，同时对传输层端口或其他上层协议信息进行转换，以实现IP复用。对由内而外的报文，替换源地址和端口，反向报文替换目的地址和端口。仅以连接公网的接口IP作为NAT转换的公网地址时，这种配置最简化，又被称为EasyIP。当以一段公网IP地址作为NAT转换地址时，需要配置一个地址池，NAT会自动在地址池中选择使用公网IP。\n\n- 动态地址映射(no-pat)\n\n这是介于静态多对多地址映射和动态端口映射方式之间的一种工作机制。当有一个私网向公网侧访问到达NAT网关时，NAT网关会检查这个私网IP是否已经有关联的公网IP映射。如果已经存在，则按照转换表直接替换IP，不修改上层协议。如果不存在关联表项，则在空闲的公网IP池中占用一个IP，并写入关联表中，以后按照这个关联关系进行地址转换。当这个私网主机发起的所有对外访问均关闭或超时后，回收公网IP。这种方式可以理解为一组内网主机抢占式地共享一个公网IP地址池。当公网IP地址池用完以后，新连接将无法建立。\n\n- 静态端口映射\n\n通过静态配置，把一个固定的私网IP地址和端口关联到一个公网地址和端口上。这种方式等同于前面介绍过的全锥模式，但是不需要内网主机首先发出报文。这种方式适用于在NAT网关上把一个知名服务（如HTTP）映射到一个内部主机上，也称为port forwarding。\n\n- 应用层网关(ALG)\n\n在所有NAT产品实现中，ALG是一个必需的功能组件。但在不同实现中，有些产品可以动态加载不同的ALG模块，有些产品可以提供ALG开关控制，有些则不提供任何用户接口。ALG解析上层应用协议的内容，并且根据需要修改IP和端口相关信息，创建和维护附加的关联表项。\n\n- NAT转换关联表\n\n无论哪一种NAT工作方式，都要用到地址转换关联表，在不同产品的实现中，这个关联表的存储结构和在IP转发中调用的方式有很大不同。关联表中会记录源IP、目的IP、连接协议类型、传输层源端口、目的端口，以及转换后的源IP、源端口，目的IP、目的端口信息，这里的源和目的都是对应于从内网到外网的访问方向。依据NAT具体工作方式，这些信息可能全部填充，也可能部分填充。例如只按照IP做静态映射的方式，就不需要填入任何端口相关信息；对于静态端口映射，则只填入源相关的内容，而目的端的信息为空。\n\n# 5. 后IPv4时代的NAT\n\nNAT是为延缓IPv4地址耗尽而推出的技术。毫无疑问，它已经出色完成了自己的历史使命，IPv4比预期走得更远。作为继任者的IPv6吸取了IPv4的教训，被赋予充足地址空间的同时在各个方面做了优化——安全、高效、简洁。但是IPv6无法平滑地取代IPv4，导致IP升级步伐缓慢。尽管网络协议的分层设计很清晰，大量应用层协议和互联网软件中仍内嵌了IPv4地址的处理，要Internet全网升级到IPv6，必须先完成应用的改造。因为NAT和它的穿越技术结合能够满足大部分用户的需求，所以IPv6时代被不断推迟。\n\n随着IPv4地址的濒临耗尽，再经济的模式也无以为继，IPv4必须退出历史舞台。人们自然会认为，NAT作为IPv4的超级补丁技术使命已经完结。实际情况是，IPv4向IPv6过渡的阶段，NAT仍然是一项必不可少的技术手段。因为Internet无法在一日之内完成全网升级，必然是局部升级，逐渐替换。在两套协议并存的时期，用户和服务资源分布在不同网络之间，跨网访问的需求必须得到满足。这正是NAT所擅长的领域，地址替换，因此NAT-PT应运而生。由于IPv4和IPv6之间的差异，NAT要做的事比以往更复杂，有更多的限制和细节。\n\n此外，IETF也在制定纯IPv6网络使用的NAT规范。虽然人们还看不到这种应用的强烈需求，但是NAT仍有其独特的作用，比如隐藏内部网络的地址，实现重叠地址网络的合并等。\n\n毫不夸张地说，正是有了NAT，以IPv4为基础的Internet才能容纳数十亿的用户终端，成就今日之辉煌。IPv4已至日暮西山，IPv6的黎明尚未来临，Internet比任何时刻都更依赖NAT这项过渡技术。NAT的历史再次证明，翻天覆地的划时代进步不一定有市场，抱残守缺的修修补补未必不会成功。在世代更替之时让我们走近NAT，领略IP领域更多细微但不高深的知识，理解NAT就是理解变换万千的应用世界。\n","source":"_posts/p2p1.md","raw":"---\ntitle: P2P技术详解(一)：NAT详解——详细原理、P2P简介\ndate: 2018-09-06 17:27:56\ntags: p2p\n---\n\n# 1. IPv4协议和NAT的由来\n\n今天，无数快乐的互联网用户在尽情享受Internet带来的乐趣。他们浏览新闻，搜索资料，下载软件，广交新朋，分享信息，甚至于足不出户获取一切日用所需。企业利用互联网发布信息，传递资料和订单，提供技术支持，完成日常办公。然而，Internet在给亿万用户带来便利的同时，自身却面临一个致命的问题：构建这个无所不能的Internet的基础IPv4协议已经不能再提供新的网络地址了。\n\n2011年2月3日中国农历新年， IANA对外宣布：IPv4地址空间最后5个地址块已经被分配给下属的5个地区委员会。2011年4月15日，亚太区委员会APNIC对外宣布，除了个别保留地址外，本区域所有的IPv4地址基本耗尽。一时之间，IPv4地址作为一种濒危资源身价陡增，各大网络公司出巨资收购剩余的空闲地址。其实，IPv4地址不足问题已不是新问题，早在20年以前，IPv4地址即将耗尽的问题就已经摆在Internet先驱们面前。这不禁让我们想去了解，是什么技术使这一危机延缓了尽20年。\n\n要找到问题的答案，让我们先来简略回顾一下IPv4协议。\n\nIPv4即网际网协议第4版——Internet Protocol Version 4的缩写。IPv4定义一个跨越异种网络互连的超级网，它为每个网际网的节点分配全球唯一IP地址。如果我们把Internet比作一个邮政系统，那么IP地址的作用就等同于包含城市、街区、门牌编号在内的完整地址。IPv4使用32bits整数表达一个地址，地址最大范围就是232 约为43亿。以IP创始时期可被联网的设备来看，这样的一个空间已经很大，很难被短时间用完。然而，事实远远超出人们的设想，计算机网络在此后的几十年里迅速壮大，网络终端数量呈爆炸性增长。\n\n更为糟糕的是，为了路由和管理方便，43亿的地址空间被按照不同前缀长度划分为A,B,C,D类地址网络和保留地址。其中，A类网络地址127段，每段包括主机地址约1678万个。B类网络地址16384段，每段包括65536个主机地址。\n\n![image](http://www.52im.net/data/attachment/forum/201509/06/200926crr724j68tledk1p.png)\n\nIANA向超大型企业/组织分配A类网络地址，一次一段。向中型企业或教育机构分配B类网络地址，一次一段。这样一种分配策略使得IP地址浪费很严重，很多被分配出去的地址没有真实被利用，地址消耗很快。以至于二十世纪90年代初，网络专家们意识到，这样大手大脚下去，IPv4地址很快就要耗光了。于是，人们开始考虑IPv4的替代方案，同时采取一系列的措施来减缓IPv4地址的消耗。正是在这样一个背景之下，本期的主角闪亮登场，它就是网络地址转换——NAT。\n\nNAT是一项神奇的技术，说它神奇在于它的出现几乎使IPv4起死回生。在IPv4已经被认为行将结束历史使命之后近20年时间里，人们几乎忘了IPv4的地址空间即将耗尽这样一个事实——在新技术日新月异的时代，20年可算一段漫长的历史。更不用说，在NAT产生以后，网络终端的数量呈加速上升趋势，对IP地址的需求剧烈增加。此足见NAT技术之成功，影响之深远。\n\n说它神奇，更因为NAT给IP网络模型带来了深远影响，其身影遍布网络每个角落。根据一份最近的研究报告，70%的P2P用户位于NAT网关以内。因为P2P主要运行在终端用户的个人电脑之上，这个数字意味着大多数PC通过NAT网关连接到Internet。如果加上2G和3G方式联网的智能手机等移动终端，在NAT网关之后的用户远远超过这个比例。\n\n然而当我们求本溯源时却发现一个很奇怪的事实：NAT这一意义重大的技术，竟然没有公认的发明者。NAT第一个版本的RFC作者，只是整理归纳了已被广泛采用的技术。\n\n<!-- more -->\n\n# 2. NAT的工作模型和特点\n\n> 2.1 NAT的概念模型\n\nNAT名字很准确，网络地址转换，就是替换IP报文头部的地址信息。NAT通常部署在一个组织的网络出口位置，通过将内部网络IP地址替换为出口的IP地址提供公网可达性和上层协议的连接能力。那么，什么是内部网络IP地址？\n\nRFC1918规定了三个保留地址段落：10.0.0.0-10.255.255.255；172.16.0.0-172.31.255.255；192.168.0.0-192.168.255.255。这三个范围分别处于A,B,C类的地址段，不向特定的用户分配，被IANA作为私有地址保留。这些地址可以在任何组织或企业内部使用，和其他Internet地址的区别就是，仅能在内部使用，不能作为全球路由地址。这就是说，出了组织的管理范围这些地址就不再有意义，无论是作为源地址，还是目的地址。对于一个封闭的组织，如果其网络不连接到Internet，就可以使用这些地址而不用向IANA提出申请，而在内部的路由管理和报文传递方式与其他网络没有差异。\n\n对于有Internet访问需求而内部又使用私有地址的网络，就要在组织的出口位置部署NAT网关，在报文离开私网进入Internet时，将源IP替换为公网地址，通常是出口设备的接口地址。一个对外的访问请求在到达目标以后，表现为由本组织出口设备发起，因此被请求的服务端可将响应由Internet发回出口网关。出口网关再将目的地址替换为私网的源主机地址，发回内部。这样一次由私网主机向公网服务端的请求和响应就在通信两端均无感知的情况下完成了。依据这种模型，数量庞大的内网主机就不再需要公有IP地址了。\n\n![image](http://www.52im.net/data/attachment/forum/201509/06/202518pip8a6h99c8xc6i6.png)\n\n虽然实际过程远比这个复杂，但上面的描述概括了NAT处理报文的几个关键特点：\n1. 网络被分为私网和公网两个部分，NAT网关设置在私网到公网的路由出口位置，双向流量必须都要经过NAT网关；\n2. 网络访问只能先由私网侧发起，公网无法主动访问私网主机； \n3. NAT网关在两个访问方向上完成两次地址的转换或翻译，出方向做源信息替换，入方向做目的信息替换； \n4. NAT网关的存在对通信双方是保持透明的； \n5. NAT网关为了实现双向翻译的功能，需要维护一张关联表，把会话的信息保存下来。\n\n随着后面对NAT的深入描述，读者会发现，这些特点是鲜明的，但又不是绝对的。其中第二个特点打破了IP协议架构中所有节点在通讯中的对等地位，这是NAT最大的弊端，为对等通讯带来了诸多问题，当然相应的克服手段也应运而生。事实上，第四点是NAT致力于达到的目标，但在很多情况下，NAT并没有做到，因为除了IP首部，上层通信协议经常在内部携带IP地址信息。这些我们稍后解释。\n\n> 2.2 一对一的NAT\n\n如果一个内部主机唯一占用一个公网IP，这种方式被称为一对一模型。此种方式下，转换上层协议就是不必要的，因为一个公网IP就能唯一对应一个内部主机。显然，这种方式对节约公网IP没有太大意义，主要是为了实现一些特殊的组网需求。比如用户希望隐藏内部主机的真实IP，或者实现两个IP地址重叠网络的通信。\n\n> 2.3 一对多的NAT\n\nNAT最典型的应用场景就如同图2描述的，一个组织网络，在出口位置部署NAT网关，所有对公网的访问表现为一台主机。这就是所谓的一对多模型。这种方式下，出口设备只占用一个由Internet服务提供商分配的公网IP地址。面对私网内部数量庞大的主机，如果NAT只进行IP地址的简单替换，就会产生一个问题：当有多个内部主机去访问同一个服务器时，从返回的信息不足以区分响应应该转发到哪个内部主机。此时，需要NAT设备根据传输层信息或其他上层协议去区分不同的会话，并且可能要对上层协议的标识进行转换，比如TCP或UDP端口号。这样NAT网关就可以将不同的内部连接访问映射到同一公网IP的不同传输层端口，通过这种方式实现公网IP的复用和解复用。这种方式也被称为端口转换PAT、NAPT或IP伪装，但更多时候直接被称为NAT，因为它是最典型的一种应用模式。\n\n> 2.4 按照NAT端口映射方式分类\n\n在一对多模型中，按照端口转换的工作方式不同，又可以进行更进一步的划分。为描述方便，以下将IP和端口标记为(nAddr:nPort)，其中n代表主机或NAT网关的不同角色。\n\n![image](http://www.52im.net/data/attachment/forum/201509/06/202751b5p2nmsj6nu5sujj.png)\n\n- 全锥形NAT\n\n其特点为：一旦内部主机端口对(iAddr:iPort)被NAT网关映射到(eAddr:ePort)，所有后续的(iAddr:iPort)报文都会被转换为(eAddr:ePort)；任何一个外部主机发送到(eAddr:ePort)的报文将会被转换后发到(iAddr:iPort)。\n\n- 限制锥形NAT\n\n其特点为：一旦内部主机端口对(iAddr:iPort)被映射到(eAddr:ePort)，所有后续的(iAddr:iPort)报文都会被转换为(eAddr:ePort)；只有 (iAddr:iPort)向特定的外部主机hAddr发送过数据，主机hAddr从任意端口发送到(eAddr:ePort)的报文将会被转发到(iAddr:iPort)。\n\n- 端口限制锥形NAT\n\n其特点为：一旦内部主机端口对(iAddr:iPort)被映射到(eAddr:ePort)，所有后续的(iAddr:iPort)报文都会被转换为(eAddr:ePort)；只有(iAddr:iPort)向特定的外部主机端口对(hAddr:hPort)发送过数据，由 (hAddr:hPort)发送到(eAddr:ePort)的报文将会被转发到(iAddr:iPort)。\n\n- 对称型NAT\n\n其特点为：NAT网关会把内部主机“地址端口对”和外部主机“地址端口对”完全相同的报文看作一个连接，在网关上创建一个公网“地址端口对”映射进行转换，只有收到报文的外部主机从对应的端口对发送回应的报文，才能被转换。即使内部主机使用之前用过的地址端口对去连接不同外部主机(或端口)时，NAT网关也会建立新的映射关系。\n\n事实上，这些术语的引入是很多混淆的起源。现实中的很多NAT设备是将这些转换方式混合在一起工作的，而不单单使用一种，所以这些术语只适合描述一种工作方式，而不是一个设备。比如，很多NAT设备对内部发出的连接使用对称型NAT方式，而同时支持静态的端口映射，后者可以被看作是全锥型NAT方式。而有些情况下，NAT设备的一个公网地址和端口可以同时映射到内部几个服务器上以实现负载分担，比如一个对外提供WEB服务器的站点可能是有成百上千个服务器在提供HTTP服务，但是对外却表现为一个或少数几个IP地址。\n\n# 3. NAT的限制与解决方案\n\n> 3.1 IP端到端服务模型\n\nIP协议的一个重要贡献是把世界变得平等。在理论上，具有IP地址的每个站点在协议层面有相当的获取服务和提供服务的能力，不同的IP地址之间没有差异。人们熟知的服务器和客户机实际是在应用协议层上的角色区分，而在网络层和传输层没有差异。一个具有IP地址的主机既可以是客户机，也可以是服务器，大部分情况下，既是客户机，也是服务器。端到端对等看起来是很平常的事情，而意义并不寻常。但在以往的技术中，很多协议体系下的网络限定了终端的能力。正是IP的这个开放性，使得TCP/IP协议族可以提供丰富的功能，为应用实现提供了广阔平台。因为所有的IP主机都可以服务器的形式出现，所以通讯设计可以更加灵活。使用UNIX/LINUX的系统充分利用了这个特性，使得任何一个主机都可以建立自己的HTTP、SMTP、POP3、DNS、DHCP等服务。与此同时，很多应用也是把客户端和服务器的角色组合起来完成功能。例如在VoIP应用中，用户端向注册服务器登录自己的IP地址和端口信息过程中，主机是客户端；而在呼叫到达时，呼叫处理服务器向用户端发送呼叫请求时，用户端实际工作在服务器模式下。在语音媒体流信道建立过程后，通讯双向发送语音数据，发送端是客户模式，接收端是服务器模式。而在P2P的应用中，一个用户的主机既为下载的客户，同时也向其他客户提供数据，是一种C/S混合的模型。上层应用之所以能这样设计，是因为IP协议栈定义了这样的能力。试想一下，如果IP提供的能力不对等，那么每个通信会话都只能是单方向发起的，这会极大限制通信的能力。细心的读者会发现，前面介绍NAT的一个特性正是这样一种限制。没错，NAT最大的弊端正在于此——破坏了IP端到端通信的能力。\n\n> 3.2 NAT的弊端\n\nNAT在解决IPv4地址短缺问题上，并非没有副作用，其实存在很多问题。\n\n首先，NAT使IP会话的保持时效变短。因为一个会话建立后会在NAT设备上建立一个关联表，在会话静默的这段时间，NAT网关会进行老化操作。这是任何一个NAT网关必须做的事情，因为IP和端口资源有限，通信的需求无限，所以必须在会话结束后回收资源。通常TCP会话通过协商的方式主动关闭连接，NAT网关可以跟踪这些报文，但总是存在例外的情况，要依赖自己的定时器去回收资源。而基于UDP的通信协议很难确定何时通信结束，所以NAT网关主要依赖超时机制回收外部端口。通过定时器老化回收会带来一个问题，如果应用需要维持连接的时间大于NAT网关的设置，通信就会意外中断。因为网关回收相关转换表资源以后，新的数据到达时就找不到相关的转换信息，必须建立新的连接。当这个新数据是由公网侧向私网侧发送时，就会发生无法触发新连接建立，也不能通知到私网侧的主机去重建连接的情况。这时候通信就会中断，不能自动恢复。即使新数据是从私网侧发向公网侧，因为重建的会话表往往使用不同于之前的公网IP和端口地址，公网侧主机也无法对应到之前的通信上，导致用户可感知的连接中断。NAT网关要把回收空闲连接的时间设置到不发生持续的资源流失，又维持大部分连接不被意外中断，是一件比较有难度的事情。在NAT已经普及化的时代，很多应用协议的设计者已经考虑到了这种情况，所以一般会设置一个连接保活的机制，即在一段时间没有数据需要发送时，主动发送一个NAT能感知到而又没有实际数据的保活消息，这么做的主要目的就是重置NAT的会话定时器。\n\n其次，NAT在实现上将多个内部主机发出的连接复用到一个IP上，这就使依赖IP进行主机跟踪的机制都失效了。如网络管理中需要的基于网络流量分析的应用无法跟踪到终端用户与流量的具体行为的关系。基于用户行为的日志分析也变得困难，因为一个IP被很多用户共享，如果存在恶意的用户行为，很难定位到发起连接的那个主机。即便有一些机制提供了在NAT网关上进行连接跟踪的方法，但是把这种变换关系接续起来也困难重重。基于IP的用户授权不再可靠，因为拥有一个IP的不等于一个用户或主机。一个服务器也不能简单把同一IP的访问视作同一主机发起的，不能进行关联。有些服务器设置有连接限制，同一时刻只接纳来自一个IP的有限访问(有时是仅一个访问)，这会造成不同用户之间的服务抢占和排队。有时服务器端这样做是出于DOS攻击防护的考虑，因为一个用户正常情况下不应该建立大量的连接请求，过度使用服务资源被理解为攻击行为。但是这在NAT存在时不能简单按照连接数判断。总之，因为NAT隐蔽了通信的一端，把简单的事情复杂化了。\n\n我们来深入理解NAT一下对IP端到端模型的破坏力。NAT通过修改IP首部的信息变换通信的地址。但是在这个转换过程中只能基于一个会话单位。当一个应用需要保持多个双向连接时，麻烦就很大。NAT不能理解多个会话之间的关联性，无法保证转换符合应用需要的规则。当NAT网关拥有多个公有IP地址时，一组关联会话可能被分配到不同的公网地址，这通常是服务器端无法接受的。更为严重的是，当公网侧的主机要主动向私网侧发送数据时，NAT网关没有转换这个连接需要的关联表，这个数据包无法到达私网侧的主机。这些反方向发送数据的连接总有应用协议的约定或在初始建立的会话中进行过协商。但是因为NAT工作在网络层和传输层，无法理解应用层协议的行为，对这些信息是无知的。NAT希望自己对通信双方是透明的，但是在这些情况下这是一种奢望。\n\n![image](http://www.52im.net/data/attachment/forum/201509/06/203015ak3kk90kyh4c8484.png)\n\n此外，NAT工作机制依赖于修改IP包头的信息，这会妨碍一些安全协议的工作。因为NAT篡改了IP地址、传输层端口号和校验和，这会导致认证协议彻底不能工作，因为认证目的就是要保证这些信息在传输过程中没有变化。对于一些隧道协议，NAT的存在也导致了额外的问题，因为隧道协议通常用外层地址标识隧道实体，穿过NAT的隧道会有IP复用关系，在另一端需要小心处理。ICMP是一种网络控制协议，它的工作原理也是在两个主机之间传递差错和控制消息，因为IP的对应关系被重新映射，ICMP也要进行复用和解复用处理，很多情况下因为ICMP报文载荷无法提供足够的信息，解复用会失败。IP分片机制是在信息源端或网络路径上，需要发送的IP报文尺寸大于路径实际能承载最大尺寸时，IP协议层会将一个报文分成多个片断发送，然后在接收端重组这些片断恢复原始报文。IP这样的分片机制会导致传输层的信息只包括在第一个分片中，NAT难以识别后续分片与关联表的对应关系，因此需要特殊处理。\n\n> 3.3 NAT穿越技术\n\n前面解释了NAT的弊端，为了解决IP端到端应用在NAT环境下遇到的问题，网络协议的设计者们创造了各种武器来进行应对。但遗憾的是，这里每一种方法都不完美，还需要在内部主机、应用程序或者NAT网关上增加额外的处理。\n\n- 应用层网关\n\n应用层网关(ALG)是解决NAT对应用层协议无感知的一个最常用方法，已经被NAT设备厂商广泛采用，成为NAT设备的一个必需功能。因为NAT不感知应用协议，所以有必要额外为每个应用协议定制协议分析功能，这样NAT网关就能理解并支持特定的协议。ALG与NAT形成互动关系，在一个NAT网关检测到新的连接请求时，需要判断是否为已知的应用类型，这通常是基于连接的传输层端口信息来识别的。在识别为已知应用时，再调用相应功能对报文的深层内容进行检查，当发现任何形式表达的IP地址和端口时，将会把这些信息同步转换，并且为这个新连接创建一个附加的转换表项。这样，当报文到达公网侧的目的主机时，应用层协议中携带的信息就是NAT网关提供的地址和端口。一旦公网侧主机开始发送数据或建立连接到此端口，NAT网关就可以根据关联表信息进行转换，再把数据转发到私网侧的主机。很多应用层协议实现不限于一个初始连接(通常为信令或控制通道)加一个数据连接，可能是一个初始连接对应很多后续的新连接。比较特别的协议，在一次协商中会产生一组相关连接，比如RTP/RTCP协议规定，一个RTP通道建立后占用连续的两个端口，一个服务于数据，另一个服务于控制消息。此时，就需要ALG分配连续的端口为应用服务。ALG能成功解决大部分协议的NAT穿越需求，但是这个方法也有很大的限制。因为应用协议的数量非常多而且在不断发展变化之中，添加到设备中的ALG功能都是为特定协议的特定规范版本而开发的，协议的创新和演进要求NAT设备制造商必须跟踪这些协议的最近标准，同时兼容旧标准。尽管有如Linux这种开放平台允许动态加载新的ALG特性，但是管理成本仍然很高，网络维护人员也不能随时了解用户都需要什么应用。因此为每个应用协议开发ALG代码并跟踪最新标准是不可行的，ALG只能解决用户最常用的需求。此外，出于安全性需要，有些应用类型报文从源端发出就已经加密，这种报文在网络中间无法进行分析，所以ALG无能为力。\n\n- 探针技术STUN和TURN\n\n所谓探针技术，是通过在所有参与通信的实体上安装探测插件，以检测网络中是否存在NAT网关，并对不同NAT模型实施不同穿越方法的一种技术。STUN服务器被部署在公网上，用于接收来自通信实体的探测请求，服务器会记录收到请求的报文地址和端口，并填写到回送的响应报文中。客户端根据接收到的响应消息中记录的地址和端口与本地选择的地址和端口进行比较，就能识别出是否存在NAT网关。如果存在NAT网关，客户端会使用之前的地址和端口向服务器的另外一个IP发起请求，重复前面的探测。然后再比较两次响应返回的结果判断出NAT工作的模式。由前述的一对多转换模型得知，除对称型NAT以外的模型，NAT网关对内部主机地址端口的映射都是相对固定的，所以比较容易实现NAT穿越。而对称型NAT为每个连接提供一个映射，使得转换后的公网地址和端口对不可预测。此时TURN可以与STUN绑定提供穿越NAT的服务，即在公网服务器上提供一个“地址端口对”，所有此“地址端口对”接收到的数据会经由探测建立的连接转发到内网主机上。TURN分配的这个映射“地址端口对”会通过STUN响应发给内部主机，后者将此信息放入建立连接的信令中通知通信的对端。这种探针技术是一种通用方法，不用在NAT设备上为每种应用协议开发功能，相对于ALG方式有一定普遍性。但是TURN中继服务会成为通信瓶颈。而且在客户端中增加探针功能要求每个应用都要增加代码才能支持。\n\n- 中间件技术\n\n这也是一种通过开发通用方法解决NAT穿越问题的努力。与前者不同之处是，NAT网关是这一解决方案的参与者。与ALG的不同在于，客户端会参与网关公网映射信息的维护，此时NAT网关只要理解客户端的请求并按照要求去分配转换表，不需要自己去分析客户端的应用层数据。其中UPnP就是这样一种方法。UPnP中文全称为通用即插即用，是一个通用的网络终端与网关的通信协议，具备信息发布和管理控制的能力。其中，网关映射请求可以为客户动态添加映射表项。此时，NAT不再需要理解应用层携带的信息，只转换IP地址和端口信息。而客户端通过控制消息或信令发到公网侧的信息中，直接携带公网映射的IP地址和端口，接收端可以按照此信息建立数据连接。NAT网关在收到数据或连接请求时，按照UPnP建立的表项只转换地址和端口信息，不关心内容，再将数据转发到内网。这种方案需要网关、内部主机和应用程序都支持UPnP技术，且组网允许内部主机和NAT网关之间可以直接交换UPnP信令才能实施。\n\n- 中继代理技术\n\n准确说它不是NAT穿越技术，而是NAT旁路技术。简单说，就是在NAT网关所在的位置旁边放置一个应用服务器，这个服务器在内部网络和外部公网分别有自己的网络连接。客户端特定的应用产生网络请求时，将定向发送到应用代理服务器。应用代理服务器根据代理协议解析客户端的请求，再从服务器的公网侧发起一个新的请求，把客户端请求的内容中继到外部网络上，返回的相应反方向中继。这项技术和ALG有很大的相似性，它要求为每个应用类型部署中继代理业务，中间服务器要理解这些请求。\n\n- 特定协议的自穿越技术\n\n在所有方法中最复杂也最可靠的就是自己解决自己的问题。比如IKE和IPsec技术，在设计时就考虑了到如何穿越NAT的问题。因为这个协议是一个自加密的协议并且具有报文防修改的鉴别能力，其他通用方法爱莫能助。因为实际应用的NAT网关基本都是NAPT方式，所有通过传输层协议承载的报文可以顺利通过NAT。IKE和IPsec采用的方案就是用UDP在报文外面再加一层封装，而内部的报文就不再受到影响。IKE中还专门增加了NAT网关是否存在的检查能力以及绕开NAT网关检测IKE协议的方法。\n\n# 4. NAT的应用和实现\n\n> 4.1 NAT的应用\n\nNAT在当代Internet中被广泛采用，小至家庭网关，大到企业广域网出口甚至运营商业务网络出口。其实NAT在用户身边随处可见，一般家庭宽带接入的ADSL Modem和SOHO路由器都内置了NAT功能，WindowsXP支持网络连接共享，一个用户连接到公网可能会经过多层NAT而对此一无所知。很多企业也为节约IP费用采用NAT接入Internet，但是相比家庭用户有更复杂的需求。\n\n- NAT多实例应用\n\n在VPN网络中，多实例路由意味着一个物理拓扑上承载多个逻辑拓扑，网络终端被分配到相互隔离的逻辑拓扑中，彼此之间没有路由的通路。但在访问Internet或者一些关键服务器资源时，被隔离的网络之间又存在共享资源的需求。NAT的多实例实现就是跨越这种逻辑拓扑的方法，把一个空间的网络地址映射到另一个空间。\n\n- NAT的高可靠性组网\n\n提高网络可靠性是一个广泛的需求，NAT作为私网到公网的关键路径自然也需要高可靠性。当一个设备提供多个公网接口时，在多接口上部署NAT可以提供更高带宽和多ISP就近访问的能力。但是，当部署多个出口时，访问的流量可能会从不匹配的接口返回，这就要求NAT方案有良好的路由规划和部署合适的策略保证这种流量能够正确处理。在多个物理设备承担NAT功能时，不同设备之间的信息备份和流量分担也是一个组网难题。\n\n- 同时转换源和目的地址的应用\n\n前面我们介绍的所有NAT应用中，由内网向外网访问过程中，都是将源地址进行转换而目的地址保持不变，报文反方向进入时则处理目的地址。但有一些特殊应用需要在由内向外的IP通路上，替换目的IP地址。通常，这种应用会同时替换源地址和目的地址，在经过NAT网关以后完成两次地址转换。当两个均规划使用私属IP地址范围的网络进行合并时，终端用户都不想调整自己的IP地址方案，又希望开放一些网络资源给彼此访问。这时就可以通过NAT的两次地址转换来解决路由和地址规划无法解决的问题。\n\n![image](http://www.52im.net/data/attachment/forum/201509/06/203248s85pmn8l0iicoc0c.png)\n\n> 4.2 NAT的设备实现\n\nNAT作为一个IP层业务特性，在产品实现中与防火墙、会话管理等特性有紧密联系，这是因为NAT判断一个进入设备的报文是否需要NAT处理，判断报文是否为一个新的连接，都需要通过匹配访问控制列表规则和查询会话关联表进行判断。为了满足不同应用场景的NAT需求， NAT的管理界面可提供用户多种配置策略。按照NAT的具体工作方式，又可以做如下分类。\n\n- 静态一对一地址映射\n\n这种工作方式下，NAT把一个私网地址和一个公网地址做静态关联，在从内而外的方向，将源IP匹配的私网IP替换为公网IP，反方向则将目的IP匹配公网IP的报文替换为私网IP。网络层以上的部分不进行替换处理，只修正校验和。\n\n- 静态多对多地址映射\n\n这种方式与上一种类似，只是把一段私网地址映射到一段公网地址。工作机制与前述的方式没有差别，只是简化配置工作量。\n\n- 动态端口映射\n\n这是最基本的工作方式，即前面多次介绍的将一段内网地址动态翻译为一个或多个公网IP，同时对传输层端口或其他上层协议信息进行转换，以实现IP复用。对由内而外的报文，替换源地址和端口，反向报文替换目的地址和端口。仅以连接公网的接口IP作为NAT转换的公网地址时，这种配置最简化，又被称为EasyIP。当以一段公网IP地址作为NAT转换地址时，需要配置一个地址池，NAT会自动在地址池中选择使用公网IP。\n\n- 动态地址映射(no-pat)\n\n这是介于静态多对多地址映射和动态端口映射方式之间的一种工作机制。当有一个私网向公网侧访问到达NAT网关时，NAT网关会检查这个私网IP是否已经有关联的公网IP映射。如果已经存在，则按照转换表直接替换IP，不修改上层协议。如果不存在关联表项，则在空闲的公网IP池中占用一个IP，并写入关联表中，以后按照这个关联关系进行地址转换。当这个私网主机发起的所有对外访问均关闭或超时后，回收公网IP。这种方式可以理解为一组内网主机抢占式地共享一个公网IP地址池。当公网IP地址池用完以后，新连接将无法建立。\n\n- 静态端口映射\n\n通过静态配置，把一个固定的私网IP地址和端口关联到一个公网地址和端口上。这种方式等同于前面介绍过的全锥模式，但是不需要内网主机首先发出报文。这种方式适用于在NAT网关上把一个知名服务（如HTTP）映射到一个内部主机上，也称为port forwarding。\n\n- 应用层网关(ALG)\n\n在所有NAT产品实现中，ALG是一个必需的功能组件。但在不同实现中，有些产品可以动态加载不同的ALG模块，有些产品可以提供ALG开关控制，有些则不提供任何用户接口。ALG解析上层应用协议的内容，并且根据需要修改IP和端口相关信息，创建和维护附加的关联表项。\n\n- NAT转换关联表\n\n无论哪一种NAT工作方式，都要用到地址转换关联表，在不同产品的实现中，这个关联表的存储结构和在IP转发中调用的方式有很大不同。关联表中会记录源IP、目的IP、连接协议类型、传输层源端口、目的端口，以及转换后的源IP、源端口，目的IP、目的端口信息，这里的源和目的都是对应于从内网到外网的访问方向。依据NAT具体工作方式，这些信息可能全部填充，也可能部分填充。例如只按照IP做静态映射的方式，就不需要填入任何端口相关信息；对于静态端口映射，则只填入源相关的内容，而目的端的信息为空。\n\n# 5. 后IPv4时代的NAT\n\nNAT是为延缓IPv4地址耗尽而推出的技术。毫无疑问，它已经出色完成了自己的历史使命，IPv4比预期走得更远。作为继任者的IPv6吸取了IPv4的教训，被赋予充足地址空间的同时在各个方面做了优化——安全、高效、简洁。但是IPv6无法平滑地取代IPv4，导致IP升级步伐缓慢。尽管网络协议的分层设计很清晰，大量应用层协议和互联网软件中仍内嵌了IPv4地址的处理，要Internet全网升级到IPv6，必须先完成应用的改造。因为NAT和它的穿越技术结合能够满足大部分用户的需求，所以IPv6时代被不断推迟。\n\n随着IPv4地址的濒临耗尽，再经济的模式也无以为继，IPv4必须退出历史舞台。人们自然会认为，NAT作为IPv4的超级补丁技术使命已经完结。实际情况是，IPv4向IPv6过渡的阶段，NAT仍然是一项必不可少的技术手段。因为Internet无法在一日之内完成全网升级，必然是局部升级，逐渐替换。在两套协议并存的时期，用户和服务资源分布在不同网络之间，跨网访问的需求必须得到满足。这正是NAT所擅长的领域，地址替换，因此NAT-PT应运而生。由于IPv4和IPv6之间的差异，NAT要做的事比以往更复杂，有更多的限制和细节。\n\n此外，IETF也在制定纯IPv6网络使用的NAT规范。虽然人们还看不到这种应用的强烈需求，但是NAT仍有其独特的作用，比如隐藏内部网络的地址，实现重叠地址网络的合并等。\n\n毫不夸张地说，正是有了NAT，以IPv4为基础的Internet才能容纳数十亿的用户终端，成就今日之辉煌。IPv4已至日暮西山，IPv6的黎明尚未来临，Internet比任何时刻都更依赖NAT这项过渡技术。NAT的历史再次证明，翻天覆地的划时代进步不一定有市场，抱残守缺的修修补补未必不会成功。在世代更替之时让我们走近NAT，领略IP领域更多细微但不高深的知识，理解NAT就是理解变换万千的应用世界。\n","slug":"p2p1","published":1,"updated":"2018-09-06T09:28:54.953Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlqdfcwa0002owv3o6incsb0","content":"<h1 id=\"1-IPv4协议和NAT的由来\"><a href=\"#1-IPv4协议和NAT的由来\" class=\"headerlink\" title=\"1. IPv4协议和NAT的由来\"></a>1. IPv4协议和NAT的由来</h1><p>今天，无数快乐的互联网用户在尽情享受Internet带来的乐趣。他们浏览新闻，搜索资料，下载软件，广交新朋，分享信息，甚至于足不出户获取一切日用所需。企业利用互联网发布信息，传递资料和订单，提供技术支持，完成日常办公。然而，Internet在给亿万用户带来便利的同时，自身却面临一个致命的问题：构建这个无所不能的Internet的基础IPv4协议已经不能再提供新的网络地址了。</p>\n<p>2011年2月3日中国农历新年， IANA对外宣布：IPv4地址空间最后5个地址块已经被分配给下属的5个地区委员会。2011年4月15日，亚太区委员会APNIC对外宣布，除了个别保留地址外，本区域所有的IPv4地址基本耗尽。一时之间，IPv4地址作为一种濒危资源身价陡增，各大网络公司出巨资收购剩余的空闲地址。其实，IPv4地址不足问题已不是新问题，早在20年以前，IPv4地址即将耗尽的问题就已经摆在Internet先驱们面前。这不禁让我们想去了解，是什么技术使这一危机延缓了尽20年。</p>\n<p>要找到问题的答案，让我们先来简略回顾一下IPv4协议。</p>\n<p>IPv4即网际网协议第4版——Internet Protocol Version 4的缩写。IPv4定义一个跨越异种网络互连的超级网，它为每个网际网的节点分配全球唯一IP地址。如果我们把Internet比作一个邮政系统，那么IP地址的作用就等同于包含城市、街区、门牌编号在内的完整地址。IPv4使用32bits整数表达一个地址，地址最大范围就是232 约为43亿。以IP创始时期可被联网的设备来看，这样的一个空间已经很大，很难被短时间用完。然而，事实远远超出人们的设想，计算机网络在此后的几十年里迅速壮大，网络终端数量呈爆炸性增长。</p>\n<p>更为糟糕的是，为了路由和管理方便，43亿的地址空间被按照不同前缀长度划分为A,B,C,D类地址网络和保留地址。其中，A类网络地址127段，每段包括主机地址约1678万个。B类网络地址16384段，每段包括65536个主机地址。</p>\n<p><img src=\"http://www.52im.net/data/attachment/forum/201509/06/200926crr724j68tledk1p.png\" alt=\"image\"></p>\n<p>IANA向超大型企业/组织分配A类网络地址，一次一段。向中型企业或教育机构分配B类网络地址，一次一段。这样一种分配策略使得IP地址浪费很严重，很多被分配出去的地址没有真实被利用，地址消耗很快。以至于二十世纪90年代初，网络专家们意识到，这样大手大脚下去，IPv4地址很快就要耗光了。于是，人们开始考虑IPv4的替代方案，同时采取一系列的措施来减缓IPv4地址的消耗。正是在这样一个背景之下，本期的主角闪亮登场，它就是网络地址转换——NAT。</p>\n<p>NAT是一项神奇的技术，说它神奇在于它的出现几乎使IPv4起死回生。在IPv4已经被认为行将结束历史使命之后近20年时间里，人们几乎忘了IPv4的地址空间即将耗尽这样一个事实——在新技术日新月异的时代，20年可算一段漫长的历史。更不用说，在NAT产生以后，网络终端的数量呈加速上升趋势，对IP地址的需求剧烈增加。此足见NAT技术之成功，影响之深远。</p>\n<p>说它神奇，更因为NAT给IP网络模型带来了深远影响，其身影遍布网络每个角落。根据一份最近的研究报告，70%的P2P用户位于NAT网关以内。因为P2P主要运行在终端用户的个人电脑之上，这个数字意味着大多数PC通过NAT网关连接到Internet。如果加上2G和3G方式联网的智能手机等移动终端，在NAT网关之后的用户远远超过这个比例。</p>\n<p>然而当我们求本溯源时却发现一个很奇怪的事实：NAT这一意义重大的技术，竟然没有公认的发明者。NAT第一个版本的RFC作者，只是整理归纳了已被广泛采用的技术。</p>\n<a id=\"more\"></a>\n<h1 id=\"2-NAT的工作模型和特点\"><a href=\"#2-NAT的工作模型和特点\" class=\"headerlink\" title=\"2. NAT的工作模型和特点\"></a>2. NAT的工作模型和特点</h1><blockquote>\n<p>2.1 NAT的概念模型</p>\n</blockquote>\n<p>NAT名字很准确，网络地址转换，就是替换IP报文头部的地址信息。NAT通常部署在一个组织的网络出口位置，通过将内部网络IP地址替换为出口的IP地址提供公网可达性和上层协议的连接能力。那么，什么是内部网络IP地址？</p>\n<p>RFC1918规定了三个保留地址段落：10.0.0.0-10.255.255.255；172.16.0.0-172.31.255.255；192.168.0.0-192.168.255.255。这三个范围分别处于A,B,C类的地址段，不向特定的用户分配，被IANA作为私有地址保留。这些地址可以在任何组织或企业内部使用，和其他Internet地址的区别就是，仅能在内部使用，不能作为全球路由地址。这就是说，出了组织的管理范围这些地址就不再有意义，无论是作为源地址，还是目的地址。对于一个封闭的组织，如果其网络不连接到Internet，就可以使用这些地址而不用向IANA提出申请，而在内部的路由管理和报文传递方式与其他网络没有差异。</p>\n<p>对于有Internet访问需求而内部又使用私有地址的网络，就要在组织的出口位置部署NAT网关，在报文离开私网进入Internet时，将源IP替换为公网地址，通常是出口设备的接口地址。一个对外的访问请求在到达目标以后，表现为由本组织出口设备发起，因此被请求的服务端可将响应由Internet发回出口网关。出口网关再将目的地址替换为私网的源主机地址，发回内部。这样一次由私网主机向公网服务端的请求和响应就在通信两端均无感知的情况下完成了。依据这种模型，数量庞大的内网主机就不再需要公有IP地址了。</p>\n<p><img src=\"http://www.52im.net/data/attachment/forum/201509/06/202518pip8a6h99c8xc6i6.png\" alt=\"image\"></p>\n<p>虽然实际过程远比这个复杂，但上面的描述概括了NAT处理报文的几个关键特点：</p>\n<ol>\n<li>网络被分为私网和公网两个部分，NAT网关设置在私网到公网的路由出口位置，双向流量必须都要经过NAT网关；</li>\n<li>网络访问只能先由私网侧发起，公网无法主动访问私网主机； </li>\n<li>NAT网关在两个访问方向上完成两次地址的转换或翻译，出方向做源信息替换，入方向做目的信息替换； </li>\n<li>NAT网关的存在对通信双方是保持透明的； </li>\n<li>NAT网关为了实现双向翻译的功能，需要维护一张关联表，把会话的信息保存下来。</li>\n</ol>\n<p>随着后面对NAT的深入描述，读者会发现，这些特点是鲜明的，但又不是绝对的。其中第二个特点打破了IP协议架构中所有节点在通讯中的对等地位，这是NAT最大的弊端，为对等通讯带来了诸多问题，当然相应的克服手段也应运而生。事实上，第四点是NAT致力于达到的目标，但在很多情况下，NAT并没有做到，因为除了IP首部，上层通信协议经常在内部携带IP地址信息。这些我们稍后解释。</p>\n<blockquote>\n<p>2.2 一对一的NAT</p>\n</blockquote>\n<p>如果一个内部主机唯一占用一个公网IP，这种方式被称为一对一模型。此种方式下，转换上层协议就是不必要的，因为一个公网IP就能唯一对应一个内部主机。显然，这种方式对节约公网IP没有太大意义，主要是为了实现一些特殊的组网需求。比如用户希望隐藏内部主机的真实IP，或者实现两个IP地址重叠网络的通信。</p>\n<blockquote>\n<p>2.3 一对多的NAT</p>\n</blockquote>\n<p>NAT最典型的应用场景就如同图2描述的，一个组织网络，在出口位置部署NAT网关，所有对公网的访问表现为一台主机。这就是所谓的一对多模型。这种方式下，出口设备只占用一个由Internet服务提供商分配的公网IP地址。面对私网内部数量庞大的主机，如果NAT只进行IP地址的简单替换，就会产生一个问题：当有多个内部主机去访问同一个服务器时，从返回的信息不足以区分响应应该转发到哪个内部主机。此时，需要NAT设备根据传输层信息或其他上层协议去区分不同的会话，并且可能要对上层协议的标识进行转换，比如TCP或UDP端口号。这样NAT网关就可以将不同的内部连接访问映射到同一公网IP的不同传输层端口，通过这种方式实现公网IP的复用和解复用。这种方式也被称为端口转换PAT、NAPT或IP伪装，但更多时候直接被称为NAT，因为它是最典型的一种应用模式。</p>\n<blockquote>\n<p>2.4 按照NAT端口映射方式分类</p>\n</blockquote>\n<p>在一对多模型中，按照端口转换的工作方式不同，又可以进行更进一步的划分。为描述方便，以下将IP和端口标记为(nAddr:nPort)，其中n代表主机或NAT网关的不同角色。</p>\n<p><img src=\"http://www.52im.net/data/attachment/forum/201509/06/202751b5p2nmsj6nu5sujj.png\" alt=\"image\"></p>\n<ul>\n<li>全锥形NAT</li>\n</ul>\n<p>其特点为：一旦内部主机端口对(iAddr:iPort)被NAT网关映射到(eAddr:ePort)，所有后续的(iAddr:iPort)报文都会被转换为(eAddr:ePort)；任何一个外部主机发送到(eAddr:ePort)的报文将会被转换后发到(iAddr:iPort)。</p>\n<ul>\n<li>限制锥形NAT</li>\n</ul>\n<p>其特点为：一旦内部主机端口对(iAddr:iPort)被映射到(eAddr:ePort)，所有后续的(iAddr:iPort)报文都会被转换为(eAddr:ePort)；只有 (iAddr:iPort)向特定的外部主机hAddr发送过数据，主机hAddr从任意端口发送到(eAddr:ePort)的报文将会被转发到(iAddr:iPort)。</p>\n<ul>\n<li>端口限制锥形NAT</li>\n</ul>\n<p>其特点为：一旦内部主机端口对(iAddr:iPort)被映射到(eAddr:ePort)，所有后续的(iAddr:iPort)报文都会被转换为(eAddr:ePort)；只有(iAddr:iPort)向特定的外部主机端口对(hAddr:hPort)发送过数据，由 (hAddr:hPort)发送到(eAddr:ePort)的报文将会被转发到(iAddr:iPort)。</p>\n<ul>\n<li>对称型NAT</li>\n</ul>\n<p>其特点为：NAT网关会把内部主机“地址端口对”和外部主机“地址端口对”完全相同的报文看作一个连接，在网关上创建一个公网“地址端口对”映射进行转换，只有收到报文的外部主机从对应的端口对发送回应的报文，才能被转换。即使内部主机使用之前用过的地址端口对去连接不同外部主机(或端口)时，NAT网关也会建立新的映射关系。</p>\n<p>事实上，这些术语的引入是很多混淆的起源。现实中的很多NAT设备是将这些转换方式混合在一起工作的，而不单单使用一种，所以这些术语只适合描述一种工作方式，而不是一个设备。比如，很多NAT设备对内部发出的连接使用对称型NAT方式，而同时支持静态的端口映射，后者可以被看作是全锥型NAT方式。而有些情况下，NAT设备的一个公网地址和端口可以同时映射到内部几个服务器上以实现负载分担，比如一个对外提供WEB服务器的站点可能是有成百上千个服务器在提供HTTP服务，但是对外却表现为一个或少数几个IP地址。</p>\n<h1 id=\"3-NAT的限制与解决方案\"><a href=\"#3-NAT的限制与解决方案\" class=\"headerlink\" title=\"3. NAT的限制与解决方案\"></a>3. NAT的限制与解决方案</h1><blockquote>\n<p>3.1 IP端到端服务模型</p>\n</blockquote>\n<p>IP协议的一个重要贡献是把世界变得平等。在理论上，具有IP地址的每个站点在协议层面有相当的获取服务和提供服务的能力，不同的IP地址之间没有差异。人们熟知的服务器和客户机实际是在应用协议层上的角色区分，而在网络层和传输层没有差异。一个具有IP地址的主机既可以是客户机，也可以是服务器，大部分情况下，既是客户机，也是服务器。端到端对等看起来是很平常的事情，而意义并不寻常。但在以往的技术中，很多协议体系下的网络限定了终端的能力。正是IP的这个开放性，使得TCP/IP协议族可以提供丰富的功能，为应用实现提供了广阔平台。因为所有的IP主机都可以服务器的形式出现，所以通讯设计可以更加灵活。使用UNIX/LINUX的系统充分利用了这个特性，使得任何一个主机都可以建立自己的HTTP、SMTP、POP3、DNS、DHCP等服务。与此同时，很多应用也是把客户端和服务器的角色组合起来完成功能。例如在VoIP应用中，用户端向注册服务器登录自己的IP地址和端口信息过程中，主机是客户端；而在呼叫到达时，呼叫处理服务器向用户端发送呼叫请求时，用户端实际工作在服务器模式下。在语音媒体流信道建立过程后，通讯双向发送语音数据，发送端是客户模式，接收端是服务器模式。而在P2P的应用中，一个用户的主机既为下载的客户，同时也向其他客户提供数据，是一种C/S混合的模型。上层应用之所以能这样设计，是因为IP协议栈定义了这样的能力。试想一下，如果IP提供的能力不对等，那么每个通信会话都只能是单方向发起的，这会极大限制通信的能力。细心的读者会发现，前面介绍NAT的一个特性正是这样一种限制。没错，NAT最大的弊端正在于此——破坏了IP端到端通信的能力。</p>\n<blockquote>\n<p>3.2 NAT的弊端</p>\n</blockquote>\n<p>NAT在解决IPv4地址短缺问题上，并非没有副作用，其实存在很多问题。</p>\n<p>首先，NAT使IP会话的保持时效变短。因为一个会话建立后会在NAT设备上建立一个关联表，在会话静默的这段时间，NAT网关会进行老化操作。这是任何一个NAT网关必须做的事情，因为IP和端口资源有限，通信的需求无限，所以必须在会话结束后回收资源。通常TCP会话通过协商的方式主动关闭连接，NAT网关可以跟踪这些报文，但总是存在例外的情况，要依赖自己的定时器去回收资源。而基于UDP的通信协议很难确定何时通信结束，所以NAT网关主要依赖超时机制回收外部端口。通过定时器老化回收会带来一个问题，如果应用需要维持连接的时间大于NAT网关的设置，通信就会意外中断。因为网关回收相关转换表资源以后，新的数据到达时就找不到相关的转换信息，必须建立新的连接。当这个新数据是由公网侧向私网侧发送时，就会发生无法触发新连接建立，也不能通知到私网侧的主机去重建连接的情况。这时候通信就会中断，不能自动恢复。即使新数据是从私网侧发向公网侧，因为重建的会话表往往使用不同于之前的公网IP和端口地址，公网侧主机也无法对应到之前的通信上，导致用户可感知的连接中断。NAT网关要把回收空闲连接的时间设置到不发生持续的资源流失，又维持大部分连接不被意外中断，是一件比较有难度的事情。在NAT已经普及化的时代，很多应用协议的设计者已经考虑到了这种情况，所以一般会设置一个连接保活的机制，即在一段时间没有数据需要发送时，主动发送一个NAT能感知到而又没有实际数据的保活消息，这么做的主要目的就是重置NAT的会话定时器。</p>\n<p>其次，NAT在实现上将多个内部主机发出的连接复用到一个IP上，这就使依赖IP进行主机跟踪的机制都失效了。如网络管理中需要的基于网络流量分析的应用无法跟踪到终端用户与流量的具体行为的关系。基于用户行为的日志分析也变得困难，因为一个IP被很多用户共享，如果存在恶意的用户行为，很难定位到发起连接的那个主机。即便有一些机制提供了在NAT网关上进行连接跟踪的方法，但是把这种变换关系接续起来也困难重重。基于IP的用户授权不再可靠，因为拥有一个IP的不等于一个用户或主机。一个服务器也不能简单把同一IP的访问视作同一主机发起的，不能进行关联。有些服务器设置有连接限制，同一时刻只接纳来自一个IP的有限访问(有时是仅一个访问)，这会造成不同用户之间的服务抢占和排队。有时服务器端这样做是出于DOS攻击防护的考虑，因为一个用户正常情况下不应该建立大量的连接请求，过度使用服务资源被理解为攻击行为。但是这在NAT存在时不能简单按照连接数判断。总之，因为NAT隐蔽了通信的一端，把简单的事情复杂化了。</p>\n<p>我们来深入理解NAT一下对IP端到端模型的破坏力。NAT通过修改IP首部的信息变换通信的地址。但是在这个转换过程中只能基于一个会话单位。当一个应用需要保持多个双向连接时，麻烦就很大。NAT不能理解多个会话之间的关联性，无法保证转换符合应用需要的规则。当NAT网关拥有多个公有IP地址时，一组关联会话可能被分配到不同的公网地址，这通常是服务器端无法接受的。更为严重的是，当公网侧的主机要主动向私网侧发送数据时，NAT网关没有转换这个连接需要的关联表，这个数据包无法到达私网侧的主机。这些反方向发送数据的连接总有应用协议的约定或在初始建立的会话中进行过协商。但是因为NAT工作在网络层和传输层，无法理解应用层协议的行为，对这些信息是无知的。NAT希望自己对通信双方是透明的，但是在这些情况下这是一种奢望。</p>\n<p><img src=\"http://www.52im.net/data/attachment/forum/201509/06/203015ak3kk90kyh4c8484.png\" alt=\"image\"></p>\n<p>此外，NAT工作机制依赖于修改IP包头的信息，这会妨碍一些安全协议的工作。因为NAT篡改了IP地址、传输层端口号和校验和，这会导致认证协议彻底不能工作，因为认证目的就是要保证这些信息在传输过程中没有变化。对于一些隧道协议，NAT的存在也导致了额外的问题，因为隧道协议通常用外层地址标识隧道实体，穿过NAT的隧道会有IP复用关系，在另一端需要小心处理。ICMP是一种网络控制协议，它的工作原理也是在两个主机之间传递差错和控制消息，因为IP的对应关系被重新映射，ICMP也要进行复用和解复用处理，很多情况下因为ICMP报文载荷无法提供足够的信息，解复用会失败。IP分片机制是在信息源端或网络路径上，需要发送的IP报文尺寸大于路径实际能承载最大尺寸时，IP协议层会将一个报文分成多个片断发送，然后在接收端重组这些片断恢复原始报文。IP这样的分片机制会导致传输层的信息只包括在第一个分片中，NAT难以识别后续分片与关联表的对应关系，因此需要特殊处理。</p>\n<blockquote>\n<p>3.3 NAT穿越技术</p>\n</blockquote>\n<p>前面解释了NAT的弊端，为了解决IP端到端应用在NAT环境下遇到的问题，网络协议的设计者们创造了各种武器来进行应对。但遗憾的是，这里每一种方法都不完美，还需要在内部主机、应用程序或者NAT网关上增加额外的处理。</p>\n<ul>\n<li>应用层网关</li>\n</ul>\n<p>应用层网关(ALG)是解决NAT对应用层协议无感知的一个最常用方法，已经被NAT设备厂商广泛采用，成为NAT设备的一个必需功能。因为NAT不感知应用协议，所以有必要额外为每个应用协议定制协议分析功能，这样NAT网关就能理解并支持特定的协议。ALG与NAT形成互动关系，在一个NAT网关检测到新的连接请求时，需要判断是否为已知的应用类型，这通常是基于连接的传输层端口信息来识别的。在识别为已知应用时，再调用相应功能对报文的深层内容进行检查，当发现任何形式表达的IP地址和端口时，将会把这些信息同步转换，并且为这个新连接创建一个附加的转换表项。这样，当报文到达公网侧的目的主机时，应用层协议中携带的信息就是NAT网关提供的地址和端口。一旦公网侧主机开始发送数据或建立连接到此端口，NAT网关就可以根据关联表信息进行转换，再把数据转发到私网侧的主机。很多应用层协议实现不限于一个初始连接(通常为信令或控制通道)加一个数据连接，可能是一个初始连接对应很多后续的新连接。比较特别的协议，在一次协商中会产生一组相关连接，比如RTP/RTCP协议规定，一个RTP通道建立后占用连续的两个端口，一个服务于数据，另一个服务于控制消息。此时，就需要ALG分配连续的端口为应用服务。ALG能成功解决大部分协议的NAT穿越需求，但是这个方法也有很大的限制。因为应用协议的数量非常多而且在不断发展变化之中，添加到设备中的ALG功能都是为特定协议的特定规范版本而开发的，协议的创新和演进要求NAT设备制造商必须跟踪这些协议的最近标准，同时兼容旧标准。尽管有如Linux这种开放平台允许动态加载新的ALG特性，但是管理成本仍然很高，网络维护人员也不能随时了解用户都需要什么应用。因此为每个应用协议开发ALG代码并跟踪最新标准是不可行的，ALG只能解决用户最常用的需求。此外，出于安全性需要，有些应用类型报文从源端发出就已经加密，这种报文在网络中间无法进行分析，所以ALG无能为力。</p>\n<ul>\n<li>探针技术STUN和TURN</li>\n</ul>\n<p>所谓探针技术，是通过在所有参与通信的实体上安装探测插件，以检测网络中是否存在NAT网关，并对不同NAT模型实施不同穿越方法的一种技术。STUN服务器被部署在公网上，用于接收来自通信实体的探测请求，服务器会记录收到请求的报文地址和端口，并填写到回送的响应报文中。客户端根据接收到的响应消息中记录的地址和端口与本地选择的地址和端口进行比较，就能识别出是否存在NAT网关。如果存在NAT网关，客户端会使用之前的地址和端口向服务器的另外一个IP发起请求，重复前面的探测。然后再比较两次响应返回的结果判断出NAT工作的模式。由前述的一对多转换模型得知，除对称型NAT以外的模型，NAT网关对内部主机地址端口的映射都是相对固定的，所以比较容易实现NAT穿越。而对称型NAT为每个连接提供一个映射，使得转换后的公网地址和端口对不可预测。此时TURN可以与STUN绑定提供穿越NAT的服务，即在公网服务器上提供一个“地址端口对”，所有此“地址端口对”接收到的数据会经由探测建立的连接转发到内网主机上。TURN分配的这个映射“地址端口对”会通过STUN响应发给内部主机，后者将此信息放入建立连接的信令中通知通信的对端。这种探针技术是一种通用方法，不用在NAT设备上为每种应用协议开发功能，相对于ALG方式有一定普遍性。但是TURN中继服务会成为通信瓶颈。而且在客户端中增加探针功能要求每个应用都要增加代码才能支持。</p>\n<ul>\n<li>中间件技术</li>\n</ul>\n<p>这也是一种通过开发通用方法解决NAT穿越问题的努力。与前者不同之处是，NAT网关是这一解决方案的参与者。与ALG的不同在于，客户端会参与网关公网映射信息的维护，此时NAT网关只要理解客户端的请求并按照要求去分配转换表，不需要自己去分析客户端的应用层数据。其中UPnP就是这样一种方法。UPnP中文全称为通用即插即用，是一个通用的网络终端与网关的通信协议，具备信息发布和管理控制的能力。其中，网关映射请求可以为客户动态添加映射表项。此时，NAT不再需要理解应用层携带的信息，只转换IP地址和端口信息。而客户端通过控制消息或信令发到公网侧的信息中，直接携带公网映射的IP地址和端口，接收端可以按照此信息建立数据连接。NAT网关在收到数据或连接请求时，按照UPnP建立的表项只转换地址和端口信息，不关心内容，再将数据转发到内网。这种方案需要网关、内部主机和应用程序都支持UPnP技术，且组网允许内部主机和NAT网关之间可以直接交换UPnP信令才能实施。</p>\n<ul>\n<li>中继代理技术</li>\n</ul>\n<p>准确说它不是NAT穿越技术，而是NAT旁路技术。简单说，就是在NAT网关所在的位置旁边放置一个应用服务器，这个服务器在内部网络和外部公网分别有自己的网络连接。客户端特定的应用产生网络请求时，将定向发送到应用代理服务器。应用代理服务器根据代理协议解析客户端的请求，再从服务器的公网侧发起一个新的请求，把客户端请求的内容中继到外部网络上，返回的相应反方向中继。这项技术和ALG有很大的相似性，它要求为每个应用类型部署中继代理业务，中间服务器要理解这些请求。</p>\n<ul>\n<li>特定协议的自穿越技术</li>\n</ul>\n<p>在所有方法中最复杂也最可靠的就是自己解决自己的问题。比如IKE和IPsec技术，在设计时就考虑了到如何穿越NAT的问题。因为这个协议是一个自加密的协议并且具有报文防修改的鉴别能力，其他通用方法爱莫能助。因为实际应用的NAT网关基本都是NAPT方式，所有通过传输层协议承载的报文可以顺利通过NAT。IKE和IPsec采用的方案就是用UDP在报文外面再加一层封装，而内部的报文就不再受到影响。IKE中还专门增加了NAT网关是否存在的检查能力以及绕开NAT网关检测IKE协议的方法。</p>\n<h1 id=\"4-NAT的应用和实现\"><a href=\"#4-NAT的应用和实现\" class=\"headerlink\" title=\"4. NAT的应用和实现\"></a>4. NAT的应用和实现</h1><blockquote>\n<p>4.1 NAT的应用</p>\n</blockquote>\n<p>NAT在当代Internet中被广泛采用，小至家庭网关，大到企业广域网出口甚至运营商业务网络出口。其实NAT在用户身边随处可见，一般家庭宽带接入的ADSL Modem和SOHO路由器都内置了NAT功能，WindowsXP支持网络连接共享，一个用户连接到公网可能会经过多层NAT而对此一无所知。很多企业也为节约IP费用采用NAT接入Internet，但是相比家庭用户有更复杂的需求。</p>\n<ul>\n<li>NAT多实例应用</li>\n</ul>\n<p>在VPN网络中，多实例路由意味着一个物理拓扑上承载多个逻辑拓扑，网络终端被分配到相互隔离的逻辑拓扑中，彼此之间没有路由的通路。但在访问Internet或者一些关键服务器资源时，被隔离的网络之间又存在共享资源的需求。NAT的多实例实现就是跨越这种逻辑拓扑的方法，把一个空间的网络地址映射到另一个空间。</p>\n<ul>\n<li>NAT的高可靠性组网</li>\n</ul>\n<p>提高网络可靠性是一个广泛的需求，NAT作为私网到公网的关键路径自然也需要高可靠性。当一个设备提供多个公网接口时，在多接口上部署NAT可以提供更高带宽和多ISP就近访问的能力。但是，当部署多个出口时，访问的流量可能会从不匹配的接口返回，这就要求NAT方案有良好的路由规划和部署合适的策略保证这种流量能够正确处理。在多个物理设备承担NAT功能时，不同设备之间的信息备份和流量分担也是一个组网难题。</p>\n<ul>\n<li>同时转换源和目的地址的应用</li>\n</ul>\n<p>前面我们介绍的所有NAT应用中，由内网向外网访问过程中，都是将源地址进行转换而目的地址保持不变，报文反方向进入时则处理目的地址。但有一些特殊应用需要在由内向外的IP通路上，替换目的IP地址。通常，这种应用会同时替换源地址和目的地址，在经过NAT网关以后完成两次地址转换。当两个均规划使用私属IP地址范围的网络进行合并时，终端用户都不想调整自己的IP地址方案，又希望开放一些网络资源给彼此访问。这时就可以通过NAT的两次地址转换来解决路由和地址规划无法解决的问题。</p>\n<p><img src=\"http://www.52im.net/data/attachment/forum/201509/06/203248s85pmn8l0iicoc0c.png\" alt=\"image\"></p>\n<blockquote>\n<p>4.2 NAT的设备实现</p>\n</blockquote>\n<p>NAT作为一个IP层业务特性，在产品实现中与防火墙、会话管理等特性有紧密联系，这是因为NAT判断一个进入设备的报文是否需要NAT处理，判断报文是否为一个新的连接，都需要通过匹配访问控制列表规则和查询会话关联表进行判断。为了满足不同应用场景的NAT需求， NAT的管理界面可提供用户多种配置策略。按照NAT的具体工作方式，又可以做如下分类。</p>\n<ul>\n<li>静态一对一地址映射</li>\n</ul>\n<p>这种工作方式下，NAT把一个私网地址和一个公网地址做静态关联，在从内而外的方向，将源IP匹配的私网IP替换为公网IP，反方向则将目的IP匹配公网IP的报文替换为私网IP。网络层以上的部分不进行替换处理，只修正校验和。</p>\n<ul>\n<li>静态多对多地址映射</li>\n</ul>\n<p>这种方式与上一种类似，只是把一段私网地址映射到一段公网地址。工作机制与前述的方式没有差别，只是简化配置工作量。</p>\n<ul>\n<li>动态端口映射</li>\n</ul>\n<p>这是最基本的工作方式，即前面多次介绍的将一段内网地址动态翻译为一个或多个公网IP，同时对传输层端口或其他上层协议信息进行转换，以实现IP复用。对由内而外的报文，替换源地址和端口，反向报文替换目的地址和端口。仅以连接公网的接口IP作为NAT转换的公网地址时，这种配置最简化，又被称为EasyIP。当以一段公网IP地址作为NAT转换地址时，需要配置一个地址池，NAT会自动在地址池中选择使用公网IP。</p>\n<ul>\n<li>动态地址映射(no-pat)</li>\n</ul>\n<p>这是介于静态多对多地址映射和动态端口映射方式之间的一种工作机制。当有一个私网向公网侧访问到达NAT网关时，NAT网关会检查这个私网IP是否已经有关联的公网IP映射。如果已经存在，则按照转换表直接替换IP，不修改上层协议。如果不存在关联表项，则在空闲的公网IP池中占用一个IP，并写入关联表中，以后按照这个关联关系进行地址转换。当这个私网主机发起的所有对外访问均关闭或超时后，回收公网IP。这种方式可以理解为一组内网主机抢占式地共享一个公网IP地址池。当公网IP地址池用完以后，新连接将无法建立。</p>\n<ul>\n<li>静态端口映射</li>\n</ul>\n<p>通过静态配置，把一个固定的私网IP地址和端口关联到一个公网地址和端口上。这种方式等同于前面介绍过的全锥模式，但是不需要内网主机首先发出报文。这种方式适用于在NAT网关上把一个知名服务（如HTTP）映射到一个内部主机上，也称为port forwarding。</p>\n<ul>\n<li>应用层网关(ALG)</li>\n</ul>\n<p>在所有NAT产品实现中，ALG是一个必需的功能组件。但在不同实现中，有些产品可以动态加载不同的ALG模块，有些产品可以提供ALG开关控制，有些则不提供任何用户接口。ALG解析上层应用协议的内容，并且根据需要修改IP和端口相关信息，创建和维护附加的关联表项。</p>\n<ul>\n<li>NAT转换关联表</li>\n</ul>\n<p>无论哪一种NAT工作方式，都要用到地址转换关联表，在不同产品的实现中，这个关联表的存储结构和在IP转发中调用的方式有很大不同。关联表中会记录源IP、目的IP、连接协议类型、传输层源端口、目的端口，以及转换后的源IP、源端口，目的IP、目的端口信息，这里的源和目的都是对应于从内网到外网的访问方向。依据NAT具体工作方式，这些信息可能全部填充，也可能部分填充。例如只按照IP做静态映射的方式，就不需要填入任何端口相关信息；对于静态端口映射，则只填入源相关的内容，而目的端的信息为空。</p>\n<h1 id=\"5-后IPv4时代的NAT\"><a href=\"#5-后IPv4时代的NAT\" class=\"headerlink\" title=\"5. 后IPv4时代的NAT\"></a>5. 后IPv4时代的NAT</h1><p>NAT是为延缓IPv4地址耗尽而推出的技术。毫无疑问，它已经出色完成了自己的历史使命，IPv4比预期走得更远。作为继任者的IPv6吸取了IPv4的教训，被赋予充足地址空间的同时在各个方面做了优化——安全、高效、简洁。但是IPv6无法平滑地取代IPv4，导致IP升级步伐缓慢。尽管网络协议的分层设计很清晰，大量应用层协议和互联网软件中仍内嵌了IPv4地址的处理，要Internet全网升级到IPv6，必须先完成应用的改造。因为NAT和它的穿越技术结合能够满足大部分用户的需求，所以IPv6时代被不断推迟。</p>\n<p>随着IPv4地址的濒临耗尽，再经济的模式也无以为继，IPv4必须退出历史舞台。人们自然会认为，NAT作为IPv4的超级补丁技术使命已经完结。实际情况是，IPv4向IPv6过渡的阶段，NAT仍然是一项必不可少的技术手段。因为Internet无法在一日之内完成全网升级，必然是局部升级，逐渐替换。在两套协议并存的时期，用户和服务资源分布在不同网络之间，跨网访问的需求必须得到满足。这正是NAT所擅长的领域，地址替换，因此NAT-PT应运而生。由于IPv4和IPv6之间的差异，NAT要做的事比以往更复杂，有更多的限制和细节。</p>\n<p>此外，IETF也在制定纯IPv6网络使用的NAT规范。虽然人们还看不到这种应用的强烈需求，但是NAT仍有其独特的作用，比如隐藏内部网络的地址，实现重叠地址网络的合并等。</p>\n<p>毫不夸张地说，正是有了NAT，以IPv4为基础的Internet才能容纳数十亿的用户终端，成就今日之辉煌。IPv4已至日暮西山，IPv6的黎明尚未来临，Internet比任何时刻都更依赖NAT这项过渡技术。NAT的历史再次证明，翻天覆地的划时代进步不一定有市场，抱残守缺的修修补补未必不会成功。在世代更替之时让我们走近NAT，领略IP领域更多细微但不高深的知识，理解NAT就是理解变换万千的应用世界。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"1-IPv4协议和NAT的由来\"><a href=\"#1-IPv4协议和NAT的由来\" class=\"headerlink\" title=\"1. IPv4协议和NAT的由来\"></a>1. IPv4协议和NAT的由来</h1><p>今天，无数快乐的互联网用户在尽情享受Internet带来的乐趣。他们浏览新闻，搜索资料，下载软件，广交新朋，分享信息，甚至于足不出户获取一切日用所需。企业利用互联网发布信息，传递资料和订单，提供技术支持，完成日常办公。然而，Internet在给亿万用户带来便利的同时，自身却面临一个致命的问题：构建这个无所不能的Internet的基础IPv4协议已经不能再提供新的网络地址了。</p>\n<p>2011年2月3日中国农历新年， IANA对外宣布：IPv4地址空间最后5个地址块已经被分配给下属的5个地区委员会。2011年4月15日，亚太区委员会APNIC对外宣布，除了个别保留地址外，本区域所有的IPv4地址基本耗尽。一时之间，IPv4地址作为一种濒危资源身价陡增，各大网络公司出巨资收购剩余的空闲地址。其实，IPv4地址不足问题已不是新问题，早在20年以前，IPv4地址即将耗尽的问题就已经摆在Internet先驱们面前。这不禁让我们想去了解，是什么技术使这一危机延缓了尽20年。</p>\n<p>要找到问题的答案，让我们先来简略回顾一下IPv4协议。</p>\n<p>IPv4即网际网协议第4版——Internet Protocol Version 4的缩写。IPv4定义一个跨越异种网络互连的超级网，它为每个网际网的节点分配全球唯一IP地址。如果我们把Internet比作一个邮政系统，那么IP地址的作用就等同于包含城市、街区、门牌编号在内的完整地址。IPv4使用32bits整数表达一个地址，地址最大范围就是232 约为43亿。以IP创始时期可被联网的设备来看，这样的一个空间已经很大，很难被短时间用完。然而，事实远远超出人们的设想，计算机网络在此后的几十年里迅速壮大，网络终端数量呈爆炸性增长。</p>\n<p>更为糟糕的是，为了路由和管理方便，43亿的地址空间被按照不同前缀长度划分为A,B,C,D类地址网络和保留地址。其中，A类网络地址127段，每段包括主机地址约1678万个。B类网络地址16384段，每段包括65536个主机地址。</p>\n<p><img src=\"http://www.52im.net/data/attachment/forum/201509/06/200926crr724j68tledk1p.png\" alt=\"image\"></p>\n<p>IANA向超大型企业/组织分配A类网络地址，一次一段。向中型企业或教育机构分配B类网络地址，一次一段。这样一种分配策略使得IP地址浪费很严重，很多被分配出去的地址没有真实被利用，地址消耗很快。以至于二十世纪90年代初，网络专家们意识到，这样大手大脚下去，IPv4地址很快就要耗光了。于是，人们开始考虑IPv4的替代方案，同时采取一系列的措施来减缓IPv4地址的消耗。正是在这样一个背景之下，本期的主角闪亮登场，它就是网络地址转换——NAT。</p>\n<p>NAT是一项神奇的技术，说它神奇在于它的出现几乎使IPv4起死回生。在IPv4已经被认为行将结束历史使命之后近20年时间里，人们几乎忘了IPv4的地址空间即将耗尽这样一个事实——在新技术日新月异的时代，20年可算一段漫长的历史。更不用说，在NAT产生以后，网络终端的数量呈加速上升趋势，对IP地址的需求剧烈增加。此足见NAT技术之成功，影响之深远。</p>\n<p>说它神奇，更因为NAT给IP网络模型带来了深远影响，其身影遍布网络每个角落。根据一份最近的研究报告，70%的P2P用户位于NAT网关以内。因为P2P主要运行在终端用户的个人电脑之上，这个数字意味着大多数PC通过NAT网关连接到Internet。如果加上2G和3G方式联网的智能手机等移动终端，在NAT网关之后的用户远远超过这个比例。</p>\n<p>然而当我们求本溯源时却发现一个很奇怪的事实：NAT这一意义重大的技术，竟然没有公认的发明者。NAT第一个版本的RFC作者，只是整理归纳了已被广泛采用的技术。</p>","more":"<h1 id=\"2-NAT的工作模型和特点\"><a href=\"#2-NAT的工作模型和特点\" class=\"headerlink\" title=\"2. NAT的工作模型和特点\"></a>2. NAT的工作模型和特点</h1><blockquote>\n<p>2.1 NAT的概念模型</p>\n</blockquote>\n<p>NAT名字很准确，网络地址转换，就是替换IP报文头部的地址信息。NAT通常部署在一个组织的网络出口位置，通过将内部网络IP地址替换为出口的IP地址提供公网可达性和上层协议的连接能力。那么，什么是内部网络IP地址？</p>\n<p>RFC1918规定了三个保留地址段落：10.0.0.0-10.255.255.255；172.16.0.0-172.31.255.255；192.168.0.0-192.168.255.255。这三个范围分别处于A,B,C类的地址段，不向特定的用户分配，被IANA作为私有地址保留。这些地址可以在任何组织或企业内部使用，和其他Internet地址的区别就是，仅能在内部使用，不能作为全球路由地址。这就是说，出了组织的管理范围这些地址就不再有意义，无论是作为源地址，还是目的地址。对于一个封闭的组织，如果其网络不连接到Internet，就可以使用这些地址而不用向IANA提出申请，而在内部的路由管理和报文传递方式与其他网络没有差异。</p>\n<p>对于有Internet访问需求而内部又使用私有地址的网络，就要在组织的出口位置部署NAT网关，在报文离开私网进入Internet时，将源IP替换为公网地址，通常是出口设备的接口地址。一个对外的访问请求在到达目标以后，表现为由本组织出口设备发起，因此被请求的服务端可将响应由Internet发回出口网关。出口网关再将目的地址替换为私网的源主机地址，发回内部。这样一次由私网主机向公网服务端的请求和响应就在通信两端均无感知的情况下完成了。依据这种模型，数量庞大的内网主机就不再需要公有IP地址了。</p>\n<p><img src=\"http://www.52im.net/data/attachment/forum/201509/06/202518pip8a6h99c8xc6i6.png\" alt=\"image\"></p>\n<p>虽然实际过程远比这个复杂，但上面的描述概括了NAT处理报文的几个关键特点：</p>\n<ol>\n<li>网络被分为私网和公网两个部分，NAT网关设置在私网到公网的路由出口位置，双向流量必须都要经过NAT网关；</li>\n<li>网络访问只能先由私网侧发起，公网无法主动访问私网主机； </li>\n<li>NAT网关在两个访问方向上完成两次地址的转换或翻译，出方向做源信息替换，入方向做目的信息替换； </li>\n<li>NAT网关的存在对通信双方是保持透明的； </li>\n<li>NAT网关为了实现双向翻译的功能，需要维护一张关联表，把会话的信息保存下来。</li>\n</ol>\n<p>随着后面对NAT的深入描述，读者会发现，这些特点是鲜明的，但又不是绝对的。其中第二个特点打破了IP协议架构中所有节点在通讯中的对等地位，这是NAT最大的弊端，为对等通讯带来了诸多问题，当然相应的克服手段也应运而生。事实上，第四点是NAT致力于达到的目标，但在很多情况下，NAT并没有做到，因为除了IP首部，上层通信协议经常在内部携带IP地址信息。这些我们稍后解释。</p>\n<blockquote>\n<p>2.2 一对一的NAT</p>\n</blockquote>\n<p>如果一个内部主机唯一占用一个公网IP，这种方式被称为一对一模型。此种方式下，转换上层协议就是不必要的，因为一个公网IP就能唯一对应一个内部主机。显然，这种方式对节约公网IP没有太大意义，主要是为了实现一些特殊的组网需求。比如用户希望隐藏内部主机的真实IP，或者实现两个IP地址重叠网络的通信。</p>\n<blockquote>\n<p>2.3 一对多的NAT</p>\n</blockquote>\n<p>NAT最典型的应用场景就如同图2描述的，一个组织网络，在出口位置部署NAT网关，所有对公网的访问表现为一台主机。这就是所谓的一对多模型。这种方式下，出口设备只占用一个由Internet服务提供商分配的公网IP地址。面对私网内部数量庞大的主机，如果NAT只进行IP地址的简单替换，就会产生一个问题：当有多个内部主机去访问同一个服务器时，从返回的信息不足以区分响应应该转发到哪个内部主机。此时，需要NAT设备根据传输层信息或其他上层协议去区分不同的会话，并且可能要对上层协议的标识进行转换，比如TCP或UDP端口号。这样NAT网关就可以将不同的内部连接访问映射到同一公网IP的不同传输层端口，通过这种方式实现公网IP的复用和解复用。这种方式也被称为端口转换PAT、NAPT或IP伪装，但更多时候直接被称为NAT，因为它是最典型的一种应用模式。</p>\n<blockquote>\n<p>2.4 按照NAT端口映射方式分类</p>\n</blockquote>\n<p>在一对多模型中，按照端口转换的工作方式不同，又可以进行更进一步的划分。为描述方便，以下将IP和端口标记为(nAddr:nPort)，其中n代表主机或NAT网关的不同角色。</p>\n<p><img src=\"http://www.52im.net/data/attachment/forum/201509/06/202751b5p2nmsj6nu5sujj.png\" alt=\"image\"></p>\n<ul>\n<li>全锥形NAT</li>\n</ul>\n<p>其特点为：一旦内部主机端口对(iAddr:iPort)被NAT网关映射到(eAddr:ePort)，所有后续的(iAddr:iPort)报文都会被转换为(eAddr:ePort)；任何一个外部主机发送到(eAddr:ePort)的报文将会被转换后发到(iAddr:iPort)。</p>\n<ul>\n<li>限制锥形NAT</li>\n</ul>\n<p>其特点为：一旦内部主机端口对(iAddr:iPort)被映射到(eAddr:ePort)，所有后续的(iAddr:iPort)报文都会被转换为(eAddr:ePort)；只有 (iAddr:iPort)向特定的外部主机hAddr发送过数据，主机hAddr从任意端口发送到(eAddr:ePort)的报文将会被转发到(iAddr:iPort)。</p>\n<ul>\n<li>端口限制锥形NAT</li>\n</ul>\n<p>其特点为：一旦内部主机端口对(iAddr:iPort)被映射到(eAddr:ePort)，所有后续的(iAddr:iPort)报文都会被转换为(eAddr:ePort)；只有(iAddr:iPort)向特定的外部主机端口对(hAddr:hPort)发送过数据，由 (hAddr:hPort)发送到(eAddr:ePort)的报文将会被转发到(iAddr:iPort)。</p>\n<ul>\n<li>对称型NAT</li>\n</ul>\n<p>其特点为：NAT网关会把内部主机“地址端口对”和外部主机“地址端口对”完全相同的报文看作一个连接，在网关上创建一个公网“地址端口对”映射进行转换，只有收到报文的外部主机从对应的端口对发送回应的报文，才能被转换。即使内部主机使用之前用过的地址端口对去连接不同外部主机(或端口)时，NAT网关也会建立新的映射关系。</p>\n<p>事实上，这些术语的引入是很多混淆的起源。现实中的很多NAT设备是将这些转换方式混合在一起工作的，而不单单使用一种，所以这些术语只适合描述一种工作方式，而不是一个设备。比如，很多NAT设备对内部发出的连接使用对称型NAT方式，而同时支持静态的端口映射，后者可以被看作是全锥型NAT方式。而有些情况下，NAT设备的一个公网地址和端口可以同时映射到内部几个服务器上以实现负载分担，比如一个对外提供WEB服务器的站点可能是有成百上千个服务器在提供HTTP服务，但是对外却表现为一个或少数几个IP地址。</p>\n<h1 id=\"3-NAT的限制与解决方案\"><a href=\"#3-NAT的限制与解决方案\" class=\"headerlink\" title=\"3. NAT的限制与解决方案\"></a>3. NAT的限制与解决方案</h1><blockquote>\n<p>3.1 IP端到端服务模型</p>\n</blockquote>\n<p>IP协议的一个重要贡献是把世界变得平等。在理论上，具有IP地址的每个站点在协议层面有相当的获取服务和提供服务的能力，不同的IP地址之间没有差异。人们熟知的服务器和客户机实际是在应用协议层上的角色区分，而在网络层和传输层没有差异。一个具有IP地址的主机既可以是客户机，也可以是服务器，大部分情况下，既是客户机，也是服务器。端到端对等看起来是很平常的事情，而意义并不寻常。但在以往的技术中，很多协议体系下的网络限定了终端的能力。正是IP的这个开放性，使得TCP/IP协议族可以提供丰富的功能，为应用实现提供了广阔平台。因为所有的IP主机都可以服务器的形式出现，所以通讯设计可以更加灵活。使用UNIX/LINUX的系统充分利用了这个特性，使得任何一个主机都可以建立自己的HTTP、SMTP、POP3、DNS、DHCP等服务。与此同时，很多应用也是把客户端和服务器的角色组合起来完成功能。例如在VoIP应用中，用户端向注册服务器登录自己的IP地址和端口信息过程中，主机是客户端；而在呼叫到达时，呼叫处理服务器向用户端发送呼叫请求时，用户端实际工作在服务器模式下。在语音媒体流信道建立过程后，通讯双向发送语音数据，发送端是客户模式，接收端是服务器模式。而在P2P的应用中，一个用户的主机既为下载的客户，同时也向其他客户提供数据，是一种C/S混合的模型。上层应用之所以能这样设计，是因为IP协议栈定义了这样的能力。试想一下，如果IP提供的能力不对等，那么每个通信会话都只能是单方向发起的，这会极大限制通信的能力。细心的读者会发现，前面介绍NAT的一个特性正是这样一种限制。没错，NAT最大的弊端正在于此——破坏了IP端到端通信的能力。</p>\n<blockquote>\n<p>3.2 NAT的弊端</p>\n</blockquote>\n<p>NAT在解决IPv4地址短缺问题上，并非没有副作用，其实存在很多问题。</p>\n<p>首先，NAT使IP会话的保持时效变短。因为一个会话建立后会在NAT设备上建立一个关联表，在会话静默的这段时间，NAT网关会进行老化操作。这是任何一个NAT网关必须做的事情，因为IP和端口资源有限，通信的需求无限，所以必须在会话结束后回收资源。通常TCP会话通过协商的方式主动关闭连接，NAT网关可以跟踪这些报文，但总是存在例外的情况，要依赖自己的定时器去回收资源。而基于UDP的通信协议很难确定何时通信结束，所以NAT网关主要依赖超时机制回收外部端口。通过定时器老化回收会带来一个问题，如果应用需要维持连接的时间大于NAT网关的设置，通信就会意外中断。因为网关回收相关转换表资源以后，新的数据到达时就找不到相关的转换信息，必须建立新的连接。当这个新数据是由公网侧向私网侧发送时，就会发生无法触发新连接建立，也不能通知到私网侧的主机去重建连接的情况。这时候通信就会中断，不能自动恢复。即使新数据是从私网侧发向公网侧，因为重建的会话表往往使用不同于之前的公网IP和端口地址，公网侧主机也无法对应到之前的通信上，导致用户可感知的连接中断。NAT网关要把回收空闲连接的时间设置到不发生持续的资源流失，又维持大部分连接不被意外中断，是一件比较有难度的事情。在NAT已经普及化的时代，很多应用协议的设计者已经考虑到了这种情况，所以一般会设置一个连接保活的机制，即在一段时间没有数据需要发送时，主动发送一个NAT能感知到而又没有实际数据的保活消息，这么做的主要目的就是重置NAT的会话定时器。</p>\n<p>其次，NAT在实现上将多个内部主机发出的连接复用到一个IP上，这就使依赖IP进行主机跟踪的机制都失效了。如网络管理中需要的基于网络流量分析的应用无法跟踪到终端用户与流量的具体行为的关系。基于用户行为的日志分析也变得困难，因为一个IP被很多用户共享，如果存在恶意的用户行为，很难定位到发起连接的那个主机。即便有一些机制提供了在NAT网关上进行连接跟踪的方法，但是把这种变换关系接续起来也困难重重。基于IP的用户授权不再可靠，因为拥有一个IP的不等于一个用户或主机。一个服务器也不能简单把同一IP的访问视作同一主机发起的，不能进行关联。有些服务器设置有连接限制，同一时刻只接纳来自一个IP的有限访问(有时是仅一个访问)，这会造成不同用户之间的服务抢占和排队。有时服务器端这样做是出于DOS攻击防护的考虑，因为一个用户正常情况下不应该建立大量的连接请求，过度使用服务资源被理解为攻击行为。但是这在NAT存在时不能简单按照连接数判断。总之，因为NAT隐蔽了通信的一端，把简单的事情复杂化了。</p>\n<p>我们来深入理解NAT一下对IP端到端模型的破坏力。NAT通过修改IP首部的信息变换通信的地址。但是在这个转换过程中只能基于一个会话单位。当一个应用需要保持多个双向连接时，麻烦就很大。NAT不能理解多个会话之间的关联性，无法保证转换符合应用需要的规则。当NAT网关拥有多个公有IP地址时，一组关联会话可能被分配到不同的公网地址，这通常是服务器端无法接受的。更为严重的是，当公网侧的主机要主动向私网侧发送数据时，NAT网关没有转换这个连接需要的关联表，这个数据包无法到达私网侧的主机。这些反方向发送数据的连接总有应用协议的约定或在初始建立的会话中进行过协商。但是因为NAT工作在网络层和传输层，无法理解应用层协议的行为，对这些信息是无知的。NAT希望自己对通信双方是透明的，但是在这些情况下这是一种奢望。</p>\n<p><img src=\"http://www.52im.net/data/attachment/forum/201509/06/203015ak3kk90kyh4c8484.png\" alt=\"image\"></p>\n<p>此外，NAT工作机制依赖于修改IP包头的信息，这会妨碍一些安全协议的工作。因为NAT篡改了IP地址、传输层端口号和校验和，这会导致认证协议彻底不能工作，因为认证目的就是要保证这些信息在传输过程中没有变化。对于一些隧道协议，NAT的存在也导致了额外的问题，因为隧道协议通常用外层地址标识隧道实体，穿过NAT的隧道会有IP复用关系，在另一端需要小心处理。ICMP是一种网络控制协议，它的工作原理也是在两个主机之间传递差错和控制消息，因为IP的对应关系被重新映射，ICMP也要进行复用和解复用处理，很多情况下因为ICMP报文载荷无法提供足够的信息，解复用会失败。IP分片机制是在信息源端或网络路径上，需要发送的IP报文尺寸大于路径实际能承载最大尺寸时，IP协议层会将一个报文分成多个片断发送，然后在接收端重组这些片断恢复原始报文。IP这样的分片机制会导致传输层的信息只包括在第一个分片中，NAT难以识别后续分片与关联表的对应关系，因此需要特殊处理。</p>\n<blockquote>\n<p>3.3 NAT穿越技术</p>\n</blockquote>\n<p>前面解释了NAT的弊端，为了解决IP端到端应用在NAT环境下遇到的问题，网络协议的设计者们创造了各种武器来进行应对。但遗憾的是，这里每一种方法都不完美，还需要在内部主机、应用程序或者NAT网关上增加额外的处理。</p>\n<ul>\n<li>应用层网关</li>\n</ul>\n<p>应用层网关(ALG)是解决NAT对应用层协议无感知的一个最常用方法，已经被NAT设备厂商广泛采用，成为NAT设备的一个必需功能。因为NAT不感知应用协议，所以有必要额外为每个应用协议定制协议分析功能，这样NAT网关就能理解并支持特定的协议。ALG与NAT形成互动关系，在一个NAT网关检测到新的连接请求时，需要判断是否为已知的应用类型，这通常是基于连接的传输层端口信息来识别的。在识别为已知应用时，再调用相应功能对报文的深层内容进行检查，当发现任何形式表达的IP地址和端口时，将会把这些信息同步转换，并且为这个新连接创建一个附加的转换表项。这样，当报文到达公网侧的目的主机时，应用层协议中携带的信息就是NAT网关提供的地址和端口。一旦公网侧主机开始发送数据或建立连接到此端口，NAT网关就可以根据关联表信息进行转换，再把数据转发到私网侧的主机。很多应用层协议实现不限于一个初始连接(通常为信令或控制通道)加一个数据连接，可能是一个初始连接对应很多后续的新连接。比较特别的协议，在一次协商中会产生一组相关连接，比如RTP/RTCP协议规定，一个RTP通道建立后占用连续的两个端口，一个服务于数据，另一个服务于控制消息。此时，就需要ALG分配连续的端口为应用服务。ALG能成功解决大部分协议的NAT穿越需求，但是这个方法也有很大的限制。因为应用协议的数量非常多而且在不断发展变化之中，添加到设备中的ALG功能都是为特定协议的特定规范版本而开发的，协议的创新和演进要求NAT设备制造商必须跟踪这些协议的最近标准，同时兼容旧标准。尽管有如Linux这种开放平台允许动态加载新的ALG特性，但是管理成本仍然很高，网络维护人员也不能随时了解用户都需要什么应用。因此为每个应用协议开发ALG代码并跟踪最新标准是不可行的，ALG只能解决用户最常用的需求。此外，出于安全性需要，有些应用类型报文从源端发出就已经加密，这种报文在网络中间无法进行分析，所以ALG无能为力。</p>\n<ul>\n<li>探针技术STUN和TURN</li>\n</ul>\n<p>所谓探针技术，是通过在所有参与通信的实体上安装探测插件，以检测网络中是否存在NAT网关，并对不同NAT模型实施不同穿越方法的一种技术。STUN服务器被部署在公网上，用于接收来自通信实体的探测请求，服务器会记录收到请求的报文地址和端口，并填写到回送的响应报文中。客户端根据接收到的响应消息中记录的地址和端口与本地选择的地址和端口进行比较，就能识别出是否存在NAT网关。如果存在NAT网关，客户端会使用之前的地址和端口向服务器的另外一个IP发起请求，重复前面的探测。然后再比较两次响应返回的结果判断出NAT工作的模式。由前述的一对多转换模型得知，除对称型NAT以外的模型，NAT网关对内部主机地址端口的映射都是相对固定的，所以比较容易实现NAT穿越。而对称型NAT为每个连接提供一个映射，使得转换后的公网地址和端口对不可预测。此时TURN可以与STUN绑定提供穿越NAT的服务，即在公网服务器上提供一个“地址端口对”，所有此“地址端口对”接收到的数据会经由探测建立的连接转发到内网主机上。TURN分配的这个映射“地址端口对”会通过STUN响应发给内部主机，后者将此信息放入建立连接的信令中通知通信的对端。这种探针技术是一种通用方法，不用在NAT设备上为每种应用协议开发功能，相对于ALG方式有一定普遍性。但是TURN中继服务会成为通信瓶颈。而且在客户端中增加探针功能要求每个应用都要增加代码才能支持。</p>\n<ul>\n<li>中间件技术</li>\n</ul>\n<p>这也是一种通过开发通用方法解决NAT穿越问题的努力。与前者不同之处是，NAT网关是这一解决方案的参与者。与ALG的不同在于，客户端会参与网关公网映射信息的维护，此时NAT网关只要理解客户端的请求并按照要求去分配转换表，不需要自己去分析客户端的应用层数据。其中UPnP就是这样一种方法。UPnP中文全称为通用即插即用，是一个通用的网络终端与网关的通信协议，具备信息发布和管理控制的能力。其中，网关映射请求可以为客户动态添加映射表项。此时，NAT不再需要理解应用层携带的信息，只转换IP地址和端口信息。而客户端通过控制消息或信令发到公网侧的信息中，直接携带公网映射的IP地址和端口，接收端可以按照此信息建立数据连接。NAT网关在收到数据或连接请求时，按照UPnP建立的表项只转换地址和端口信息，不关心内容，再将数据转发到内网。这种方案需要网关、内部主机和应用程序都支持UPnP技术，且组网允许内部主机和NAT网关之间可以直接交换UPnP信令才能实施。</p>\n<ul>\n<li>中继代理技术</li>\n</ul>\n<p>准确说它不是NAT穿越技术，而是NAT旁路技术。简单说，就是在NAT网关所在的位置旁边放置一个应用服务器，这个服务器在内部网络和外部公网分别有自己的网络连接。客户端特定的应用产生网络请求时，将定向发送到应用代理服务器。应用代理服务器根据代理协议解析客户端的请求，再从服务器的公网侧发起一个新的请求，把客户端请求的内容中继到外部网络上，返回的相应反方向中继。这项技术和ALG有很大的相似性，它要求为每个应用类型部署中继代理业务，中间服务器要理解这些请求。</p>\n<ul>\n<li>特定协议的自穿越技术</li>\n</ul>\n<p>在所有方法中最复杂也最可靠的就是自己解决自己的问题。比如IKE和IPsec技术，在设计时就考虑了到如何穿越NAT的问题。因为这个协议是一个自加密的协议并且具有报文防修改的鉴别能力，其他通用方法爱莫能助。因为实际应用的NAT网关基本都是NAPT方式，所有通过传输层协议承载的报文可以顺利通过NAT。IKE和IPsec采用的方案就是用UDP在报文外面再加一层封装，而内部的报文就不再受到影响。IKE中还专门增加了NAT网关是否存在的检查能力以及绕开NAT网关检测IKE协议的方法。</p>\n<h1 id=\"4-NAT的应用和实现\"><a href=\"#4-NAT的应用和实现\" class=\"headerlink\" title=\"4. NAT的应用和实现\"></a>4. NAT的应用和实现</h1><blockquote>\n<p>4.1 NAT的应用</p>\n</blockquote>\n<p>NAT在当代Internet中被广泛采用，小至家庭网关，大到企业广域网出口甚至运营商业务网络出口。其实NAT在用户身边随处可见，一般家庭宽带接入的ADSL Modem和SOHO路由器都内置了NAT功能，WindowsXP支持网络连接共享，一个用户连接到公网可能会经过多层NAT而对此一无所知。很多企业也为节约IP费用采用NAT接入Internet，但是相比家庭用户有更复杂的需求。</p>\n<ul>\n<li>NAT多实例应用</li>\n</ul>\n<p>在VPN网络中，多实例路由意味着一个物理拓扑上承载多个逻辑拓扑，网络终端被分配到相互隔离的逻辑拓扑中，彼此之间没有路由的通路。但在访问Internet或者一些关键服务器资源时，被隔离的网络之间又存在共享资源的需求。NAT的多实例实现就是跨越这种逻辑拓扑的方法，把一个空间的网络地址映射到另一个空间。</p>\n<ul>\n<li>NAT的高可靠性组网</li>\n</ul>\n<p>提高网络可靠性是一个广泛的需求，NAT作为私网到公网的关键路径自然也需要高可靠性。当一个设备提供多个公网接口时，在多接口上部署NAT可以提供更高带宽和多ISP就近访问的能力。但是，当部署多个出口时，访问的流量可能会从不匹配的接口返回，这就要求NAT方案有良好的路由规划和部署合适的策略保证这种流量能够正确处理。在多个物理设备承担NAT功能时，不同设备之间的信息备份和流量分担也是一个组网难题。</p>\n<ul>\n<li>同时转换源和目的地址的应用</li>\n</ul>\n<p>前面我们介绍的所有NAT应用中，由内网向外网访问过程中，都是将源地址进行转换而目的地址保持不变，报文反方向进入时则处理目的地址。但有一些特殊应用需要在由内向外的IP通路上，替换目的IP地址。通常，这种应用会同时替换源地址和目的地址，在经过NAT网关以后完成两次地址转换。当两个均规划使用私属IP地址范围的网络进行合并时，终端用户都不想调整自己的IP地址方案，又希望开放一些网络资源给彼此访问。这时就可以通过NAT的两次地址转换来解决路由和地址规划无法解决的问题。</p>\n<p><img src=\"http://www.52im.net/data/attachment/forum/201509/06/203248s85pmn8l0iicoc0c.png\" alt=\"image\"></p>\n<blockquote>\n<p>4.2 NAT的设备实现</p>\n</blockquote>\n<p>NAT作为一个IP层业务特性，在产品实现中与防火墙、会话管理等特性有紧密联系，这是因为NAT判断一个进入设备的报文是否需要NAT处理，判断报文是否为一个新的连接，都需要通过匹配访问控制列表规则和查询会话关联表进行判断。为了满足不同应用场景的NAT需求， NAT的管理界面可提供用户多种配置策略。按照NAT的具体工作方式，又可以做如下分类。</p>\n<ul>\n<li>静态一对一地址映射</li>\n</ul>\n<p>这种工作方式下，NAT把一个私网地址和一个公网地址做静态关联，在从内而外的方向，将源IP匹配的私网IP替换为公网IP，反方向则将目的IP匹配公网IP的报文替换为私网IP。网络层以上的部分不进行替换处理，只修正校验和。</p>\n<ul>\n<li>静态多对多地址映射</li>\n</ul>\n<p>这种方式与上一种类似，只是把一段私网地址映射到一段公网地址。工作机制与前述的方式没有差别，只是简化配置工作量。</p>\n<ul>\n<li>动态端口映射</li>\n</ul>\n<p>这是最基本的工作方式，即前面多次介绍的将一段内网地址动态翻译为一个或多个公网IP，同时对传输层端口或其他上层协议信息进行转换，以实现IP复用。对由内而外的报文，替换源地址和端口，反向报文替换目的地址和端口。仅以连接公网的接口IP作为NAT转换的公网地址时，这种配置最简化，又被称为EasyIP。当以一段公网IP地址作为NAT转换地址时，需要配置一个地址池，NAT会自动在地址池中选择使用公网IP。</p>\n<ul>\n<li>动态地址映射(no-pat)</li>\n</ul>\n<p>这是介于静态多对多地址映射和动态端口映射方式之间的一种工作机制。当有一个私网向公网侧访问到达NAT网关时，NAT网关会检查这个私网IP是否已经有关联的公网IP映射。如果已经存在，则按照转换表直接替换IP，不修改上层协议。如果不存在关联表项，则在空闲的公网IP池中占用一个IP，并写入关联表中，以后按照这个关联关系进行地址转换。当这个私网主机发起的所有对外访问均关闭或超时后，回收公网IP。这种方式可以理解为一组内网主机抢占式地共享一个公网IP地址池。当公网IP地址池用完以后，新连接将无法建立。</p>\n<ul>\n<li>静态端口映射</li>\n</ul>\n<p>通过静态配置，把一个固定的私网IP地址和端口关联到一个公网地址和端口上。这种方式等同于前面介绍过的全锥模式，但是不需要内网主机首先发出报文。这种方式适用于在NAT网关上把一个知名服务（如HTTP）映射到一个内部主机上，也称为port forwarding。</p>\n<ul>\n<li>应用层网关(ALG)</li>\n</ul>\n<p>在所有NAT产品实现中，ALG是一个必需的功能组件。但在不同实现中，有些产品可以动态加载不同的ALG模块，有些产品可以提供ALG开关控制，有些则不提供任何用户接口。ALG解析上层应用协议的内容，并且根据需要修改IP和端口相关信息，创建和维护附加的关联表项。</p>\n<ul>\n<li>NAT转换关联表</li>\n</ul>\n<p>无论哪一种NAT工作方式，都要用到地址转换关联表，在不同产品的实现中，这个关联表的存储结构和在IP转发中调用的方式有很大不同。关联表中会记录源IP、目的IP、连接协议类型、传输层源端口、目的端口，以及转换后的源IP、源端口，目的IP、目的端口信息，这里的源和目的都是对应于从内网到外网的访问方向。依据NAT具体工作方式，这些信息可能全部填充，也可能部分填充。例如只按照IP做静态映射的方式，就不需要填入任何端口相关信息；对于静态端口映射，则只填入源相关的内容，而目的端的信息为空。</p>\n<h1 id=\"5-后IPv4时代的NAT\"><a href=\"#5-后IPv4时代的NAT\" class=\"headerlink\" title=\"5. 后IPv4时代的NAT\"></a>5. 后IPv4时代的NAT</h1><p>NAT是为延缓IPv4地址耗尽而推出的技术。毫无疑问，它已经出色完成了自己的历史使命，IPv4比预期走得更远。作为继任者的IPv6吸取了IPv4的教训，被赋予充足地址空间的同时在各个方面做了优化——安全、高效、简洁。但是IPv6无法平滑地取代IPv4，导致IP升级步伐缓慢。尽管网络协议的分层设计很清晰，大量应用层协议和互联网软件中仍内嵌了IPv4地址的处理，要Internet全网升级到IPv6，必须先完成应用的改造。因为NAT和它的穿越技术结合能够满足大部分用户的需求，所以IPv6时代被不断推迟。</p>\n<p>随着IPv4地址的濒临耗尽，再经济的模式也无以为继，IPv4必须退出历史舞台。人们自然会认为，NAT作为IPv4的超级补丁技术使命已经完结。实际情况是，IPv4向IPv6过渡的阶段，NAT仍然是一项必不可少的技术手段。因为Internet无法在一日之内完成全网升级，必然是局部升级，逐渐替换。在两套协议并存的时期，用户和服务资源分布在不同网络之间，跨网访问的需求必须得到满足。这正是NAT所擅长的领域，地址替换，因此NAT-PT应运而生。由于IPv4和IPv6之间的差异，NAT要做的事比以往更复杂，有更多的限制和细节。</p>\n<p>此外，IETF也在制定纯IPv6网络使用的NAT规范。虽然人们还看不到这种应用的强烈需求，但是NAT仍有其独特的作用，比如隐藏内部网络的地址，实现重叠地址网络的合并等。</p>\n<p>毫不夸张地说，正是有了NAT，以IPv4为基础的Internet才能容纳数十亿的用户终端，成就今日之辉煌。IPv4已至日暮西山，IPv6的黎明尚未来临，Internet比任何时刻都更依赖NAT这项过渡技术。NAT的历史再次证明，翻天覆地的划时代进步不一定有市场，抱残守缺的修修补补未必不会成功。在世代更替之时让我们走近NAT，领略IP领域更多细微但不高深的知识，理解NAT就是理解变换万千的应用世界。</p>"},{"title":"P2P技术详解(二)：P2P中的NAT穿越(打洞)方案详解","date":"2018-09-06T09:28:03.000Z","_content":"\n## 1、内容概述\n\nP2P即点对点通信，或称为对等联网，与传统的服务器客户端模式（如下图“P2P结构模型”所示）有着明显的区别，在即时通讯方案中应用广泛（比如IM应用中的实时音视频通信、实时文件传输甚至文字聊天等）。\n\nP2P可以是一种通信模式、一种逻辑网络模型、一种技术、甚至一种理念。在P2P网络中（如右图所示），所有通信节点的地位都是对等的，每个节点都扮演着客户机和服务器双重角色，节点之间通过直接通信实现文件信息、处理器运算能力、存储空间等资源的共享。P2P网络具有分散性、可扩展性、健壮性等特点，这使得P2P技术在信息共享、\b即时通讯、协同工作、分布式计算、网络存储等领域都有广阔的应用。\n\n图1 - 经典的CS模式：\n![image](http://www.52im.net/data/attachment/forum/201610/10/132736s7tqmprzhrz7wzds.jpg)\n\n图2 - P2P结构模型：\n![image](http://www.52im.net/data/attachment/forum/201610/10/132735dgcypehy72gbrv4d.jpg)\n\nNAT技术和P2P技术作为经典的两项网络技术，在现在的网络上有着广泛的应用，P2P主机位于NAT网关后面的情况屡见不鲜。NAT技术虽然在一定程度上解决了IPv4地址短缺的问题，在构建防火墙、保证网络安全方面都发挥了一定的作用，却破坏了端到端的网络通信。NAT阻碍主机进行P2P通信的主要原因是NAT不允许外网主机主动访问内网主机，但是P2P技术却要求通信双方都能主动发起访问，所以要在NAT网络环境中进行有效的P2P通信，就必须采用新的解决方案。\n\nP2P作为一项实用的技术，有很大的优化空间，并且相对于网络设备，基于P2P的应用程序在实现上更为灵活。所以为了兼容NAT，基于P2P的应用程序在开发的时候大多会根据自身特点加入一些穿越NAT的功能以解决上述问题。以下着重介绍几种常见的P2P穿越NAT方案。\n\n<!-- more -->\n\n## 2、反向链接技术：一种特殊的P2P场景（通信双方中只有一方位于NAT设备之后）\n\n此种情况是所有P2P场景中最简单的，它使用一种被称为“反向链接技术”来解决这个问题。大致的原理如下所述。\n\n如图3所示，客户端A位于NAT之后，它通过TCP端口1234连接到服务器的TCP端口1235上，NAT设备为这个连接重新分配了TCP端口62000。客户端B也通过TCP端口1234连接到服务器端口1235上。A和B从服务器处获知的对方的外网地址二元组{IP地址:端口号}分别为{138.76.29.7:1234}和{155.99.25.11:62000}，它们在各自的本地端口上进行侦听。\n\n由于B 拥有外网IP地址，所以A要发起与B的通信，可以直接通过TCP连接到B。但如果B尝试通过TCP连接到A进行P2P通信，则会失败，原因是A位于NAT设备后，虽然B发出的TCP SYN请求能够到达NAT设备的端口62000，但NAT设备会拒绝这个连接请求。要想与Client A通信， B不是直接向A发起连接，而是通过服务器给A转发一个连接请求，反过来请求A连接到B（即进行反向链接），A在收到从服务器转发过来的请求以后，会主动向B发起一个TCP的连接请求，这样在NAT设备上就会建立起关于这个连接的相关表项，使A和B之间能够正常通信，从而建立起它们之间的TCP连接。\n\n图3 - 反向链接示意图：\n![image](http://www.52im.net/data/attachment/forum/201610/10/133042i8nux66pj1jbul6p.jpg)\n\n## 3、基于UDP协议的P2P打洞技术详解\n\n> 原理概述\n\nUDP打洞技术是通过中间服务器的协助在各自的NAT网关上建立相关的表项，使P2P连接的双方发送的报文能够直接穿透对方的NAT网关，从而实现P2P客户端互连。如果两台位于NAT设备后面的P2P客户端希望在自己的NAT网关上打个洞，那么他们需要一个协助者——集中服务器，并且还需要一种用于打洞的Session建立机制。\n\n什么是集中服务器？\n\n集中服务器本质上是一台被设置在公网上的服务器，建立P2P的双方都可以直接访问到这台服务器。位于NAT网关后面的客户端A和B都可以与一台已知的集中服务器建立连接，并通过这台集中服务器了解对方的信息并中转各自的信息。\n\n同时集中服务器的另一个重要作用在于判断某个客户端是否在NAT网关之后。具体的方法是：一个客户端在集中服务器上登陆的时候，服务器记录下该客户端的两对地址二元组信息{IP地址:UDP端口}，一对是该客户端与集中服务器进行通信的自身的IP地址和端口号，另一对是集中服务器记录下的由服务器“观察”到的该客户端实际与自己通信所使用的IP地址和端口号。我们可以把前一对地址二元组看作是客户端的内网IP地址和端口号，把后一对地址二元组看作是客户端的内网IP地址和端口号经过NAT转换后的外网IP地址和端口号。集中服务器可以从客户端的登陆消息中得到该客户端的内网相关信息，还可以通过登陆消息的IP头和UDP头得到该客户端的外网相关信息。如果该客户端不是位于NAT设备后面，那么采用上述方法得到的两对地址二元组信息是完全相同的。\n\nP2P的Session建立原理：\n\n假定客户端A要发起对客户端B的直接连接，具体的“打洞”过程如下：\n1. A最初不知道如何向客户端B发起连接，于是A向集中服务器发送消息，请求集中服务器帮助建立与客户端B的UDP连接。\n2. 集中服务器将含有B的外网和内网的地址二元组发给A，同时，集中服务器将包含有A的外网和内网的地址二元组信息的消息也发给B。这样一来， A与B就都知道对方外网和内网的地址二元组信息了。\n3. 当A收到由集中服务器发来的包含B的外网和内网的地址二元组信息后， A开始向B的地址二元组发送UDP数据包，并且A会自动锁定第一个给出响应的B的地址二元组。同理，当B收到由集中服务器发来的A的外网和内网地址二元组信息后，也会开始向A的外网和内网的地址二元组发送UDP数据包，并且自动锁定第一个得到A回应的地址二元组。由于A与B互相向对方发送UDP数据包的操作是异步的，所以A和B发送数据包的时间先后并没有时序要求。\n\n下面来看下这三者之间是如何进行UDP打洞的。在这我们分三种具体情景来讨论：\n\n- 第一种是最简单的一种情景，两个客户端都位于同一个NAT设备后面，即位于同一内网中；\n- 第二种是最普遍的一种情景，两个客户端分别位于不同的NAT设备后面，分属不同的内网；\n- 第三种是客户端位于两层NAT设备之后，通常最上层的NAT是由网络提供商提供的，第二层NAT是家用的NAT路由器之类的设备提供的。\n\n\n> 典型P2P情景1：  两客户端位于同一NAT设备后面（即相同内网中）\n\n这是最简单的一种情况（如图4所示）：客户端A和B分别与集中服务器建立UDP连接，经过NAT转换后，A的公网端口被映射为62000，B的公网端口映射为62005。\n\n图4 - 位于同一个NAT设备后的UDP打洞过程：\n![image](http://www.52im.net/data/attachment/forum/201610/10/134836i9jb3hccbq8cz33q.png)\n\n当A向集中服务器发出消息请求与B进行连接，集中服务器将B的外网地址二元组以及内网地址二元组发给A，同时把A的外网以及内网的地址二元组信息发给B。A和B发往对方公网地址二元组信息的UDP数据包不一定会被对方收到，这取决于当前的NAT设备是否支持不同端口之间的UDP数据包能否到达（即Hairpin转换特性），无论如何A与B发往对方内网的地址二元组信息的UDP数据包是一定可以到达的，内网数据包不需要路由，且速度更快。A与B推荐采用内网的地址二元组信息进行常规的P2P通信。\n\n假定NAT设备支持Hairpin转换，P2P双方也应忽略与内网地址二元组的连接，如果A 和B采用外网的地址二元组做为P2P通信的连接，这势必会造成数据包无谓地经过NAT设备，这是一种对资源的浪费。就目前的网络情况而言，应用程序在“打洞”的时候，最好还是把外网和内网的地址二元组都尝试一下。如果都能成功，优先以内网地址进行连接。\n\n什么是Hairpin技术？\n> Hairpin技术又被称为Hairpin NAT、Loopback NAT或Hairpin Translation。Hairpin技术需要NAT网关支持，它能够让两台位于同一台NAT网关后面的主机，通过对方的公网地址和端口相互访问，NAT网关会根据一系列规则，将对内部主机发往其NAT公网IP地址的报文进行转换，并从私网接口发送给目标主机。目前有很多NAT设备不支持该技术，这种情况下，NAT网关在一些特定场合下将会阻断P2P穿越NAT的行为，打洞的尝试是无法成功的。好在现在已经有越来越多的NAT设备商开始加入到对该转换的支持中来。\n\n> 典型P2P情景2： \b两客户端位于不同的NAT设备后面（分属不同的内网）\n\n这是最普遍的一种情况（如图5所示）：客户端A与B经由各自的NAT设备与集中服务器建立UDP连接， A与B的本地端口号均为4321，集中服务器的公网端口号为1234。在向外的会话中， A的外网IP被映射为155.99.25.11，外网端口为62000；B的外网IP被映射为138.76.29.7，外网端口为31000。\n\n如下所示：\n```\n客户端A——>本地IP:10.0.0.1，本地端口:4321，外网IP:155.99.25.11，外网端口:62000\n客户端B——>本地IP:10.1.1.3，本地端口:4321，外网IP:138.76.29.7，外网端口:31000\n```\n\n图5 - 位于不同NAT设备后的UDP打洞过程：\n![image](http://www.52im.net/data/attachment/forum/201610/10/134846sq9njqoqa88c6lnk.png)\n\n在A向服务器发送的登陆消息中，包含有A的内网地址二元组信息，即10.0.0.1:4321；服务器会记录下A的内网地址二元组信息，同时会把自己观察到的A的外网地址二元组信息记录下来。同理，服务器也会记录下B的内网地址二元组信息和由服务器观察到的客户端B的外网地址二元组信息。无论A与B二者中的任何一方向服务器发送P2P连接请求，服务器都会将其记录下来的上述的外网和内网地址二元组发送给A或B。\n\nA和B分属不同的内网，它们的内网地址在外网中是没有路由的，所以发往各自内网地址的UDP数据包会发送到错误的主机或者根本不存在的主机上。当A的第一个消息发往B的外网地址（如图3所示），该消息途经A的NAT设备，并在该设备上生成一个会话表项，该会话的源地址二元组信息是{10.0.0.1:4321}，和A与服务器建立连接的时候NAT生成的源地址二元组信息一样，但它的目的地址是B的外网地址。在A的NAT设备支持保留A的内网地址二元组信息的情况下，所有来自A的源地址二元组信息为{10.0.0.1:4321}的数据包都沿用A与集中服务器事先建立起来的会话，这些数据包的外网地址二元组信息均被映射为{155.99.25.11:62000}。\n\nA向B的外网地址发送消息的过程就是“打洞”的过程，从A的内网的角度来看应为从{10.0.0.1:4321}发往{138.76.29.7:31000}，从A在其NAT设备上建立的会话来看，是从{155.99.25.11:62000}发到{138.76.29.7:31000}。如果A发给B的外网地址二元组的消息包在B向A发送消息包之前到达B的NAT设备，B的NAT设备会认为A发过来的消息是未经授权的外网消息，并丢弃该数据包。\n\nB发往A的消息包也会在B的NAT设备上建立一个{10.1.1.3:4321，155.99.25.11:62000}的会话（通常也会沿用B与集中服务器连接时建立的会话，只是该会话现在不仅接受由服务器发给B的消息，还可以接受从A的NAT设备{155.99.25.11:6200}发来的消息）。\n\n一旦A与B都向对方的NAT设备在外网上的地址二元组发送了数据包，就打开了A与B之间的“洞”，A与B向对方的外网地址发送数据，等效为向对方的客户端直接发送UDP数据包了。一旦应用程序确认已经可以通过往对方的外网地址发送数据包的方式让数据包到达NAT后面的目的应用程序，程序会自动停止继续发送用于“打洞”的数据包，转而开始真正的P2P数据传输。\n\n> 典型P2P情景3： 两客户端位于两层(或多层)NAT设备之后（分属不同的内网）\n\n此种情景最典型的部署情况就像这样：最上层的NAT设备通常是由网络提供商（ISP）提供，下层NAT设备是家用路由器。\n\n如图6所示：假定NAT C是由ISP提供的NAT设备，NAT C提供将多个用户节点映射到有限的几个公网IP的服务，NAT A和NAT B作为NAT C的内网节点将把用户的内部网络接入NAT C的内网，用户的内部网络就可以经由NAT C访问公网了。从这种拓扑结构上来看，只有服务器与NAT C是真正拥有公网可路由IP地址的设备，而NAT A和NAT B所使用的公网IP地址，实际上是由ISP服务提供商设定的（相对于NAT C而言）内网地址（我们将这种由ISP提供的内网地址称之为“伪”公网地址）。同理，隶属于NAT A与NAT B的客户端，它们处于NAT A，NAT B的内网，以此类推，客户端可以放到到多层NAT设备后面。客户端A和客户端B发起对服务器S的连接的时候，就会依次在NAT A和NAT B上建立向外的Session，而NAT A、NAT B要联入公网的时候，会在NAT C上再建立向外的Session。\n\n图6 - 多层NAT下的打洞过程：\n![image](http://www.52im.net/data/attachment/forum/201610/10/134855zdalvzak5dbyksvk.png)\n\n现在假定客户端A和B希望通过UDP“打洞”完成两个客户端的P2P直连。最优化的路由策略是客户端A向客户端B的“伪公网”IP上发送数据包，即ISP服务提供商指定的内网IP，NAT B的“伪”公网地址二元组，{10.0.1.2:55000}。由于从服务器的角度只能观察到真正的公网地址，也就是NAT A，NAT B在NAT C建立session的真正的公网地址{155.99.25.11:62000}以及{155.99.25.11:62005}，非常不幸的是客户端A与客户端B是无法通过服务器知道这些“伪”公网的地址，而且即使客户端A和B通过某种手段可以得到NAT A和NAT B的“伪”公网地址，我们仍然不建议采用上述的“最优化”的打洞方式，这是因为这些地址是由ISP服务提供商提供的或许会存在与客户端本身所在的内网地址重复的可能性（例如:NAT A的内网的IP地址域恰好与NAT A在NAT C的“伪”公网IP地址域重复，这样就会导致打洞数据包无法发出的问题）。\n\n因此客户端别无选择，只能使用由公网服务器观察到的A，B的公网地址二元组进行“打洞”操作，用于“打洞”的数据包将由NAT C进行转发。\n\n当客户端A向客户端B的公网地址二元组{155.99.25.11:62005}发送UDP数据包的时候，NAT A首先把数据包的源地址二元组由A的内网地址二元组{10.0.0.1:4321}转换为“伪”公网地址二元组{10.0.1.1:45000}，现在数据包到了NAT C，NAT C应该可以识别出来该数据包是要发往自身转换过的公网地址二元组，如果NAT C可以给出“合理”响应的话，NAT C将把该数据包的源地址二元组改为{155.99.25.11:62000}，目的地址二元组改为{10.0.1.2:55000}，即NAT B的“伪”公网地址二元组，NAT B最后会将收到的数据包发往客户端B。同样，由B发往A的数据包也会经过类似的过程。目前也有很多NAT设备不支持类似这样的“Hairpin转换”，但是已经有越来越多的NAT设备商开始加入对该转换的支持中来。\n\n> 一个需要考虑的现实问题：UDP在空闲状态下的超时\n\n当然，从应用的角度上来说，在完成打洞过程的同时，还有一些技术问题需要解决，如UDP在空闲状态下的超时问题。由于UDP转换协议提供的“洞”不是绝对可靠的，多数NAT设备内部都有一个UDP转换的空闲状态计时器，如果在一段时间内没有UDP数据通信，NAT设备会关掉由“打洞”过程打出来的“洞”。如果P2P应用程序希望“洞”的存活时间不受NAT网关的限制，就最好在穿越NAT以后设定一个穿越的有效期。\n\n对于有效期目前没有标准值，它与NAT设备内部的配置有关，某些设备上最短的只有20秒左右。在这个有效期内，即使没有P2P数据包需要传输，应用程序为了维持该“洞”可以正常工作，也必须向对方发送“打洞”心跳包。这个心跳包是需要双方应用程序都发送的，只有一方发送不会维持另一方的Session正常工作。除了频繁发送“打洞”心跳包以外，还有一个方法就是在当前的“洞”超时之前，P2P客户端双方重新“打洞”，丢弃原有的“洞”，这也不失为一个有效的方法。\n\n## 4、基于TCP协议的P2P打洞技术详细\n\n建立穿越NAT设备的P2P的TCP连接只比UDP复杂一点点，TCP协议的”“打洞”从协议层来看是与UDP的“打洞”过程非常相似的。尽管如此，基于TCP协议的打洞至今为止还没有被很好的理解，这也造成了的对其提供支持的NAT设备不是很多。在NAT设备支持的前提下，基于TCP的“打洞”技术实际上与基于UDP的“打洞”技术一样快捷、可靠。实际上，只要NAT设备支持的话，基于TCP的P2P技术的健壮性将比基于UDP技术的更强一些，因为TCP协议的状态机给出了一种标准的方法来精确的获取某个TCP session的生命期，而UDP协议则无法做到这一点。\n\n> 套接字和TCP端口的重用\n\n实现基于TCP协议的P2P打洞过程中，最主要的问题不是来自于TCP协议，而是来自于应用程序的API接口。这是由于标准的伯克利(Berkeley)套接字的API是围绕着构建客户端/服务器程序而设计的，API允许TCP流套接字通过调用connect()函数来建立向外的连接，或者通过listen()和accept函数接受来自外部的连接，但是，API不提供类似UDP那样的，同一个端口既可以向外连接，又能够接受来自外部的连接。而且更糟的是，TCP的套接字通常仅允许建立1对1的响应，即应用程序在将一个套接字绑定到本地的一个端口以后，任何试图将第二个套接字绑定到该端口的操作都会失败。\n\n为了让TCP“打洞”能够顺利工作，我们需要使用一个本地的TCP端口来监听来自外部的TCP连接，同时建立多个向外的TCP连接。幸运的是，所有的主流操作系统都能够支持特殊的TCP套接字参数，通常叫做“SO_REUSEADDR”，该参数允许应用程序将多个套接字绑定到本地的一个地址二元组（只要所有要绑定的套接字都设置了SO_REUSEADDR参数即可）。BSD系统引入了SO_REUSEPORT参数，该参数用于区分端口重用还是地址重用，在这样的系统里面，上述所有的参数必须都设置才行。\n\n> 打开P2P的TCP流\n\n假定客户端A希望建立与B的TCP连接。我们像通常一样假定A和B已经与公网上的已知服务器建立了TCP连接。服务器记录下来每个接入的客户端的公网和内网的地址二元组，如同为UDP服务的时候一样。\n\n从协议层来看，TCP“打洞”与UDP“打洞”是几乎完全相同的过程：\n\n- 客户端A使用其与服务器的连接向服务器发送请求，要求服务器协助其连接客户端B；\n- 服务器将B的公网和内网的TCP地址的二元组信息返回给A，同时，服务器将A的公网和内网的地址二元组也发送给B；\n- 客户端A和B使用连接服务器的端口异步地发起向对方的公网、内网地址二元组的TCP连接，同时监听各自的本地TCP端口是否有外部的连接联入；\n- A和B开始等待向外的连接是否成功，检查是否有新连接联入。如果向外的连接由于某种网络错误而失败，如：“连接被重置”或者“节点无法访问”，客户端只需要延迟一小段时间（例如延迟一秒钟），然后重新发起连接即可，延迟的时间和重复连接的次数可以由应用程序编写者来确定；\n- TCP连接建立起来以后，客户端之间应该开始鉴权操作，确保目前联入的连接就是所希望的连接。如果鉴权失败，客户端将关闭连接，并且继续等待新的连接联入。客户端通常采用“先入为主”的策略，只接受第一个通过鉴权操作的客户端，然后将进入P2P通信过程不再继续等待是否有新的连接联入。\n\n图7 - TCP打洞：\n![image](http://www.52im.net/data/attachment/forum/201610/10/134112o7g7ojub3wj3ju3u.png)\n\n与UDP不同的是，因为使用UDP协议的每个客户端只需要一个套接字即可完成与服务器的通信，而TCP客户端必须处理多个套接字绑定到同一个本地TCP端口的问题，如图7所示。现在来看实际中常见的一种情景，A与B分别位于不同的NAT设备后面，如图5所示，并且假定图中的端口号是TCP协议的端口号，而不是UDP的端口号。图中向外的连接代表A和B向对方的内网地址二元组发起的连接，这些连接或许会失败或者无法连接到对方。如同使用UDP协议进行“打洞”操作遇到的问题一样，TCP的“打洞”操作也会遇到内网的IP与“伪”公网IP重复造成连接失败或者错误连接之类的问题。\n\n客户端向彼此公网地址二元组发起连接的操作，会使得各自的NAT设备打开新的“洞”允许A与B的TCP数据通过。如果NAT设备支持TCP“打洞”操作的话，一个在客户端之间的基于TCP协议的流通道就会自动建立起来。如果A向B发送的第一个SYN包发到了B的NAT设备，而B在此前没有向A发送SYN包，B的NAT设备会丢弃这个包，这会引起A的“连接失败”或“无法连接”问题。而此时，由于A已经向B发送过SYN包，B发往A的SYN包将被看作是由A发往B的包的回应的一部分，所以B发往A的SYN包会顺利地通过A的NAT设备，到达A，从而建立起A与B的P2P连接。\n\n> 从应用程序的角度来看TCP“打洞”\n\n从应用程序的角度来看，在进行TCP“打洞”的时候都发生了什么呢？假定A首先向B发出SYN包，该包发往B的公网地址二元组，并且被B的NAT设备丢弃，但是B发往A的公网地址二元组的SYN包则通过A的NAT到达了A，然后，会发生以下的两种结果中的一种，具体是哪一种取决于操作系统对TCP协议的实现：\n\n（1）A的TCP实现会发现收到的SYN包就是其发起连接并希望联入的B的SYN包，通俗一点来说就是“说曹操，曹操到”的意思，本来A要去找B，结果B自己找上门来了。A的TCP协议栈因此会把B作为A向B发起连接connect的一部分，并认为连接已经成功。程序A调用的异步connect()函数将成功返回，A的listen()等待从外部联入的函数将没有任何反映。此时，B联入A的操作在A程序的内部被理解为A联入B连接成功，并且A开始使用这个连接与B开始P2P通信。\n\n由于收到的SYN包中不包含A需要的ACK数据，因此，A的TCP将用SYN-ACK包回应B的公网地址二元组，并且将使用先前A发向B的SYN包一样的序列号。一旦B的TCP收到由A发来的SYN-ACK包，则把自己的ACK包发给A，然后两端建立起TCP连接。简单的说，第一种，就是即使A发往B的SYN包被B的NAT丢弃了，但是由于B发往A的包到达了A。结果是，A认为自己连接成功了，B也认为自己连接成功了，不管是谁成功了，总之连接是已经建立起来了。\n\n（2）另外一种结果是，A的TCP实现没有像（1）中所讲的那么“智能”，它没有发现现在联入的B就是自己希望联入的。就好比在机场接人，明明遇到了自己想要接的人却不认识，误认为是其他的人，安排别人给接走了，后来才知道是自己错过了机会，但是无论如何，人已经接到了任务已经完成了。然后，A通过常规的listen()函数和accept()函数得到与B的连接，而由A发起的向B的公网地址二元组的连接会以失败告终。尽管A向B的连接失败，A仍然得到了B发起的向A的连接，等效于A与B之间已经联通，不管中间过程如何，A与B已经连接起来了，结果是A和B的基于TCP协议的P2P连接已经建立起来了。\n\n第一种结果适用于基于BSD的操作系统对于TCP的实现，而第二种结果更加普遍一些，多数Linux和Windows系统都会按照第二种结果来处理。\n\n## 5、本文小结\n\n在IP地址极度短缺的今天，NAT几乎已经是无所不在的一项技术了，以至于现在任何一项新技术都不得不考虑和NAT的兼容。作为当下应用最广泛的技术之一，P2P技术也必然要面对NAT这个障碍。\n\n打洞技术看起来是一项近似乎蛮干的技术，却不失为一种有效的技术手段。在集中服务器的帮助下，P2P的双方利用端口预测的技术在NAT网关上打出通道，从而实现NAT穿越，解决了NAT对于P2P的阻隔，为P2P技术在网络中更广泛的推广作出了非常大的贡献。\n","source":"_posts/p2p2.md","raw":"---\ntitle: P2P技术详解(二)：P2P中的NAT穿越(打洞)方案详解\ndate: 2018-09-06 17:28:03\ntags: p2p\n---\n\n## 1、内容概述\n\nP2P即点对点通信，或称为对等联网，与传统的服务器客户端模式（如下图“P2P结构模型”所示）有着明显的区别，在即时通讯方案中应用广泛（比如IM应用中的实时音视频通信、实时文件传输甚至文字聊天等）。\n\nP2P可以是一种通信模式、一种逻辑网络模型、一种技术、甚至一种理念。在P2P网络中（如右图所示），所有通信节点的地位都是对等的，每个节点都扮演着客户机和服务器双重角色，节点之间通过直接通信实现文件信息、处理器运算能力、存储空间等资源的共享。P2P网络具有分散性、可扩展性、健壮性等特点，这使得P2P技术在信息共享、\b即时通讯、协同工作、分布式计算、网络存储等领域都有广阔的应用。\n\n图1 - 经典的CS模式：\n![image](http://www.52im.net/data/attachment/forum/201610/10/132736s7tqmprzhrz7wzds.jpg)\n\n图2 - P2P结构模型：\n![image](http://www.52im.net/data/attachment/forum/201610/10/132735dgcypehy72gbrv4d.jpg)\n\nNAT技术和P2P技术作为经典的两项网络技术，在现在的网络上有着广泛的应用，P2P主机位于NAT网关后面的情况屡见不鲜。NAT技术虽然在一定程度上解决了IPv4地址短缺的问题，在构建防火墙、保证网络安全方面都发挥了一定的作用，却破坏了端到端的网络通信。NAT阻碍主机进行P2P通信的主要原因是NAT不允许外网主机主动访问内网主机，但是P2P技术却要求通信双方都能主动发起访问，所以要在NAT网络环境中进行有效的P2P通信，就必须采用新的解决方案。\n\nP2P作为一项实用的技术，有很大的优化空间，并且相对于网络设备，基于P2P的应用程序在实现上更为灵活。所以为了兼容NAT，基于P2P的应用程序在开发的时候大多会根据自身特点加入一些穿越NAT的功能以解决上述问题。以下着重介绍几种常见的P2P穿越NAT方案。\n\n<!-- more -->\n\n## 2、反向链接技术：一种特殊的P2P场景（通信双方中只有一方位于NAT设备之后）\n\n此种情况是所有P2P场景中最简单的，它使用一种被称为“反向链接技术”来解决这个问题。大致的原理如下所述。\n\n如图3所示，客户端A位于NAT之后，它通过TCP端口1234连接到服务器的TCP端口1235上，NAT设备为这个连接重新分配了TCP端口62000。客户端B也通过TCP端口1234连接到服务器端口1235上。A和B从服务器处获知的对方的外网地址二元组{IP地址:端口号}分别为{138.76.29.7:1234}和{155.99.25.11:62000}，它们在各自的本地端口上进行侦听。\n\n由于B 拥有外网IP地址，所以A要发起与B的通信，可以直接通过TCP连接到B。但如果B尝试通过TCP连接到A进行P2P通信，则会失败，原因是A位于NAT设备后，虽然B发出的TCP SYN请求能够到达NAT设备的端口62000，但NAT设备会拒绝这个连接请求。要想与Client A通信， B不是直接向A发起连接，而是通过服务器给A转发一个连接请求，反过来请求A连接到B（即进行反向链接），A在收到从服务器转发过来的请求以后，会主动向B发起一个TCP的连接请求，这样在NAT设备上就会建立起关于这个连接的相关表项，使A和B之间能够正常通信，从而建立起它们之间的TCP连接。\n\n图3 - 反向链接示意图：\n![image](http://www.52im.net/data/attachment/forum/201610/10/133042i8nux66pj1jbul6p.jpg)\n\n## 3、基于UDP协议的P2P打洞技术详解\n\n> 原理概述\n\nUDP打洞技术是通过中间服务器的协助在各自的NAT网关上建立相关的表项，使P2P连接的双方发送的报文能够直接穿透对方的NAT网关，从而实现P2P客户端互连。如果两台位于NAT设备后面的P2P客户端希望在自己的NAT网关上打个洞，那么他们需要一个协助者——集中服务器，并且还需要一种用于打洞的Session建立机制。\n\n什么是集中服务器？\n\n集中服务器本质上是一台被设置在公网上的服务器，建立P2P的双方都可以直接访问到这台服务器。位于NAT网关后面的客户端A和B都可以与一台已知的集中服务器建立连接，并通过这台集中服务器了解对方的信息并中转各自的信息。\n\n同时集中服务器的另一个重要作用在于判断某个客户端是否在NAT网关之后。具体的方法是：一个客户端在集中服务器上登陆的时候，服务器记录下该客户端的两对地址二元组信息{IP地址:UDP端口}，一对是该客户端与集中服务器进行通信的自身的IP地址和端口号，另一对是集中服务器记录下的由服务器“观察”到的该客户端实际与自己通信所使用的IP地址和端口号。我们可以把前一对地址二元组看作是客户端的内网IP地址和端口号，把后一对地址二元组看作是客户端的内网IP地址和端口号经过NAT转换后的外网IP地址和端口号。集中服务器可以从客户端的登陆消息中得到该客户端的内网相关信息，还可以通过登陆消息的IP头和UDP头得到该客户端的外网相关信息。如果该客户端不是位于NAT设备后面，那么采用上述方法得到的两对地址二元组信息是完全相同的。\n\nP2P的Session建立原理：\n\n假定客户端A要发起对客户端B的直接连接，具体的“打洞”过程如下：\n1. A最初不知道如何向客户端B发起连接，于是A向集中服务器发送消息，请求集中服务器帮助建立与客户端B的UDP连接。\n2. 集中服务器将含有B的外网和内网的地址二元组发给A，同时，集中服务器将包含有A的外网和内网的地址二元组信息的消息也发给B。这样一来， A与B就都知道对方外网和内网的地址二元组信息了。\n3. 当A收到由集中服务器发来的包含B的外网和内网的地址二元组信息后， A开始向B的地址二元组发送UDP数据包，并且A会自动锁定第一个给出响应的B的地址二元组。同理，当B收到由集中服务器发来的A的外网和内网地址二元组信息后，也会开始向A的外网和内网的地址二元组发送UDP数据包，并且自动锁定第一个得到A回应的地址二元组。由于A与B互相向对方发送UDP数据包的操作是异步的，所以A和B发送数据包的时间先后并没有时序要求。\n\n下面来看下这三者之间是如何进行UDP打洞的。在这我们分三种具体情景来讨论：\n\n- 第一种是最简单的一种情景，两个客户端都位于同一个NAT设备后面，即位于同一内网中；\n- 第二种是最普遍的一种情景，两个客户端分别位于不同的NAT设备后面，分属不同的内网；\n- 第三种是客户端位于两层NAT设备之后，通常最上层的NAT是由网络提供商提供的，第二层NAT是家用的NAT路由器之类的设备提供的。\n\n\n> 典型P2P情景1：  两客户端位于同一NAT设备后面（即相同内网中）\n\n这是最简单的一种情况（如图4所示）：客户端A和B分别与集中服务器建立UDP连接，经过NAT转换后，A的公网端口被映射为62000，B的公网端口映射为62005。\n\n图4 - 位于同一个NAT设备后的UDP打洞过程：\n![image](http://www.52im.net/data/attachment/forum/201610/10/134836i9jb3hccbq8cz33q.png)\n\n当A向集中服务器发出消息请求与B进行连接，集中服务器将B的外网地址二元组以及内网地址二元组发给A，同时把A的外网以及内网的地址二元组信息发给B。A和B发往对方公网地址二元组信息的UDP数据包不一定会被对方收到，这取决于当前的NAT设备是否支持不同端口之间的UDP数据包能否到达（即Hairpin转换特性），无论如何A与B发往对方内网的地址二元组信息的UDP数据包是一定可以到达的，内网数据包不需要路由，且速度更快。A与B推荐采用内网的地址二元组信息进行常规的P2P通信。\n\n假定NAT设备支持Hairpin转换，P2P双方也应忽略与内网地址二元组的连接，如果A 和B采用外网的地址二元组做为P2P通信的连接，这势必会造成数据包无谓地经过NAT设备，这是一种对资源的浪费。就目前的网络情况而言，应用程序在“打洞”的时候，最好还是把外网和内网的地址二元组都尝试一下。如果都能成功，优先以内网地址进行连接。\n\n什么是Hairpin技术？\n> Hairpin技术又被称为Hairpin NAT、Loopback NAT或Hairpin Translation。Hairpin技术需要NAT网关支持，它能够让两台位于同一台NAT网关后面的主机，通过对方的公网地址和端口相互访问，NAT网关会根据一系列规则，将对内部主机发往其NAT公网IP地址的报文进行转换，并从私网接口发送给目标主机。目前有很多NAT设备不支持该技术，这种情况下，NAT网关在一些特定场合下将会阻断P2P穿越NAT的行为，打洞的尝试是无法成功的。好在现在已经有越来越多的NAT设备商开始加入到对该转换的支持中来。\n\n> 典型P2P情景2： \b两客户端位于不同的NAT设备后面（分属不同的内网）\n\n这是最普遍的一种情况（如图5所示）：客户端A与B经由各自的NAT设备与集中服务器建立UDP连接， A与B的本地端口号均为4321，集中服务器的公网端口号为1234。在向外的会话中， A的外网IP被映射为155.99.25.11，外网端口为62000；B的外网IP被映射为138.76.29.7，外网端口为31000。\n\n如下所示：\n```\n客户端A——>本地IP:10.0.0.1，本地端口:4321，外网IP:155.99.25.11，外网端口:62000\n客户端B——>本地IP:10.1.1.3，本地端口:4321，外网IP:138.76.29.7，外网端口:31000\n```\n\n图5 - 位于不同NAT设备后的UDP打洞过程：\n![image](http://www.52im.net/data/attachment/forum/201610/10/134846sq9njqoqa88c6lnk.png)\n\n在A向服务器发送的登陆消息中，包含有A的内网地址二元组信息，即10.0.0.1:4321；服务器会记录下A的内网地址二元组信息，同时会把自己观察到的A的外网地址二元组信息记录下来。同理，服务器也会记录下B的内网地址二元组信息和由服务器观察到的客户端B的外网地址二元组信息。无论A与B二者中的任何一方向服务器发送P2P连接请求，服务器都会将其记录下来的上述的外网和内网地址二元组发送给A或B。\n\nA和B分属不同的内网，它们的内网地址在外网中是没有路由的，所以发往各自内网地址的UDP数据包会发送到错误的主机或者根本不存在的主机上。当A的第一个消息发往B的外网地址（如图3所示），该消息途经A的NAT设备，并在该设备上生成一个会话表项，该会话的源地址二元组信息是{10.0.0.1:4321}，和A与服务器建立连接的时候NAT生成的源地址二元组信息一样，但它的目的地址是B的外网地址。在A的NAT设备支持保留A的内网地址二元组信息的情况下，所有来自A的源地址二元组信息为{10.0.0.1:4321}的数据包都沿用A与集中服务器事先建立起来的会话，这些数据包的外网地址二元组信息均被映射为{155.99.25.11:62000}。\n\nA向B的外网地址发送消息的过程就是“打洞”的过程，从A的内网的角度来看应为从{10.0.0.1:4321}发往{138.76.29.7:31000}，从A在其NAT设备上建立的会话来看，是从{155.99.25.11:62000}发到{138.76.29.7:31000}。如果A发给B的外网地址二元组的消息包在B向A发送消息包之前到达B的NAT设备，B的NAT设备会认为A发过来的消息是未经授权的外网消息，并丢弃该数据包。\n\nB发往A的消息包也会在B的NAT设备上建立一个{10.1.1.3:4321，155.99.25.11:62000}的会话（通常也会沿用B与集中服务器连接时建立的会话，只是该会话现在不仅接受由服务器发给B的消息，还可以接受从A的NAT设备{155.99.25.11:6200}发来的消息）。\n\n一旦A与B都向对方的NAT设备在外网上的地址二元组发送了数据包，就打开了A与B之间的“洞”，A与B向对方的外网地址发送数据，等效为向对方的客户端直接发送UDP数据包了。一旦应用程序确认已经可以通过往对方的外网地址发送数据包的方式让数据包到达NAT后面的目的应用程序，程序会自动停止继续发送用于“打洞”的数据包，转而开始真正的P2P数据传输。\n\n> 典型P2P情景3： 两客户端位于两层(或多层)NAT设备之后（分属不同的内网）\n\n此种情景最典型的部署情况就像这样：最上层的NAT设备通常是由网络提供商（ISP）提供，下层NAT设备是家用路由器。\n\n如图6所示：假定NAT C是由ISP提供的NAT设备，NAT C提供将多个用户节点映射到有限的几个公网IP的服务，NAT A和NAT B作为NAT C的内网节点将把用户的内部网络接入NAT C的内网，用户的内部网络就可以经由NAT C访问公网了。从这种拓扑结构上来看，只有服务器与NAT C是真正拥有公网可路由IP地址的设备，而NAT A和NAT B所使用的公网IP地址，实际上是由ISP服务提供商设定的（相对于NAT C而言）内网地址（我们将这种由ISP提供的内网地址称之为“伪”公网地址）。同理，隶属于NAT A与NAT B的客户端，它们处于NAT A，NAT B的内网，以此类推，客户端可以放到到多层NAT设备后面。客户端A和客户端B发起对服务器S的连接的时候，就会依次在NAT A和NAT B上建立向外的Session，而NAT A、NAT B要联入公网的时候，会在NAT C上再建立向外的Session。\n\n图6 - 多层NAT下的打洞过程：\n![image](http://www.52im.net/data/attachment/forum/201610/10/134855zdalvzak5dbyksvk.png)\n\n现在假定客户端A和B希望通过UDP“打洞”完成两个客户端的P2P直连。最优化的路由策略是客户端A向客户端B的“伪公网”IP上发送数据包，即ISP服务提供商指定的内网IP，NAT B的“伪”公网地址二元组，{10.0.1.2:55000}。由于从服务器的角度只能观察到真正的公网地址，也就是NAT A，NAT B在NAT C建立session的真正的公网地址{155.99.25.11:62000}以及{155.99.25.11:62005}，非常不幸的是客户端A与客户端B是无法通过服务器知道这些“伪”公网的地址，而且即使客户端A和B通过某种手段可以得到NAT A和NAT B的“伪”公网地址，我们仍然不建议采用上述的“最优化”的打洞方式，这是因为这些地址是由ISP服务提供商提供的或许会存在与客户端本身所在的内网地址重复的可能性（例如:NAT A的内网的IP地址域恰好与NAT A在NAT C的“伪”公网IP地址域重复，这样就会导致打洞数据包无法发出的问题）。\n\n因此客户端别无选择，只能使用由公网服务器观察到的A，B的公网地址二元组进行“打洞”操作，用于“打洞”的数据包将由NAT C进行转发。\n\n当客户端A向客户端B的公网地址二元组{155.99.25.11:62005}发送UDP数据包的时候，NAT A首先把数据包的源地址二元组由A的内网地址二元组{10.0.0.1:4321}转换为“伪”公网地址二元组{10.0.1.1:45000}，现在数据包到了NAT C，NAT C应该可以识别出来该数据包是要发往自身转换过的公网地址二元组，如果NAT C可以给出“合理”响应的话，NAT C将把该数据包的源地址二元组改为{155.99.25.11:62000}，目的地址二元组改为{10.0.1.2:55000}，即NAT B的“伪”公网地址二元组，NAT B最后会将收到的数据包发往客户端B。同样，由B发往A的数据包也会经过类似的过程。目前也有很多NAT设备不支持类似这样的“Hairpin转换”，但是已经有越来越多的NAT设备商开始加入对该转换的支持中来。\n\n> 一个需要考虑的现实问题：UDP在空闲状态下的超时\n\n当然，从应用的角度上来说，在完成打洞过程的同时，还有一些技术问题需要解决，如UDP在空闲状态下的超时问题。由于UDP转换协议提供的“洞”不是绝对可靠的，多数NAT设备内部都有一个UDP转换的空闲状态计时器，如果在一段时间内没有UDP数据通信，NAT设备会关掉由“打洞”过程打出来的“洞”。如果P2P应用程序希望“洞”的存活时间不受NAT网关的限制，就最好在穿越NAT以后设定一个穿越的有效期。\n\n对于有效期目前没有标准值，它与NAT设备内部的配置有关，某些设备上最短的只有20秒左右。在这个有效期内，即使没有P2P数据包需要传输，应用程序为了维持该“洞”可以正常工作，也必须向对方发送“打洞”心跳包。这个心跳包是需要双方应用程序都发送的，只有一方发送不会维持另一方的Session正常工作。除了频繁发送“打洞”心跳包以外，还有一个方法就是在当前的“洞”超时之前，P2P客户端双方重新“打洞”，丢弃原有的“洞”，这也不失为一个有效的方法。\n\n## 4、基于TCP协议的P2P打洞技术详细\n\n建立穿越NAT设备的P2P的TCP连接只比UDP复杂一点点，TCP协议的”“打洞”从协议层来看是与UDP的“打洞”过程非常相似的。尽管如此，基于TCP协议的打洞至今为止还没有被很好的理解，这也造成了的对其提供支持的NAT设备不是很多。在NAT设备支持的前提下，基于TCP的“打洞”技术实际上与基于UDP的“打洞”技术一样快捷、可靠。实际上，只要NAT设备支持的话，基于TCP的P2P技术的健壮性将比基于UDP技术的更强一些，因为TCP协议的状态机给出了一种标准的方法来精确的获取某个TCP session的生命期，而UDP协议则无法做到这一点。\n\n> 套接字和TCP端口的重用\n\n实现基于TCP协议的P2P打洞过程中，最主要的问题不是来自于TCP协议，而是来自于应用程序的API接口。这是由于标准的伯克利(Berkeley)套接字的API是围绕着构建客户端/服务器程序而设计的，API允许TCP流套接字通过调用connect()函数来建立向外的连接，或者通过listen()和accept函数接受来自外部的连接，但是，API不提供类似UDP那样的，同一个端口既可以向外连接，又能够接受来自外部的连接。而且更糟的是，TCP的套接字通常仅允许建立1对1的响应，即应用程序在将一个套接字绑定到本地的一个端口以后，任何试图将第二个套接字绑定到该端口的操作都会失败。\n\n为了让TCP“打洞”能够顺利工作，我们需要使用一个本地的TCP端口来监听来自外部的TCP连接，同时建立多个向外的TCP连接。幸运的是，所有的主流操作系统都能够支持特殊的TCP套接字参数，通常叫做“SO_REUSEADDR”，该参数允许应用程序将多个套接字绑定到本地的一个地址二元组（只要所有要绑定的套接字都设置了SO_REUSEADDR参数即可）。BSD系统引入了SO_REUSEPORT参数，该参数用于区分端口重用还是地址重用，在这样的系统里面，上述所有的参数必须都设置才行。\n\n> 打开P2P的TCP流\n\n假定客户端A希望建立与B的TCP连接。我们像通常一样假定A和B已经与公网上的已知服务器建立了TCP连接。服务器记录下来每个接入的客户端的公网和内网的地址二元组，如同为UDP服务的时候一样。\n\n从协议层来看，TCP“打洞”与UDP“打洞”是几乎完全相同的过程：\n\n- 客户端A使用其与服务器的连接向服务器发送请求，要求服务器协助其连接客户端B；\n- 服务器将B的公网和内网的TCP地址的二元组信息返回给A，同时，服务器将A的公网和内网的地址二元组也发送给B；\n- 客户端A和B使用连接服务器的端口异步地发起向对方的公网、内网地址二元组的TCP连接，同时监听各自的本地TCP端口是否有外部的连接联入；\n- A和B开始等待向外的连接是否成功，检查是否有新连接联入。如果向外的连接由于某种网络错误而失败，如：“连接被重置”或者“节点无法访问”，客户端只需要延迟一小段时间（例如延迟一秒钟），然后重新发起连接即可，延迟的时间和重复连接的次数可以由应用程序编写者来确定；\n- TCP连接建立起来以后，客户端之间应该开始鉴权操作，确保目前联入的连接就是所希望的连接。如果鉴权失败，客户端将关闭连接，并且继续等待新的连接联入。客户端通常采用“先入为主”的策略，只接受第一个通过鉴权操作的客户端，然后将进入P2P通信过程不再继续等待是否有新的连接联入。\n\n图7 - TCP打洞：\n![image](http://www.52im.net/data/attachment/forum/201610/10/134112o7g7ojub3wj3ju3u.png)\n\n与UDP不同的是，因为使用UDP协议的每个客户端只需要一个套接字即可完成与服务器的通信，而TCP客户端必须处理多个套接字绑定到同一个本地TCP端口的问题，如图7所示。现在来看实际中常见的一种情景，A与B分别位于不同的NAT设备后面，如图5所示，并且假定图中的端口号是TCP协议的端口号，而不是UDP的端口号。图中向外的连接代表A和B向对方的内网地址二元组发起的连接，这些连接或许会失败或者无法连接到对方。如同使用UDP协议进行“打洞”操作遇到的问题一样，TCP的“打洞”操作也会遇到内网的IP与“伪”公网IP重复造成连接失败或者错误连接之类的问题。\n\n客户端向彼此公网地址二元组发起连接的操作，会使得各自的NAT设备打开新的“洞”允许A与B的TCP数据通过。如果NAT设备支持TCP“打洞”操作的话，一个在客户端之间的基于TCP协议的流通道就会自动建立起来。如果A向B发送的第一个SYN包发到了B的NAT设备，而B在此前没有向A发送SYN包，B的NAT设备会丢弃这个包，这会引起A的“连接失败”或“无法连接”问题。而此时，由于A已经向B发送过SYN包，B发往A的SYN包将被看作是由A发往B的包的回应的一部分，所以B发往A的SYN包会顺利地通过A的NAT设备，到达A，从而建立起A与B的P2P连接。\n\n> 从应用程序的角度来看TCP“打洞”\n\n从应用程序的角度来看，在进行TCP“打洞”的时候都发生了什么呢？假定A首先向B发出SYN包，该包发往B的公网地址二元组，并且被B的NAT设备丢弃，但是B发往A的公网地址二元组的SYN包则通过A的NAT到达了A，然后，会发生以下的两种结果中的一种，具体是哪一种取决于操作系统对TCP协议的实现：\n\n（1）A的TCP实现会发现收到的SYN包就是其发起连接并希望联入的B的SYN包，通俗一点来说就是“说曹操，曹操到”的意思，本来A要去找B，结果B自己找上门来了。A的TCP协议栈因此会把B作为A向B发起连接connect的一部分，并认为连接已经成功。程序A调用的异步connect()函数将成功返回，A的listen()等待从外部联入的函数将没有任何反映。此时，B联入A的操作在A程序的内部被理解为A联入B连接成功，并且A开始使用这个连接与B开始P2P通信。\n\n由于收到的SYN包中不包含A需要的ACK数据，因此，A的TCP将用SYN-ACK包回应B的公网地址二元组，并且将使用先前A发向B的SYN包一样的序列号。一旦B的TCP收到由A发来的SYN-ACK包，则把自己的ACK包发给A，然后两端建立起TCP连接。简单的说，第一种，就是即使A发往B的SYN包被B的NAT丢弃了，但是由于B发往A的包到达了A。结果是，A认为自己连接成功了，B也认为自己连接成功了，不管是谁成功了，总之连接是已经建立起来了。\n\n（2）另外一种结果是，A的TCP实现没有像（1）中所讲的那么“智能”，它没有发现现在联入的B就是自己希望联入的。就好比在机场接人，明明遇到了自己想要接的人却不认识，误认为是其他的人，安排别人给接走了，后来才知道是自己错过了机会，但是无论如何，人已经接到了任务已经完成了。然后，A通过常规的listen()函数和accept()函数得到与B的连接，而由A发起的向B的公网地址二元组的连接会以失败告终。尽管A向B的连接失败，A仍然得到了B发起的向A的连接，等效于A与B之间已经联通，不管中间过程如何，A与B已经连接起来了，结果是A和B的基于TCP协议的P2P连接已经建立起来了。\n\n第一种结果适用于基于BSD的操作系统对于TCP的实现，而第二种结果更加普遍一些，多数Linux和Windows系统都会按照第二种结果来处理。\n\n## 5、本文小结\n\n在IP地址极度短缺的今天，NAT几乎已经是无所不在的一项技术了，以至于现在任何一项新技术都不得不考虑和NAT的兼容。作为当下应用最广泛的技术之一，P2P技术也必然要面对NAT这个障碍。\n\n打洞技术看起来是一项近似乎蛮干的技术，却不失为一种有效的技术手段。在集中服务器的帮助下，P2P的双方利用端口预测的技术在NAT网关上打出通道，从而实现NAT穿越，解决了NAT对于P2P的阻隔，为P2P技术在网络中更广泛的推广作出了非常大的贡献。\n","slug":"p2p2","published":1,"updated":"2018-09-06T09:29:45.604Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlqdfcwg0004owv3l8oavpdj","content":"<h2 id=\"1、内容概述\"><a href=\"#1、内容概述\" class=\"headerlink\" title=\"1、内容概述\"></a>1、内容概述</h2><p>P2P即点对点通信，或称为对等联网，与传统的服务器客户端模式（如下图“P2P结构模型”所示）有着明显的区别，在即时通讯方案中应用广泛（比如IM应用中的实时音视频通信、实时文件传输甚至文字聊天等）。</p>\n<p>P2P可以是一种通信模式、一种逻辑网络模型、一种技术、甚至一种理念。在P2P网络中（如右图所示），所有通信节点的地位都是对等的，每个节点都扮演着客户机和服务器双重角色，节点之间通过直接通信实现文件信息、处理器运算能力、存储空间等资源的共享。P2P网络具有分散性、可扩展性、健壮性等特点，这使得P2P技术在信息共享、\b即时通讯、协同工作、分布式计算、网络存储等领域都有广阔的应用。</p>\n<p>图1 - 经典的CS模式：<br><img src=\"http://www.52im.net/data/attachment/forum/201610/10/132736s7tqmprzhrz7wzds.jpg\" alt=\"image\"></p>\n<p>图2 - P2P结构模型：<br><img src=\"http://www.52im.net/data/attachment/forum/201610/10/132735dgcypehy72gbrv4d.jpg\" alt=\"image\"></p>\n<p>NAT技术和P2P技术作为经典的两项网络技术，在现在的网络上有着广泛的应用，P2P主机位于NAT网关后面的情况屡见不鲜。NAT技术虽然在一定程度上解决了IPv4地址短缺的问题，在构建防火墙、保证网络安全方面都发挥了一定的作用，却破坏了端到端的网络通信。NAT阻碍主机进行P2P通信的主要原因是NAT不允许外网主机主动访问内网主机，但是P2P技术却要求通信双方都能主动发起访问，所以要在NAT网络环境中进行有效的P2P通信，就必须采用新的解决方案。</p>\n<p>P2P作为一项实用的技术，有很大的优化空间，并且相对于网络设备，基于P2P的应用程序在实现上更为灵活。所以为了兼容NAT，基于P2P的应用程序在开发的时候大多会根据自身特点加入一些穿越NAT的功能以解决上述问题。以下着重介绍几种常见的P2P穿越NAT方案。</p>\n<a id=\"more\"></a>\n<h2 id=\"2、反向链接技术：一种特殊的P2P场景（通信双方中只有一方位于NAT设备之后）\"><a href=\"#2、反向链接技术：一种特殊的P2P场景（通信双方中只有一方位于NAT设备之后）\" class=\"headerlink\" title=\"2、反向链接技术：一种特殊的P2P场景（通信双方中只有一方位于NAT设备之后）\"></a>2、反向链接技术：一种特殊的P2P场景（通信双方中只有一方位于NAT设备之后）</h2><p>此种情况是所有P2P场景中最简单的，它使用一种被称为“反向链接技术”来解决这个问题。大致的原理如下所述。</p>\n<p>如图3所示，客户端A位于NAT之后，它通过TCP端口1234连接到服务器的TCP端口1235上，NAT设备为这个连接重新分配了TCP端口62000。客户端B也通过TCP端口1234连接到服务器端口1235上。A和B从服务器处获知的对方的外网地址二元组{IP地址:端口号}分别为{138.76.29.7:1234}和{155.99.25.11:62000}，它们在各自的本地端口上进行侦听。</p>\n<p>由于B 拥有外网IP地址，所以A要发起与B的通信，可以直接通过TCP连接到B。但如果B尝试通过TCP连接到A进行P2P通信，则会失败，原因是A位于NAT设备后，虽然B发出的TCP SYN请求能够到达NAT设备的端口62000，但NAT设备会拒绝这个连接请求。要想与Client A通信， B不是直接向A发起连接，而是通过服务器给A转发一个连接请求，反过来请求A连接到B（即进行反向链接），A在收到从服务器转发过来的请求以后，会主动向B发起一个TCP的连接请求，这样在NAT设备上就会建立起关于这个连接的相关表项，使A和B之间能够正常通信，从而建立起它们之间的TCP连接。</p>\n<p>图3 - 反向链接示意图：<br><img src=\"http://www.52im.net/data/attachment/forum/201610/10/133042i8nux66pj1jbul6p.jpg\" alt=\"image\"></p>\n<h2 id=\"3、基于UDP协议的P2P打洞技术详解\"><a href=\"#3、基于UDP协议的P2P打洞技术详解\" class=\"headerlink\" title=\"3、基于UDP协议的P2P打洞技术详解\"></a>3、基于UDP协议的P2P打洞技术详解</h2><blockquote>\n<p>原理概述</p>\n</blockquote>\n<p>UDP打洞技术是通过中间服务器的协助在各自的NAT网关上建立相关的表项，使P2P连接的双方发送的报文能够直接穿透对方的NAT网关，从而实现P2P客户端互连。如果两台位于NAT设备后面的P2P客户端希望在自己的NAT网关上打个洞，那么他们需要一个协助者——集中服务器，并且还需要一种用于打洞的Session建立机制。</p>\n<p>什么是集中服务器？</p>\n<p>集中服务器本质上是一台被设置在公网上的服务器，建立P2P的双方都可以直接访问到这台服务器。位于NAT网关后面的客户端A和B都可以与一台已知的集中服务器建立连接，并通过这台集中服务器了解对方的信息并中转各自的信息。</p>\n<p>同时集中服务器的另一个重要作用在于判断某个客户端是否在NAT网关之后。具体的方法是：一个客户端在集中服务器上登陆的时候，服务器记录下该客户端的两对地址二元组信息{IP地址:UDP端口}，一对是该客户端与集中服务器进行通信的自身的IP地址和端口号，另一对是集中服务器记录下的由服务器“观察”到的该客户端实际与自己通信所使用的IP地址和端口号。我们可以把前一对地址二元组看作是客户端的内网IP地址和端口号，把后一对地址二元组看作是客户端的内网IP地址和端口号经过NAT转换后的外网IP地址和端口号。集中服务器可以从客户端的登陆消息中得到该客户端的内网相关信息，还可以通过登陆消息的IP头和UDP头得到该客户端的外网相关信息。如果该客户端不是位于NAT设备后面，那么采用上述方法得到的两对地址二元组信息是完全相同的。</p>\n<p>P2P的Session建立原理：</p>\n<p>假定客户端A要发起对客户端B的直接连接，具体的“打洞”过程如下：</p>\n<ol>\n<li>A最初不知道如何向客户端B发起连接，于是A向集中服务器发送消息，请求集中服务器帮助建立与客户端B的UDP连接。</li>\n<li>集中服务器将含有B的外网和内网的地址二元组发给A，同时，集中服务器将包含有A的外网和内网的地址二元组信息的消息也发给B。这样一来， A与B就都知道对方外网和内网的地址二元组信息了。</li>\n<li>当A收到由集中服务器发来的包含B的外网和内网的地址二元组信息后， A开始向B的地址二元组发送UDP数据包，并且A会自动锁定第一个给出响应的B的地址二元组。同理，当B收到由集中服务器发来的A的外网和内网地址二元组信息后，也会开始向A的外网和内网的地址二元组发送UDP数据包，并且自动锁定第一个得到A回应的地址二元组。由于A与B互相向对方发送UDP数据包的操作是异步的，所以A和B发送数据包的时间先后并没有时序要求。</li>\n</ol>\n<p>下面来看下这三者之间是如何进行UDP打洞的。在这我们分三种具体情景来讨论：</p>\n<ul>\n<li>第一种是最简单的一种情景，两个客户端都位于同一个NAT设备后面，即位于同一内网中；</li>\n<li>第二种是最普遍的一种情景，两个客户端分别位于不同的NAT设备后面，分属不同的内网；</li>\n<li>第三种是客户端位于两层NAT设备之后，通常最上层的NAT是由网络提供商提供的，第二层NAT是家用的NAT路由器之类的设备提供的。</li>\n</ul>\n<blockquote>\n<p>典型P2P情景1：  两客户端位于同一NAT设备后面（即相同内网中）</p>\n</blockquote>\n<p>这是最简单的一种情况（如图4所示）：客户端A和B分别与集中服务器建立UDP连接，经过NAT转换后，A的公网端口被映射为62000，B的公网端口映射为62005。</p>\n<p>图4 - 位于同一个NAT设备后的UDP打洞过程：<br><img src=\"http://www.52im.net/data/attachment/forum/201610/10/134836i9jb3hccbq8cz33q.png\" alt=\"image\"></p>\n<p>当A向集中服务器发出消息请求与B进行连接，集中服务器将B的外网地址二元组以及内网地址二元组发给A，同时把A的外网以及内网的地址二元组信息发给B。A和B发往对方公网地址二元组信息的UDP数据包不一定会被对方收到，这取决于当前的NAT设备是否支持不同端口之间的UDP数据包能否到达（即Hairpin转换特性），无论如何A与B发往对方内网的地址二元组信息的UDP数据包是一定可以到达的，内网数据包不需要路由，且速度更快。A与B推荐采用内网的地址二元组信息进行常规的P2P通信。</p>\n<p>假定NAT设备支持Hairpin转换，P2P双方也应忽略与内网地址二元组的连接，如果A 和B采用外网的地址二元组做为P2P通信的连接，这势必会造成数据包无谓地经过NAT设备，这是一种对资源的浪费。就目前的网络情况而言，应用程序在“打洞”的时候，最好还是把外网和内网的地址二元组都尝试一下。如果都能成功，优先以内网地址进行连接。</p>\n<p>什么是Hairpin技术？</p>\n<blockquote>\n<p>Hairpin技术又被称为Hairpin NAT、Loopback NAT或Hairpin Translation。Hairpin技术需要NAT网关支持，它能够让两台位于同一台NAT网关后面的主机，通过对方的公网地址和端口相互访问，NAT网关会根据一系列规则，将对内部主机发往其NAT公网IP地址的报文进行转换，并从私网接口发送给目标主机。目前有很多NAT设备不支持该技术，这种情况下，NAT网关在一些特定场合下将会阻断P2P穿越NAT的行为，打洞的尝试是无法成功的。好在现在已经有越来越多的NAT设备商开始加入到对该转换的支持中来。</p>\n</blockquote>\n<blockquote>\n<p>典型P2P情景2： \b两客户端位于不同的NAT设备后面（分属不同的内网）</p>\n</blockquote>\n<p>这是最普遍的一种情况（如图5所示）：客户端A与B经由各自的NAT设备与集中服务器建立UDP连接， A与B的本地端口号均为4321，集中服务器的公网端口号为1234。在向外的会话中， A的外网IP被映射为155.99.25.11，外网端口为62000；B的外网IP被映射为138.76.29.7，外网端口为31000。</p>\n<p>如下所示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">客户端A——&gt;本地IP:10.0.0.1，本地端口:4321，外网IP:155.99.25.11，外网端口:62000</span><br><span class=\"line\">客户端B——&gt;本地IP:10.1.1.3，本地端口:4321，外网IP:138.76.29.7，外网端口:31000</span><br></pre></td></tr></table></figure></p>\n<p>图5 - 位于不同NAT设备后的UDP打洞过程：<br><img src=\"http://www.52im.net/data/attachment/forum/201610/10/134846sq9njqoqa88c6lnk.png\" alt=\"image\"></p>\n<p>在A向服务器发送的登陆消息中，包含有A的内网地址二元组信息，即10.0.0.1:4321；服务器会记录下A的内网地址二元组信息，同时会把自己观察到的A的外网地址二元组信息记录下来。同理，服务器也会记录下B的内网地址二元组信息和由服务器观察到的客户端B的外网地址二元组信息。无论A与B二者中的任何一方向服务器发送P2P连接请求，服务器都会将其记录下来的上述的外网和内网地址二元组发送给A或B。</p>\n<p>A和B分属不同的内网，它们的内网地址在外网中是没有路由的，所以发往各自内网地址的UDP数据包会发送到错误的主机或者根本不存在的主机上。当A的第一个消息发往B的外网地址（如图3所示），该消息途经A的NAT设备，并在该设备上生成一个会话表项，该会话的源地址二元组信息是{10.0.0.1:4321}，和A与服务器建立连接的时候NAT生成的源地址二元组信息一样，但它的目的地址是B的外网地址。在A的NAT设备支持保留A的内网地址二元组信息的情况下，所有来自A的源地址二元组信息为{10.0.0.1:4321}的数据包都沿用A与集中服务器事先建立起来的会话，这些数据包的外网地址二元组信息均被映射为{155.99.25.11:62000}。</p>\n<p>A向B的外网地址发送消息的过程就是“打洞”的过程，从A的内网的角度来看应为从{10.0.0.1:4321}发往{138.76.29.7:31000}，从A在其NAT设备上建立的会话来看，是从{155.99.25.11:62000}发到{138.76.29.7:31000}。如果A发给B的外网地址二元组的消息包在B向A发送消息包之前到达B的NAT设备，B的NAT设备会认为A发过来的消息是未经授权的外网消息，并丢弃该数据包。</p>\n<p>B发往A的消息包也会在B的NAT设备上建立一个{10.1.1.3:4321，155.99.25.11:62000}的会话（通常也会沿用B与集中服务器连接时建立的会话，只是该会话现在不仅接受由服务器发给B的消息，还可以接受从A的NAT设备{155.99.25.11:6200}发来的消息）。</p>\n<p>一旦A与B都向对方的NAT设备在外网上的地址二元组发送了数据包，就打开了A与B之间的“洞”，A与B向对方的外网地址发送数据，等效为向对方的客户端直接发送UDP数据包了。一旦应用程序确认已经可以通过往对方的外网地址发送数据包的方式让数据包到达NAT后面的目的应用程序，程序会自动停止继续发送用于“打洞”的数据包，转而开始真正的P2P数据传输。</p>\n<blockquote>\n<p>典型P2P情景3： 两客户端位于两层(或多层)NAT设备之后（分属不同的内网）</p>\n</blockquote>\n<p>此种情景最典型的部署情况就像这样：最上层的NAT设备通常是由网络提供商（ISP）提供，下层NAT设备是家用路由器。</p>\n<p>如图6所示：假定NAT C是由ISP提供的NAT设备，NAT C提供将多个用户节点映射到有限的几个公网IP的服务，NAT A和NAT B作为NAT C的内网节点将把用户的内部网络接入NAT C的内网，用户的内部网络就可以经由NAT C访问公网了。从这种拓扑结构上来看，只有服务器与NAT C是真正拥有公网可路由IP地址的设备，而NAT A和NAT B所使用的公网IP地址，实际上是由ISP服务提供商设定的（相对于NAT C而言）内网地址（我们将这种由ISP提供的内网地址称之为“伪”公网地址）。同理，隶属于NAT A与NAT B的客户端，它们处于NAT A，NAT B的内网，以此类推，客户端可以放到到多层NAT设备后面。客户端A和客户端B发起对服务器S的连接的时候，就会依次在NAT A和NAT B上建立向外的Session，而NAT A、NAT B要联入公网的时候，会在NAT C上再建立向外的Session。</p>\n<p>图6 - 多层NAT下的打洞过程：<br><img src=\"http://www.52im.net/data/attachment/forum/201610/10/134855zdalvzak5dbyksvk.png\" alt=\"image\"></p>\n<p>现在假定客户端A和B希望通过UDP“打洞”完成两个客户端的P2P直连。最优化的路由策略是客户端A向客户端B的“伪公网”IP上发送数据包，即ISP服务提供商指定的内网IP，NAT B的“伪”公网地址二元组，{10.0.1.2:55000}。由于从服务器的角度只能观察到真正的公网地址，也就是NAT A，NAT B在NAT C建立session的真正的公网地址{155.99.25.11:62000}以及{155.99.25.11:62005}，非常不幸的是客户端A与客户端B是无法通过服务器知道这些“伪”公网的地址，而且即使客户端A和B通过某种手段可以得到NAT A和NAT B的“伪”公网地址，我们仍然不建议采用上述的“最优化”的打洞方式，这是因为这些地址是由ISP服务提供商提供的或许会存在与客户端本身所在的内网地址重复的可能性（例如:NAT A的内网的IP地址域恰好与NAT A在NAT C的“伪”公网IP地址域重复，这样就会导致打洞数据包无法发出的问题）。</p>\n<p>因此客户端别无选择，只能使用由公网服务器观察到的A，B的公网地址二元组进行“打洞”操作，用于“打洞”的数据包将由NAT C进行转发。</p>\n<p>当客户端A向客户端B的公网地址二元组{155.99.25.11:62005}发送UDP数据包的时候，NAT A首先把数据包的源地址二元组由A的内网地址二元组{10.0.0.1:4321}转换为“伪”公网地址二元组{10.0.1.1:45000}，现在数据包到了NAT C，NAT C应该可以识别出来该数据包是要发往自身转换过的公网地址二元组，如果NAT C可以给出“合理”响应的话，NAT C将把该数据包的源地址二元组改为{155.99.25.11:62000}，目的地址二元组改为{10.0.1.2:55000}，即NAT B的“伪”公网地址二元组，NAT B最后会将收到的数据包发往客户端B。同样，由B发往A的数据包也会经过类似的过程。目前也有很多NAT设备不支持类似这样的“Hairpin转换”，但是已经有越来越多的NAT设备商开始加入对该转换的支持中来。</p>\n<blockquote>\n<p>一个需要考虑的现实问题：UDP在空闲状态下的超时</p>\n</blockquote>\n<p>当然，从应用的角度上来说，在完成打洞过程的同时，还有一些技术问题需要解决，如UDP在空闲状态下的超时问题。由于UDP转换协议提供的“洞”不是绝对可靠的，多数NAT设备内部都有一个UDP转换的空闲状态计时器，如果在一段时间内没有UDP数据通信，NAT设备会关掉由“打洞”过程打出来的“洞”。如果P2P应用程序希望“洞”的存活时间不受NAT网关的限制，就最好在穿越NAT以后设定一个穿越的有效期。</p>\n<p>对于有效期目前没有标准值，它与NAT设备内部的配置有关，某些设备上最短的只有20秒左右。在这个有效期内，即使没有P2P数据包需要传输，应用程序为了维持该“洞”可以正常工作，也必须向对方发送“打洞”心跳包。这个心跳包是需要双方应用程序都发送的，只有一方发送不会维持另一方的Session正常工作。除了频繁发送“打洞”心跳包以外，还有一个方法就是在当前的“洞”超时之前，P2P客户端双方重新“打洞”，丢弃原有的“洞”，这也不失为一个有效的方法。</p>\n<h2 id=\"4、基于TCP协议的P2P打洞技术详细\"><a href=\"#4、基于TCP协议的P2P打洞技术详细\" class=\"headerlink\" title=\"4、基于TCP协议的P2P打洞技术详细\"></a>4、基于TCP协议的P2P打洞技术详细</h2><p>建立穿越NAT设备的P2P的TCP连接只比UDP复杂一点点，TCP协议的”“打洞”从协议层来看是与UDP的“打洞”过程非常相似的。尽管如此，基于TCP协议的打洞至今为止还没有被很好的理解，这也造成了的对其提供支持的NAT设备不是很多。在NAT设备支持的前提下，基于TCP的“打洞”技术实际上与基于UDP的“打洞”技术一样快捷、可靠。实际上，只要NAT设备支持的话，基于TCP的P2P技术的健壮性将比基于UDP技术的更强一些，因为TCP协议的状态机给出了一种标准的方法来精确的获取某个TCP session的生命期，而UDP协议则无法做到这一点。</p>\n<blockquote>\n<p>套接字和TCP端口的重用</p>\n</blockquote>\n<p>实现基于TCP协议的P2P打洞过程中，最主要的问题不是来自于TCP协议，而是来自于应用程序的API接口。这是由于标准的伯克利(Berkeley)套接字的API是围绕着构建客户端/服务器程序而设计的，API允许TCP流套接字通过调用connect()函数来建立向外的连接，或者通过listen()和accept函数接受来自外部的连接，但是，API不提供类似UDP那样的，同一个端口既可以向外连接，又能够接受来自外部的连接。而且更糟的是，TCP的套接字通常仅允许建立1对1的响应，即应用程序在将一个套接字绑定到本地的一个端口以后，任何试图将第二个套接字绑定到该端口的操作都会失败。</p>\n<p>为了让TCP“打洞”能够顺利工作，我们需要使用一个本地的TCP端口来监听来自外部的TCP连接，同时建立多个向外的TCP连接。幸运的是，所有的主流操作系统都能够支持特殊的TCP套接字参数，通常叫做“SO_REUSEADDR”，该参数允许应用程序将多个套接字绑定到本地的一个地址二元组（只要所有要绑定的套接字都设置了SO_REUSEADDR参数即可）。BSD系统引入了SO_REUSEPORT参数，该参数用于区分端口重用还是地址重用，在这样的系统里面，上述所有的参数必须都设置才行。</p>\n<blockquote>\n<p>打开P2P的TCP流</p>\n</blockquote>\n<p>假定客户端A希望建立与B的TCP连接。我们像通常一样假定A和B已经与公网上的已知服务器建立了TCP连接。服务器记录下来每个接入的客户端的公网和内网的地址二元组，如同为UDP服务的时候一样。</p>\n<p>从协议层来看，TCP“打洞”与UDP“打洞”是几乎完全相同的过程：</p>\n<ul>\n<li>客户端A使用其与服务器的连接向服务器发送请求，要求服务器协助其连接客户端B；</li>\n<li>服务器将B的公网和内网的TCP地址的二元组信息返回给A，同时，服务器将A的公网和内网的地址二元组也发送给B；</li>\n<li>客户端A和B使用连接服务器的端口异步地发起向对方的公网、内网地址二元组的TCP连接，同时监听各自的本地TCP端口是否有外部的连接联入；</li>\n<li>A和B开始等待向外的连接是否成功，检查是否有新连接联入。如果向外的连接由于某种网络错误而失败，如：“连接被重置”或者“节点无法访问”，客户端只需要延迟一小段时间（例如延迟一秒钟），然后重新发起连接即可，延迟的时间和重复连接的次数可以由应用程序编写者来确定；</li>\n<li>TCP连接建立起来以后，客户端之间应该开始鉴权操作，确保目前联入的连接就是所希望的连接。如果鉴权失败，客户端将关闭连接，并且继续等待新的连接联入。客户端通常采用“先入为主”的策略，只接受第一个通过鉴权操作的客户端，然后将进入P2P通信过程不再继续等待是否有新的连接联入。</li>\n</ul>\n<p>图7 - TCP打洞：<br><img src=\"http://www.52im.net/data/attachment/forum/201610/10/134112o7g7ojub3wj3ju3u.png\" alt=\"image\"></p>\n<p>与UDP不同的是，因为使用UDP协议的每个客户端只需要一个套接字即可完成与服务器的通信，而TCP客户端必须处理多个套接字绑定到同一个本地TCP端口的问题，如图7所示。现在来看实际中常见的一种情景，A与B分别位于不同的NAT设备后面，如图5所示，并且假定图中的端口号是TCP协议的端口号，而不是UDP的端口号。图中向外的连接代表A和B向对方的内网地址二元组发起的连接，这些连接或许会失败或者无法连接到对方。如同使用UDP协议进行“打洞”操作遇到的问题一样，TCP的“打洞”操作也会遇到内网的IP与“伪”公网IP重复造成连接失败或者错误连接之类的问题。</p>\n<p>客户端向彼此公网地址二元组发起连接的操作，会使得各自的NAT设备打开新的“洞”允许A与B的TCP数据通过。如果NAT设备支持TCP“打洞”操作的话，一个在客户端之间的基于TCP协议的流通道就会自动建立起来。如果A向B发送的第一个SYN包发到了B的NAT设备，而B在此前没有向A发送SYN包，B的NAT设备会丢弃这个包，这会引起A的“连接失败”或“无法连接”问题。而此时，由于A已经向B发送过SYN包，B发往A的SYN包将被看作是由A发往B的包的回应的一部分，所以B发往A的SYN包会顺利地通过A的NAT设备，到达A，从而建立起A与B的P2P连接。</p>\n<blockquote>\n<p>从应用程序的角度来看TCP“打洞”</p>\n</blockquote>\n<p>从应用程序的角度来看，在进行TCP“打洞”的时候都发生了什么呢？假定A首先向B发出SYN包，该包发往B的公网地址二元组，并且被B的NAT设备丢弃，但是B发往A的公网地址二元组的SYN包则通过A的NAT到达了A，然后，会发生以下的两种结果中的一种，具体是哪一种取决于操作系统对TCP协议的实现：</p>\n<p>（1）A的TCP实现会发现收到的SYN包就是其发起连接并希望联入的B的SYN包，通俗一点来说就是“说曹操，曹操到”的意思，本来A要去找B，结果B自己找上门来了。A的TCP协议栈因此会把B作为A向B发起连接connect的一部分，并认为连接已经成功。程序A调用的异步connect()函数将成功返回，A的listen()等待从外部联入的函数将没有任何反映。此时，B联入A的操作在A程序的内部被理解为A联入B连接成功，并且A开始使用这个连接与B开始P2P通信。</p>\n<p>由于收到的SYN包中不包含A需要的ACK数据，因此，A的TCP将用SYN-ACK包回应B的公网地址二元组，并且将使用先前A发向B的SYN包一样的序列号。一旦B的TCP收到由A发来的SYN-ACK包，则把自己的ACK包发给A，然后两端建立起TCP连接。简单的说，第一种，就是即使A发往B的SYN包被B的NAT丢弃了，但是由于B发往A的包到达了A。结果是，A认为自己连接成功了，B也认为自己连接成功了，不管是谁成功了，总之连接是已经建立起来了。</p>\n<p>（2）另外一种结果是，A的TCP实现没有像（1）中所讲的那么“智能”，它没有发现现在联入的B就是自己希望联入的。就好比在机场接人，明明遇到了自己想要接的人却不认识，误认为是其他的人，安排别人给接走了，后来才知道是自己错过了机会，但是无论如何，人已经接到了任务已经完成了。然后，A通过常规的listen()函数和accept()函数得到与B的连接，而由A发起的向B的公网地址二元组的连接会以失败告终。尽管A向B的连接失败，A仍然得到了B发起的向A的连接，等效于A与B之间已经联通，不管中间过程如何，A与B已经连接起来了，结果是A和B的基于TCP协议的P2P连接已经建立起来了。</p>\n<p>第一种结果适用于基于BSD的操作系统对于TCP的实现，而第二种结果更加普遍一些，多数Linux和Windows系统都会按照第二种结果来处理。</p>\n<h2 id=\"5、本文小结\"><a href=\"#5、本文小结\" class=\"headerlink\" title=\"5、本文小结\"></a>5、本文小结</h2><p>在IP地址极度短缺的今天，NAT几乎已经是无所不在的一项技术了，以至于现在任何一项新技术都不得不考虑和NAT的兼容。作为当下应用最广泛的技术之一，P2P技术也必然要面对NAT这个障碍。</p>\n<p>打洞技术看起来是一项近似乎蛮干的技术，却不失为一种有效的技术手段。在集中服务器的帮助下，P2P的双方利用端口预测的技术在NAT网关上打出通道，从而实现NAT穿越，解决了NAT对于P2P的阻隔，为P2P技术在网络中更广泛的推广作出了非常大的贡献。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"1、内容概述\"><a href=\"#1、内容概述\" class=\"headerlink\" title=\"1、内容概述\"></a>1、内容概述</h2><p>P2P即点对点通信，或称为对等联网，与传统的服务器客户端模式（如下图“P2P结构模型”所示）有着明显的区别，在即时通讯方案中应用广泛（比如IM应用中的实时音视频通信、实时文件传输甚至文字聊天等）。</p>\n<p>P2P可以是一种通信模式、一种逻辑网络模型、一种技术、甚至一种理念。在P2P网络中（如右图所示），所有通信节点的地位都是对等的，每个节点都扮演着客户机和服务器双重角色，节点之间通过直接通信实现文件信息、处理器运算能力、存储空间等资源的共享。P2P网络具有分散性、可扩展性、健壮性等特点，这使得P2P技术在信息共享、\b即时通讯、协同工作、分布式计算、网络存储等领域都有广阔的应用。</p>\n<p>图1 - 经典的CS模式：<br><img src=\"http://www.52im.net/data/attachment/forum/201610/10/132736s7tqmprzhrz7wzds.jpg\" alt=\"image\"></p>\n<p>图2 - P2P结构模型：<br><img src=\"http://www.52im.net/data/attachment/forum/201610/10/132735dgcypehy72gbrv4d.jpg\" alt=\"image\"></p>\n<p>NAT技术和P2P技术作为经典的两项网络技术，在现在的网络上有着广泛的应用，P2P主机位于NAT网关后面的情况屡见不鲜。NAT技术虽然在一定程度上解决了IPv4地址短缺的问题，在构建防火墙、保证网络安全方面都发挥了一定的作用，却破坏了端到端的网络通信。NAT阻碍主机进行P2P通信的主要原因是NAT不允许外网主机主动访问内网主机，但是P2P技术却要求通信双方都能主动发起访问，所以要在NAT网络环境中进行有效的P2P通信，就必须采用新的解决方案。</p>\n<p>P2P作为一项实用的技术，有很大的优化空间，并且相对于网络设备，基于P2P的应用程序在实现上更为灵活。所以为了兼容NAT，基于P2P的应用程序在开发的时候大多会根据自身特点加入一些穿越NAT的功能以解决上述问题。以下着重介绍几种常见的P2P穿越NAT方案。</p>","more":"<h2 id=\"2、反向链接技术：一种特殊的P2P场景（通信双方中只有一方位于NAT设备之后）\"><a href=\"#2、反向链接技术：一种特殊的P2P场景（通信双方中只有一方位于NAT设备之后）\" class=\"headerlink\" title=\"2、反向链接技术：一种特殊的P2P场景（通信双方中只有一方位于NAT设备之后）\"></a>2、反向链接技术：一种特殊的P2P场景（通信双方中只有一方位于NAT设备之后）</h2><p>此种情况是所有P2P场景中最简单的，它使用一种被称为“反向链接技术”来解决这个问题。大致的原理如下所述。</p>\n<p>如图3所示，客户端A位于NAT之后，它通过TCP端口1234连接到服务器的TCP端口1235上，NAT设备为这个连接重新分配了TCP端口62000。客户端B也通过TCP端口1234连接到服务器端口1235上。A和B从服务器处获知的对方的外网地址二元组{IP地址:端口号}分别为{138.76.29.7:1234}和{155.99.25.11:62000}，它们在各自的本地端口上进行侦听。</p>\n<p>由于B 拥有外网IP地址，所以A要发起与B的通信，可以直接通过TCP连接到B。但如果B尝试通过TCP连接到A进行P2P通信，则会失败，原因是A位于NAT设备后，虽然B发出的TCP SYN请求能够到达NAT设备的端口62000，但NAT设备会拒绝这个连接请求。要想与Client A通信， B不是直接向A发起连接，而是通过服务器给A转发一个连接请求，反过来请求A连接到B（即进行反向链接），A在收到从服务器转发过来的请求以后，会主动向B发起一个TCP的连接请求，这样在NAT设备上就会建立起关于这个连接的相关表项，使A和B之间能够正常通信，从而建立起它们之间的TCP连接。</p>\n<p>图3 - 反向链接示意图：<br><img src=\"http://www.52im.net/data/attachment/forum/201610/10/133042i8nux66pj1jbul6p.jpg\" alt=\"image\"></p>\n<h2 id=\"3、基于UDP协议的P2P打洞技术详解\"><a href=\"#3、基于UDP协议的P2P打洞技术详解\" class=\"headerlink\" title=\"3、基于UDP协议的P2P打洞技术详解\"></a>3、基于UDP协议的P2P打洞技术详解</h2><blockquote>\n<p>原理概述</p>\n</blockquote>\n<p>UDP打洞技术是通过中间服务器的协助在各自的NAT网关上建立相关的表项，使P2P连接的双方发送的报文能够直接穿透对方的NAT网关，从而实现P2P客户端互连。如果两台位于NAT设备后面的P2P客户端希望在自己的NAT网关上打个洞，那么他们需要一个协助者——集中服务器，并且还需要一种用于打洞的Session建立机制。</p>\n<p>什么是集中服务器？</p>\n<p>集中服务器本质上是一台被设置在公网上的服务器，建立P2P的双方都可以直接访问到这台服务器。位于NAT网关后面的客户端A和B都可以与一台已知的集中服务器建立连接，并通过这台集中服务器了解对方的信息并中转各自的信息。</p>\n<p>同时集中服务器的另一个重要作用在于判断某个客户端是否在NAT网关之后。具体的方法是：一个客户端在集中服务器上登陆的时候，服务器记录下该客户端的两对地址二元组信息{IP地址:UDP端口}，一对是该客户端与集中服务器进行通信的自身的IP地址和端口号，另一对是集中服务器记录下的由服务器“观察”到的该客户端实际与自己通信所使用的IP地址和端口号。我们可以把前一对地址二元组看作是客户端的内网IP地址和端口号，把后一对地址二元组看作是客户端的内网IP地址和端口号经过NAT转换后的外网IP地址和端口号。集中服务器可以从客户端的登陆消息中得到该客户端的内网相关信息，还可以通过登陆消息的IP头和UDP头得到该客户端的外网相关信息。如果该客户端不是位于NAT设备后面，那么采用上述方法得到的两对地址二元组信息是完全相同的。</p>\n<p>P2P的Session建立原理：</p>\n<p>假定客户端A要发起对客户端B的直接连接，具体的“打洞”过程如下：</p>\n<ol>\n<li>A最初不知道如何向客户端B发起连接，于是A向集中服务器发送消息，请求集中服务器帮助建立与客户端B的UDP连接。</li>\n<li>集中服务器将含有B的外网和内网的地址二元组发给A，同时，集中服务器将包含有A的外网和内网的地址二元组信息的消息也发给B。这样一来， A与B就都知道对方外网和内网的地址二元组信息了。</li>\n<li>当A收到由集中服务器发来的包含B的外网和内网的地址二元组信息后， A开始向B的地址二元组发送UDP数据包，并且A会自动锁定第一个给出响应的B的地址二元组。同理，当B收到由集中服务器发来的A的外网和内网地址二元组信息后，也会开始向A的外网和内网的地址二元组发送UDP数据包，并且自动锁定第一个得到A回应的地址二元组。由于A与B互相向对方发送UDP数据包的操作是异步的，所以A和B发送数据包的时间先后并没有时序要求。</li>\n</ol>\n<p>下面来看下这三者之间是如何进行UDP打洞的。在这我们分三种具体情景来讨论：</p>\n<ul>\n<li>第一种是最简单的一种情景，两个客户端都位于同一个NAT设备后面，即位于同一内网中；</li>\n<li>第二种是最普遍的一种情景，两个客户端分别位于不同的NAT设备后面，分属不同的内网；</li>\n<li>第三种是客户端位于两层NAT设备之后，通常最上层的NAT是由网络提供商提供的，第二层NAT是家用的NAT路由器之类的设备提供的。</li>\n</ul>\n<blockquote>\n<p>典型P2P情景1：  两客户端位于同一NAT设备后面（即相同内网中）</p>\n</blockquote>\n<p>这是最简单的一种情况（如图4所示）：客户端A和B分别与集中服务器建立UDP连接，经过NAT转换后，A的公网端口被映射为62000，B的公网端口映射为62005。</p>\n<p>图4 - 位于同一个NAT设备后的UDP打洞过程：<br><img src=\"http://www.52im.net/data/attachment/forum/201610/10/134836i9jb3hccbq8cz33q.png\" alt=\"image\"></p>\n<p>当A向集中服务器发出消息请求与B进行连接，集中服务器将B的外网地址二元组以及内网地址二元组发给A，同时把A的外网以及内网的地址二元组信息发给B。A和B发往对方公网地址二元组信息的UDP数据包不一定会被对方收到，这取决于当前的NAT设备是否支持不同端口之间的UDP数据包能否到达（即Hairpin转换特性），无论如何A与B发往对方内网的地址二元组信息的UDP数据包是一定可以到达的，内网数据包不需要路由，且速度更快。A与B推荐采用内网的地址二元组信息进行常规的P2P通信。</p>\n<p>假定NAT设备支持Hairpin转换，P2P双方也应忽略与内网地址二元组的连接，如果A 和B采用外网的地址二元组做为P2P通信的连接，这势必会造成数据包无谓地经过NAT设备，这是一种对资源的浪费。就目前的网络情况而言，应用程序在“打洞”的时候，最好还是把外网和内网的地址二元组都尝试一下。如果都能成功，优先以内网地址进行连接。</p>\n<p>什么是Hairpin技术？</p>\n<blockquote>\n<p>Hairpin技术又被称为Hairpin NAT、Loopback NAT或Hairpin Translation。Hairpin技术需要NAT网关支持，它能够让两台位于同一台NAT网关后面的主机，通过对方的公网地址和端口相互访问，NAT网关会根据一系列规则，将对内部主机发往其NAT公网IP地址的报文进行转换，并从私网接口发送给目标主机。目前有很多NAT设备不支持该技术，这种情况下，NAT网关在一些特定场合下将会阻断P2P穿越NAT的行为，打洞的尝试是无法成功的。好在现在已经有越来越多的NAT设备商开始加入到对该转换的支持中来。</p>\n</blockquote>\n<blockquote>\n<p>典型P2P情景2： \b两客户端位于不同的NAT设备后面（分属不同的内网）</p>\n</blockquote>\n<p>这是最普遍的一种情况（如图5所示）：客户端A与B经由各自的NAT设备与集中服务器建立UDP连接， A与B的本地端口号均为4321，集中服务器的公网端口号为1234。在向外的会话中， A的外网IP被映射为155.99.25.11，外网端口为62000；B的外网IP被映射为138.76.29.7，外网端口为31000。</p>\n<p>如下所示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">客户端A——&gt;本地IP:10.0.0.1，本地端口:4321，外网IP:155.99.25.11，外网端口:62000</span><br><span class=\"line\">客户端B——&gt;本地IP:10.1.1.3，本地端口:4321，外网IP:138.76.29.7，外网端口:31000</span><br></pre></td></tr></table></figure></p>\n<p>图5 - 位于不同NAT设备后的UDP打洞过程：<br><img src=\"http://www.52im.net/data/attachment/forum/201610/10/134846sq9njqoqa88c6lnk.png\" alt=\"image\"></p>\n<p>在A向服务器发送的登陆消息中，包含有A的内网地址二元组信息，即10.0.0.1:4321；服务器会记录下A的内网地址二元组信息，同时会把自己观察到的A的外网地址二元组信息记录下来。同理，服务器也会记录下B的内网地址二元组信息和由服务器观察到的客户端B的外网地址二元组信息。无论A与B二者中的任何一方向服务器发送P2P连接请求，服务器都会将其记录下来的上述的外网和内网地址二元组发送给A或B。</p>\n<p>A和B分属不同的内网，它们的内网地址在外网中是没有路由的，所以发往各自内网地址的UDP数据包会发送到错误的主机或者根本不存在的主机上。当A的第一个消息发往B的外网地址（如图3所示），该消息途经A的NAT设备，并在该设备上生成一个会话表项，该会话的源地址二元组信息是{10.0.0.1:4321}，和A与服务器建立连接的时候NAT生成的源地址二元组信息一样，但它的目的地址是B的外网地址。在A的NAT设备支持保留A的内网地址二元组信息的情况下，所有来自A的源地址二元组信息为{10.0.0.1:4321}的数据包都沿用A与集中服务器事先建立起来的会话，这些数据包的外网地址二元组信息均被映射为{155.99.25.11:62000}。</p>\n<p>A向B的外网地址发送消息的过程就是“打洞”的过程，从A的内网的角度来看应为从{10.0.0.1:4321}发往{138.76.29.7:31000}，从A在其NAT设备上建立的会话来看，是从{155.99.25.11:62000}发到{138.76.29.7:31000}。如果A发给B的外网地址二元组的消息包在B向A发送消息包之前到达B的NAT设备，B的NAT设备会认为A发过来的消息是未经授权的外网消息，并丢弃该数据包。</p>\n<p>B发往A的消息包也会在B的NAT设备上建立一个{10.1.1.3:4321，155.99.25.11:62000}的会话（通常也会沿用B与集中服务器连接时建立的会话，只是该会话现在不仅接受由服务器发给B的消息，还可以接受从A的NAT设备{155.99.25.11:6200}发来的消息）。</p>\n<p>一旦A与B都向对方的NAT设备在外网上的地址二元组发送了数据包，就打开了A与B之间的“洞”，A与B向对方的外网地址发送数据，等效为向对方的客户端直接发送UDP数据包了。一旦应用程序确认已经可以通过往对方的外网地址发送数据包的方式让数据包到达NAT后面的目的应用程序，程序会自动停止继续发送用于“打洞”的数据包，转而开始真正的P2P数据传输。</p>\n<blockquote>\n<p>典型P2P情景3： 两客户端位于两层(或多层)NAT设备之后（分属不同的内网）</p>\n</blockquote>\n<p>此种情景最典型的部署情况就像这样：最上层的NAT设备通常是由网络提供商（ISP）提供，下层NAT设备是家用路由器。</p>\n<p>如图6所示：假定NAT C是由ISP提供的NAT设备，NAT C提供将多个用户节点映射到有限的几个公网IP的服务，NAT A和NAT B作为NAT C的内网节点将把用户的内部网络接入NAT C的内网，用户的内部网络就可以经由NAT C访问公网了。从这种拓扑结构上来看，只有服务器与NAT C是真正拥有公网可路由IP地址的设备，而NAT A和NAT B所使用的公网IP地址，实际上是由ISP服务提供商设定的（相对于NAT C而言）内网地址（我们将这种由ISP提供的内网地址称之为“伪”公网地址）。同理，隶属于NAT A与NAT B的客户端，它们处于NAT A，NAT B的内网，以此类推，客户端可以放到到多层NAT设备后面。客户端A和客户端B发起对服务器S的连接的时候，就会依次在NAT A和NAT B上建立向外的Session，而NAT A、NAT B要联入公网的时候，会在NAT C上再建立向外的Session。</p>\n<p>图6 - 多层NAT下的打洞过程：<br><img src=\"http://www.52im.net/data/attachment/forum/201610/10/134855zdalvzak5dbyksvk.png\" alt=\"image\"></p>\n<p>现在假定客户端A和B希望通过UDP“打洞”完成两个客户端的P2P直连。最优化的路由策略是客户端A向客户端B的“伪公网”IP上发送数据包，即ISP服务提供商指定的内网IP，NAT B的“伪”公网地址二元组，{10.0.1.2:55000}。由于从服务器的角度只能观察到真正的公网地址，也就是NAT A，NAT B在NAT C建立session的真正的公网地址{155.99.25.11:62000}以及{155.99.25.11:62005}，非常不幸的是客户端A与客户端B是无法通过服务器知道这些“伪”公网的地址，而且即使客户端A和B通过某种手段可以得到NAT A和NAT B的“伪”公网地址，我们仍然不建议采用上述的“最优化”的打洞方式，这是因为这些地址是由ISP服务提供商提供的或许会存在与客户端本身所在的内网地址重复的可能性（例如:NAT A的内网的IP地址域恰好与NAT A在NAT C的“伪”公网IP地址域重复，这样就会导致打洞数据包无法发出的问题）。</p>\n<p>因此客户端别无选择，只能使用由公网服务器观察到的A，B的公网地址二元组进行“打洞”操作，用于“打洞”的数据包将由NAT C进行转发。</p>\n<p>当客户端A向客户端B的公网地址二元组{155.99.25.11:62005}发送UDP数据包的时候，NAT A首先把数据包的源地址二元组由A的内网地址二元组{10.0.0.1:4321}转换为“伪”公网地址二元组{10.0.1.1:45000}，现在数据包到了NAT C，NAT C应该可以识别出来该数据包是要发往自身转换过的公网地址二元组，如果NAT C可以给出“合理”响应的话，NAT C将把该数据包的源地址二元组改为{155.99.25.11:62000}，目的地址二元组改为{10.0.1.2:55000}，即NAT B的“伪”公网地址二元组，NAT B最后会将收到的数据包发往客户端B。同样，由B发往A的数据包也会经过类似的过程。目前也有很多NAT设备不支持类似这样的“Hairpin转换”，但是已经有越来越多的NAT设备商开始加入对该转换的支持中来。</p>\n<blockquote>\n<p>一个需要考虑的现实问题：UDP在空闲状态下的超时</p>\n</blockquote>\n<p>当然，从应用的角度上来说，在完成打洞过程的同时，还有一些技术问题需要解决，如UDP在空闲状态下的超时问题。由于UDP转换协议提供的“洞”不是绝对可靠的，多数NAT设备内部都有一个UDP转换的空闲状态计时器，如果在一段时间内没有UDP数据通信，NAT设备会关掉由“打洞”过程打出来的“洞”。如果P2P应用程序希望“洞”的存活时间不受NAT网关的限制，就最好在穿越NAT以后设定一个穿越的有效期。</p>\n<p>对于有效期目前没有标准值，它与NAT设备内部的配置有关，某些设备上最短的只有20秒左右。在这个有效期内，即使没有P2P数据包需要传输，应用程序为了维持该“洞”可以正常工作，也必须向对方发送“打洞”心跳包。这个心跳包是需要双方应用程序都发送的，只有一方发送不会维持另一方的Session正常工作。除了频繁发送“打洞”心跳包以外，还有一个方法就是在当前的“洞”超时之前，P2P客户端双方重新“打洞”，丢弃原有的“洞”，这也不失为一个有效的方法。</p>\n<h2 id=\"4、基于TCP协议的P2P打洞技术详细\"><a href=\"#4、基于TCP协议的P2P打洞技术详细\" class=\"headerlink\" title=\"4、基于TCP协议的P2P打洞技术详细\"></a>4、基于TCP协议的P2P打洞技术详细</h2><p>建立穿越NAT设备的P2P的TCP连接只比UDP复杂一点点，TCP协议的”“打洞”从协议层来看是与UDP的“打洞”过程非常相似的。尽管如此，基于TCP协议的打洞至今为止还没有被很好的理解，这也造成了的对其提供支持的NAT设备不是很多。在NAT设备支持的前提下，基于TCP的“打洞”技术实际上与基于UDP的“打洞”技术一样快捷、可靠。实际上，只要NAT设备支持的话，基于TCP的P2P技术的健壮性将比基于UDP技术的更强一些，因为TCP协议的状态机给出了一种标准的方法来精确的获取某个TCP session的生命期，而UDP协议则无法做到这一点。</p>\n<blockquote>\n<p>套接字和TCP端口的重用</p>\n</blockquote>\n<p>实现基于TCP协议的P2P打洞过程中，最主要的问题不是来自于TCP协议，而是来自于应用程序的API接口。这是由于标准的伯克利(Berkeley)套接字的API是围绕着构建客户端/服务器程序而设计的，API允许TCP流套接字通过调用connect()函数来建立向外的连接，或者通过listen()和accept函数接受来自外部的连接，但是，API不提供类似UDP那样的，同一个端口既可以向外连接，又能够接受来自外部的连接。而且更糟的是，TCP的套接字通常仅允许建立1对1的响应，即应用程序在将一个套接字绑定到本地的一个端口以后，任何试图将第二个套接字绑定到该端口的操作都会失败。</p>\n<p>为了让TCP“打洞”能够顺利工作，我们需要使用一个本地的TCP端口来监听来自外部的TCP连接，同时建立多个向外的TCP连接。幸运的是，所有的主流操作系统都能够支持特殊的TCP套接字参数，通常叫做“SO_REUSEADDR”，该参数允许应用程序将多个套接字绑定到本地的一个地址二元组（只要所有要绑定的套接字都设置了SO_REUSEADDR参数即可）。BSD系统引入了SO_REUSEPORT参数，该参数用于区分端口重用还是地址重用，在这样的系统里面，上述所有的参数必须都设置才行。</p>\n<blockquote>\n<p>打开P2P的TCP流</p>\n</blockquote>\n<p>假定客户端A希望建立与B的TCP连接。我们像通常一样假定A和B已经与公网上的已知服务器建立了TCP连接。服务器记录下来每个接入的客户端的公网和内网的地址二元组，如同为UDP服务的时候一样。</p>\n<p>从协议层来看，TCP“打洞”与UDP“打洞”是几乎完全相同的过程：</p>\n<ul>\n<li>客户端A使用其与服务器的连接向服务器发送请求，要求服务器协助其连接客户端B；</li>\n<li>服务器将B的公网和内网的TCP地址的二元组信息返回给A，同时，服务器将A的公网和内网的地址二元组也发送给B；</li>\n<li>客户端A和B使用连接服务器的端口异步地发起向对方的公网、内网地址二元组的TCP连接，同时监听各自的本地TCP端口是否有外部的连接联入；</li>\n<li>A和B开始等待向外的连接是否成功，检查是否有新连接联入。如果向外的连接由于某种网络错误而失败，如：“连接被重置”或者“节点无法访问”，客户端只需要延迟一小段时间（例如延迟一秒钟），然后重新发起连接即可，延迟的时间和重复连接的次数可以由应用程序编写者来确定；</li>\n<li>TCP连接建立起来以后，客户端之间应该开始鉴权操作，确保目前联入的连接就是所希望的连接。如果鉴权失败，客户端将关闭连接，并且继续等待新的连接联入。客户端通常采用“先入为主”的策略，只接受第一个通过鉴权操作的客户端，然后将进入P2P通信过程不再继续等待是否有新的连接联入。</li>\n</ul>\n<p>图7 - TCP打洞：<br><img src=\"http://www.52im.net/data/attachment/forum/201610/10/134112o7g7ojub3wj3ju3u.png\" alt=\"image\"></p>\n<p>与UDP不同的是，因为使用UDP协议的每个客户端只需要一个套接字即可完成与服务器的通信，而TCP客户端必须处理多个套接字绑定到同一个本地TCP端口的问题，如图7所示。现在来看实际中常见的一种情景，A与B分别位于不同的NAT设备后面，如图5所示，并且假定图中的端口号是TCP协议的端口号，而不是UDP的端口号。图中向外的连接代表A和B向对方的内网地址二元组发起的连接，这些连接或许会失败或者无法连接到对方。如同使用UDP协议进行“打洞”操作遇到的问题一样，TCP的“打洞”操作也会遇到内网的IP与“伪”公网IP重复造成连接失败或者错误连接之类的问题。</p>\n<p>客户端向彼此公网地址二元组发起连接的操作，会使得各自的NAT设备打开新的“洞”允许A与B的TCP数据通过。如果NAT设备支持TCP“打洞”操作的话，一个在客户端之间的基于TCP协议的流通道就会自动建立起来。如果A向B发送的第一个SYN包发到了B的NAT设备，而B在此前没有向A发送SYN包，B的NAT设备会丢弃这个包，这会引起A的“连接失败”或“无法连接”问题。而此时，由于A已经向B发送过SYN包，B发往A的SYN包将被看作是由A发往B的包的回应的一部分，所以B发往A的SYN包会顺利地通过A的NAT设备，到达A，从而建立起A与B的P2P连接。</p>\n<blockquote>\n<p>从应用程序的角度来看TCP“打洞”</p>\n</blockquote>\n<p>从应用程序的角度来看，在进行TCP“打洞”的时候都发生了什么呢？假定A首先向B发出SYN包，该包发往B的公网地址二元组，并且被B的NAT设备丢弃，但是B发往A的公网地址二元组的SYN包则通过A的NAT到达了A，然后，会发生以下的两种结果中的一种，具体是哪一种取决于操作系统对TCP协议的实现：</p>\n<p>（1）A的TCP实现会发现收到的SYN包就是其发起连接并希望联入的B的SYN包，通俗一点来说就是“说曹操，曹操到”的意思，本来A要去找B，结果B自己找上门来了。A的TCP协议栈因此会把B作为A向B发起连接connect的一部分，并认为连接已经成功。程序A调用的异步connect()函数将成功返回，A的listen()等待从外部联入的函数将没有任何反映。此时，B联入A的操作在A程序的内部被理解为A联入B连接成功，并且A开始使用这个连接与B开始P2P通信。</p>\n<p>由于收到的SYN包中不包含A需要的ACK数据，因此，A的TCP将用SYN-ACK包回应B的公网地址二元组，并且将使用先前A发向B的SYN包一样的序列号。一旦B的TCP收到由A发来的SYN-ACK包，则把自己的ACK包发给A，然后两端建立起TCP连接。简单的说，第一种，就是即使A发往B的SYN包被B的NAT丢弃了，但是由于B发往A的包到达了A。结果是，A认为自己连接成功了，B也认为自己连接成功了，不管是谁成功了，总之连接是已经建立起来了。</p>\n<p>（2）另外一种结果是，A的TCP实现没有像（1）中所讲的那么“智能”，它没有发现现在联入的B就是自己希望联入的。就好比在机场接人，明明遇到了自己想要接的人却不认识，误认为是其他的人，安排别人给接走了，后来才知道是自己错过了机会，但是无论如何，人已经接到了任务已经完成了。然后，A通过常规的listen()函数和accept()函数得到与B的连接，而由A发起的向B的公网地址二元组的连接会以失败告终。尽管A向B的连接失败，A仍然得到了B发起的向A的连接，等效于A与B之间已经联通，不管中间过程如何，A与B已经连接起来了，结果是A和B的基于TCP协议的P2P连接已经建立起来了。</p>\n<p>第一种结果适用于基于BSD的操作系统对于TCP的实现，而第二种结果更加普遍一些，多数Linux和Windows系统都会按照第二种结果来处理。</p>\n<h2 id=\"5、本文小结\"><a href=\"#5、本文小结\" class=\"headerlink\" title=\"5、本文小结\"></a>5、本文小结</h2><p>在IP地址极度短缺的今天，NAT几乎已经是无所不在的一项技术了，以至于现在任何一项新技术都不得不考虑和NAT的兼容。作为当下应用最广泛的技术之一，P2P技术也必然要面对NAT这个障碍。</p>\n<p>打洞技术看起来是一项近似乎蛮干的技术，却不失为一种有效的技术手段。在集中服务器的帮助下，P2P的双方利用端口预测的技术在NAT网关上打出通道，从而实现NAT穿越，解决了NAT对于P2P的阻隔，为P2P技术在网络中更广泛的推广作出了非常大的贡献。</p>"},{"title":"P2P技术详解(三)：P2P技术之STUN、TURN、ICE详解","date":"2018-09-06T09:28:06.000Z","_content":"\n## 1、内容概述\n\n在现实Internet网络环境中，大多数计算机主机都位于防火墙或NAT之后，只有少部分主机能够直接接入Internet。很多时候，我们希望网络中的两台主机能够直接进行通信，即所谓的P2P通信，而不需要其他公共服务器的中转。由于主机可能位于防火墙或NAT之后，在进行P2P通信之前，我们需要进行检测以确认它们之间能否进行P2P通信以及如何通信。这种技术通常称为NAT穿透（NAT Traversal）。最常见的NAT穿透是基于UDP的技术，如RFC3489中定义的STUN协议。\n\nSTUN，首先在RFC3489中定义，作为一个完整的NAT穿透解决方案，英文全称是Simple Traversal of UDP Through NATs，即简单的用UDP穿透NAT。\n\n在新的RFC5389修订中把STUN协议定位于为穿透NAT提供工具，而不是一个完整的解决方案，英文全称是Session Traversal Utilities for NAT，即NAT会话穿透效用。RFC5389与RFC3489除了名称变化外，最大的区别是支持TCP穿透。\n\nTURN，首先在RFC5766中定义，英文全称是Traversal Using Relays around NAT:Relay Extensions to Session Traversal Utilities for NAT，即使用中继穿透NAT:STUN的扩展。简单的说，TURN与STURN的共同点都是通过修改应用层中的私网地址达到NAT穿透的效果，异同点是TURN是通过两方通讯的“中间人”方式实现穿透。\n\nICE跟STUN和TURN不一样，ICE不是一种协议，而是一个框架（Framework），它整合了STUN和TURN。\n\n## 2、STUN详解\n\n了解STUN之前，我们需要了解NAT的种类。\n\nNAT对待UDP的实现方式有4种，分别如下：\n\n<!-- more -->\n\nFull Cone NAT：\n\n> 完全锥形NAT，所有从同一个内网IP和端口号发送过来的请求都会被映射成同一个外网IP和端口号，并且任何一个外网主机都可以通过这个映射的外网IP和端口号向这台内网主机发送包。\n\nRestricted Cone NAT：\n\n> 限制锥形NAT，它也是所有从同一个内网IP和端口号发送过来的请求都会被映射成同一个外网IP和端口号。与完全锥形不同的是，外网主机只能够向先前已经向它发送过数据包的内网主机发送包。\n\nPort Restricted Cone NAT：\n\n> 端口限制锥形NAT，与限制锥形NAT很相似，只不过它包括端口号。也就是说，一台IP地址X和端口P的外网主机想给内网主机发送包，必须是这台内网主机先前已经给这个IP地址X和端口P发送过数据包。\n\nSymmetric NAT：\n\n> 对称NAT，所有从同一个内网IP和端口号发送到一个特定的目的IP和端口号的请求，都会被映射到同一个IP和端口号。如果同一台主机使用相同的源地址和端口号发送包，但是发往不同的目的地，NAT将会使用不同的映射。此外，只有收到数据的外网主机才可以反过来向内网主机发送包。\n\n### 2.1 RFC3489/STUN\n\nSTUN（Simple Traversal of User Datagram Protocol Through Network Address Translators），即简单的用UDP穿透NAT，是个轻量级的协议，是基于UDP的完整的穿透NAT的解决方案。它允许应用程序发现它们与公共互联网之间存在的NAT和防火墙及其他类型。它也可以让应用程序确定NAT分配给它们的公网IP地址和端口号。STUN是一种Client/Server的协议，也是一种Request/Response的协议，默认端口号是3478。（IETF官方文档RFC3489/STUN点此进入）\n\n- 报文结构\n\n【Ø  消息头】\n\n所有的STUN消息都包含20个字节的消息头，包括16位的消息类型，16位的消息长度和128位的事务ID。\n\n![image](http://www.52im.net/data/attachment/forum/201610/12/112409m1f0zv1t36x1jfbf.png)\n\n消息类型许可的值如下：\n\n0x0001：捆绑请求\n\n0x0101：捆绑响应\n\n0x0111：捆绑错误响应\n\n0x0002：共享私密请求\n\n0x0102：共享私密响应\n\n0x0112：共享私密错误响应\n\n消息长度，是消息大小的字节数，但不包括20字节的头部。事务ID，128位的标识符，用于随机请求和响应，请求与其相应的所有响应具有相同的标识符。\n\n【Ø  消息属性】\n\n消息头之后是0或多个属性，每个属性进行TLV编码，包括16位的属性类型、16位的属性长度和变长属性值。\n\n![image](http://www.52im.net/data/attachment/forum/201610/12/112409kqyke5fxgkccfwqv.png)\n\n属性类型定义如下：\n\n- MAPPED-ADDRESS：MAPPED-ADDRESS属性表示映射过的IP地址和端口。它包括8位的地址族，16位的端口号及长度固定的IP地址。\n- RESPONSE-ADDRESS：RESPONSE-ADDRESS属性表示响应的目的地址\n- CHASNGE-REQUEST：客户使用32位的CHANGE-REQUEST属性来请求服务器使用不同的地址或端口号来发送响应。\n- SOURCE-ADDRESS：SOURCE-ADDRESS属性出现在捆绑响应中，它表示服务器发送响应的源IP地址和端口。\n- CHANGED-ADDRESS：如果捆绑请求的CHANGE-REQUEST属性中的“改变IP”和“改变端口”标志设置了，则CHANGED-ADDRESS属性表示响应发出的IP地址和端口号。\n- USERNAME：USERNAME属性用于消息的完整性检查，用于消息完整性检查中标识共享私密。USERNAME通常出现在共享私密响应中，与PASSWORD一起。当使用消息完整性检查时，可有选择地出现在捆绑请求中。\n- PASSWORD：PASSWORD属性用在共享私密响应中，与USERNAME一起。PASSWORD的值是变长的，用作共享私密，它的长度必须是4字节的倍数，以保证属性与边界对齐。\n- MESSAGE-INTEGRITY：MESSAGE-INTEGRITY属性包含STUN消息的HMAC-SHA1，它可以出现在捆绑请求或捆绑响应中；MESSAGE-INTEGRITY属性必须是任何STUN消息的最后一个属性。它的内容决定了HMAC输入的Key值。\n- ERROR-CODE：ERROR-CODE属性出现在捆绑错误响应或共享私密错误响应中。它的响应号数值范围从100到699。\n- UNKNOWN-ATTRIBUTES：UNKNOWN-ATTRIBUTES属性只存在于其ERROR-CODE属性中的响应号为420的捆绑错误响应或共享私密错误响应中。\n- REFLECTED-FROM：REFLECTED-FROM属性只存在于其对应的捆绑请求包含RESPONSE-ADDRESS属性的捆绑响应中。属性包含请求发出的源IP地址，它的目的是提供跟踪能力，这样STUN就不能被用作DOS攻击的反射器。\n\n具体的ERROR-CODE（响应号），与它们缺省的原因语句一起，目前定义如下：\n\n- 400（错误请求）：请求变形了。客户在修改先前的尝试前不应该重试该请求。\n- 401（未授权）：捆绑请求没有包含MESSAGE-INTERITY属性。\n- 420（未知属性）：服务器不认识请求中的强制属性。\n- 430（过期资格）：捆绑请求没有包含MESSAGE-INTEGRITY属性，但它使用过期\n的共享私密。客户应该获得新的共享私密并再次重试。\n- 431（完整性检查失败）：捆绑请求包含MESSAGE-INTEGRITY属性，但HMAC验\n证失败。这可能是潜在攻击的表现，或者客户端实现错误\n- 432（丢失用户名）：捆绑请求包含MESSAGE-INTEGRITY属性，但没有\nUSERNAME属性。完整性检查中两项都必须存在。\n- 433（使用TLS）：共享私密请求已经通过TLS（Transport Layer Security，即安全\n传输层协议）发送，但没有在TLS上收到。\n- 500（服务器错误）：服务器遇到临时错误，客户应该再次尝试。\n- 600（全局失败）：服务器拒绝完成请求，客户不应该重试。\n\n属性空间分为可选部分与强制部分，值超过0x7fff的属性是可选的，即客户或服务器即使不认识该属性也能够处理该消息；值小于或等于0x7fff的属性是强制理解的，即除非理解该属性，否则客户或服务器就不能处理该消息。\n\n> 实现原理\n\n![image](http://www.52im.net/data/attachment/forum/201610/12/112611tggg98eyyezpuqys.jpg)\n\nSTUN协议的完整交互过程如上，下面我们来介绍具体实现步骤。\n\n一般情况下，客户会配置STUN服务器提供者的域名，该域名被解析为IP地址和SRV过程的端口号。服务器名是“stun”，使用UDP协议发送捆绑请求，使用TCP协议发送共享私密请求。STUN协议的缺省端口号为3478。\n\n若要提供完整性检查，STUN在客户和服务器间使用128位的共享私密，作为在捆绑请求和捆绑响应中的密匙。\n\n首先，客户通过发现过程获得它将与之建立TCP连接的IP地址和端口号。客户打开该地址和端口的连接，开始TLS协商，验证服务器的标识。客户发送共享私密请求。该请求没有属性，只有头。服务器生成响应。\n\n客户会在该连接上生成多个请求，但在获得用户名和密码后关闭该连接。\n\n服务器收到共享私密请求，验证从TLS连接上到达的该请求；如果不是通过TLS收到的请求，则生成共享私密错误响应，并设置ERROR-CODE属性为响应号433；这里区分两种情况：若通过TCP收到请求，则错误响应通过收到请求的相同连接发送；若通过UDP收到请求，则错误响应发送回请求送出的源IP和端口。\n\n服务器检查请求中的任何属性，当其中有不理解的小于或等于0x7fff的值，则生成共享私密错误响应，设置ERROR-CODE属性为响应号420,并包括UNKNOWN-ATTRIBUTE属性，列出它不理解的小于或等于0x7fff的属性的值。该错误响应通过TLS连接发送。\n\n若请求正确，服务器创建共享私密响应，包含与请求中相同的事务ID，并包含USERNAME和PASSWORD属性。用户名在10分钟内有效。\n\n共享私密响应通过与收到请求的相同的TLS连接发送，服务器保持连接打开状态，由客户关闭它。\n\n接着，客户发送捆绑请求，携带的属性包括：\n\n- 可选属性：RESPONSE-ADDRESS属性和CHANGE-REQUEST属性；\n- 强制属性：MESSAGE-INTEGRITY属性和USERNAME属性。\n\n客户发送捆绑请求，通过客户重传来提供可靠性。客户开始用100ms的间隔重传，每次重传间隔加倍，直至1.6秒。之间间隔1.6秒的重传继续，直到收到响应或总共已经发送了9次。因此，若9500ms后，还未收到响应，客户认为传输已经失败。\n\n服务器检查捆绑请求的MESSAGE-INTEGRITY属性，不存在则生成捆绑错误响应，设置ERROR-CODE属性为响应号401；若存在，计算请求的HMACKey值。\n\n服务器检查USERNAME属性，不存在则生成捆绑错误响应，设置ERROR-CODE属性为响应号432；若存在，但不认识该USERNAME的共享私密（例如，它超时了），生成捆绑错误响应，设置ERROR-CODE属性为响应号430。\n\n若服务器知道该共享私密，但所计算的HMAC与请求的不同，生成捆绑错误响应，设置ERROR-CODE属性为响应号431。\n\n假设消息完整性检查通过了，服务器检查请求中的任何属性的值，若遇到不理解的小于或等于0x7fff的值，生成捆绑错误响应，设置ERROR-CODE属性为响应号420，该响应包含UNKNOWN-ATTRIBUTE属性，并列出不理解的小于或等于0x7fff的属性。\n\n若请求正确，服务器生成单个捆绑响应，包含与捆绑请求相同的事务ID。服务器在捆绑响应中加入MAPPED-ADDRESS属性，该属性的IP地址和端口号为捆绑请求的源IP地址和端口号。\n\n捆绑响应的源地址和端口号取决于捆绑请求中CHANGE-REQUEST属性的值及捆绑请求收到的地址和端口号相关。总结如下：\n\n![image](http://www.52im.net/data/attachment/forum/201610/12/112735tq1uhlhhll11qiux.png)\n\n服务器在捆绑响应中加入SOURCE-ADDRESS属性，包含用于发送捆绑响应的源地址和端口号；加入CHANGED-ADDRESS属性，包含源IP地址和端口号。\n\n如果捆绑请求中包含了USERNAME和MESSAGE-INTEGRITY属性，则服务器在捆绑响应中加入MESSAGE-INTEGRITY属性。\n\n如果捆绑请求包含RESPONSE-ADDRESS属性，则服务器在捆绑响应中加入REFLECTED-FROM属性：如果捆绑请求使用从共享私密请求获得的用户名进行认证，则REFLECTED-FROM属性包含共享私密请求到达的源IP地址和端口号；若请求中的用户名不是使用共享私密分配的，则REFLECTED-FROM属性包含获得该用户名的实体的源IP地址和端口号；若请求中没有用户名，且服务器愿意处理该请求，则REFLECTED-FROM属性包含请求发出的源IP地址和端口号。\n\n服务器不会重传响应，可靠性通过客户周期性地重发请求来保障，每个请求都会触发服务器进行响应。\n\n客户端判断响应的类型是捆绑错误响应还是捆绑响应。捆绑错误响应通常在请求发送的源地址和端口收到；捆绑响应通常在请求中的RESPONSE-ADDRESS属性的地址和端口收到，若没有该属性，则捆绑响应将在请求发送的源地址和端口号收到。\n\n- 若是捆绑错误响应，客户检查响应中的ERROR-CODE属性的响应号：400至499之间的未知属性按属性400处理，500至599之间的未知属性按500处理，600至699之间的未知属性按600处理。任何100和399之间的响应都会使请求重传中止，但其他则忽略；若客户收到响应的属性类型大于0x7fff，则忽略该属性，若小于或等于0x7fff，则请求重传停止，并忽略整个响应；\n- 若是捆绑响应，客户检查响应的MESSAGE-INTEGRITY属性：如果不存在，客户在请求中加入MESSAGE-INTEGRITY属性，并放弃该响应；如果存在，客户计算响应的HMAC。如果计算出的HMAC与响应中的不同，则放弃该响应，并警告客户可能受到了攻击；若计算出的HMAC与响应中的匹配，则过程继续；\n- 不论收到捆绑响应还是捆绑错误响应，都将中止该请求的重传。客户在第一次响应后继续监听捆绑请求的响应10秒钟，如果这期间它收到任何消息类型不同的响应或不同的MAPPED-ADDRESS属性，它将警告用户可能受到攻击；并且，如果客户收到的捆绑响应次数超过它发送的捆绑请求数的两倍，它将警告用户可能受到攻击；若捆绑响应经过认证，上述攻击并未导致客户丢弃MAPPED-ADDRESS，则客户可以使用该MAPPED-ADDRESS和SOURCE-ADDRESS属性。\n\n> STUN功能举例\n\n客户通过带外方式获得STUN服务器信息后，就打开对应的地址和端口的连接，并开始与STUN服务器进行TLS协商。一旦打开了连接，客户就通过TCP协议发送共享私密请求，服务器生成共享私密响应。STUN在客户和服务器间使用共享私密，用作捆绑请求和捆绑响应中的密匙。之后，客户使用UDP协议向STUN服务器发送捆绑请求，当捆绑请求消息到达服务器的时候，它可能经过了一个或者多个NAT。结果是STUN服务器收到的捆绑请求消息的源IP地址被映射成最靠近STUN服务器的NAT的IP地址，STUN服务器把这个源IP地址和端口号复制到一个捆绑响应消息中，发送回拥有这个IP地址和端口号的客户端。\n\n当STUN客户端收到捆绑响应消息之后，它会将自己发送捆绑请求时绑定的本地IP地址和端口号同捆绑响应消息中的IP地址和端口号进行比较，如果不匹配，就表示客户端正处于一个或者多个NAT的前面。\n\n在Full-Cone NAT的情况下，在捆绑响应消息中的IP地址和端口是属于公网的，公网上的任何主机都可以使用这个IP地址和端口号向这个应用程序发送数据包，应用程序只需要在刚才发送捆绑请求的IP地址和端口上监听即可。\n\n当然，客户可能并不在一个Full-Cone NAT的前面，实际上，它并不知道自己在一个什么类型的NAT的前面。为了确定NAT的类型，客户端使用附加的捆绑请求。具体过程是很灵活的，但一般都会像下面这样工作：客户端再发送一个捆绑请求，这次发往另一个IP地址，但是使用的是跟上一次同一个源IP地址和源端口号，如果返回的数据包里面的IP地址和端口号和第一次返回的数据包中的不同，客户端就会知道它是在一个对称NAT的前面。客户端为了确认自己是否在一个完全锥形NAT的前面，客户端可以发送一个带有标志的捆绑请求，这个标志告诉服务器使用另一个IP地址和端口发送捆绑响应。换句话说，如果客户端使X/Y的IP地址端口对向A/B的IP地址端口对发送捆绑请求，服务器就会使用源IP地址和源端口号为C/D的地址端口对向X/Y发送捆绑响应。如果客户端收到了这个响应，它就知道它是在一个Full-Cone NAT前面。\n\nSTUN协议允许客户端请求服务器从收到捆绑请求的IP地址往回发捆绑响应，但是要使用不同的端口号。这可以用来检查客户端是否在Port Restricted Cone NAT的前面还是在Restricted Cone NAT的前面。\n\n### 2.2 RFC5389/STUN\n\nSTUN协议在RFC5389中被重新命名为Session Traversal Utilities for NAT，即NAT会话穿透效用。在这里，NAT会话穿透效用被定位为一个用于其他解决NAT穿透问题协议的协议。它可以用于终端设备检查由NAT分配给终端的IP地址和端口号。同时，它也被用来检查两个终端之间的连接性，好比是一种维持NAT绑定表项的保活协议。STUN可以用于多种NAT类型，并不需要它们提供特殊的行为。\n\nSTUN本身不再是一种完整的NAT穿透解决方案，它相当于是一种NAT穿透解决方案中的工具。这是与RFC3489/STUN版本相比最重要的改变。\n\n> STUN用途\n\n目前定义了三种STUN用途：\n\n- Interactive Connectivity Establishment（ICE）[MMUSIC-ICE]，交互式连接建立\n- Client-initiated connections for SIP [SIP-OUTBOUND]，用于SIP的客户端初始化连接\n- NAT Behavior Discovery [BEHAVE-NAT]，NAT行为发现\n\n> 报文结构\n\n【Ø  消息头】\n\nSTUN消息头为20字节，后面紧跟0或多个属性。STUN头部包含一STUN消息类型、magic cookie、事务ID和消息长度。\n\n![image](http://www.52im.net/data/attachment/forum/201610/12/114036v0l0xcxjj6l6lc94.png)\n\n每个STUN消息的最高位前2位必须为0。当STUN协议为多个协议多路复用时若使用的是同一个端口，这可以用于与其他协议区分STUN数据包。消息类型确定消息的类别（如请求、成功回应、失败回应、标志）。虽然这里有四种消息类型，但可以分为2类事务：请求/响应事务、标志事务。\n\n消息类型字段可进一步划分为下面结构：\n\n![image](http://www.52im.net/data/attachment/forum/201610/12/113902e1ci02g21bks8cmf.png)\n\n消息类型定义如下：\n\n- 0b00，表示请求\n- 0b01，表示标志\n- 0b10，表示成功响应\n- 0b11，表示错误响应\n\n魔术字域必须包含固定的值0x2112A442。在RFC3489中，该域是事务ID的一部分。配置魔术字允许服务器检测客户是否理解某些在改进的版本中增加的属性。另外，还可用于STUN多路复用时与其他协议的包进行区分。\n\n96位的事务ID用于唯一的识别STUN事务。对于请求/响应事务，事务ID由STUN客户端来选择；对于标志事务，由代理（代理指支持STUN的客户端或服务器）来选择并发送。它主要服务于与请求相关的响应，因此它也扮演着一个帮助阻止确定类型的攻击的角色。服务器使用事务ID来唯一的标识出所有客户端的每一个事务。事务ID本身必须是唯一的，并且随机的从0到2的96-1次方中选择。重新发送相同的请求时，也必须使用新的事务ID。成功或错误响应必须携带与相对应的请求相同的事务ID。\n\n消息长度字段不包括20字节的STUN头部。所有的STUN属性必须填充为4字节的倍数。消息长度字段的最后2位总是为0，这为区分STUN包与其他协议的包提供了另外一种方法。\n\n【Ø  消息属性】\n\nSTUN头之后是0或多个属性。每个属性都采用TLV编码，16位的类型、16位的长度及可变长度的值。每个STUN属性必须是4字节边界对齐。\n\n![image](http://www.52im.net/data/attachment/forum/201610/12/114019vcfzuicfi6vumdfz.png)\n\n属性空间被划分为2个范围。属性的类型值在0x0000到0x7fff是强制理解属性，这意味着除非STUN代理能够理解这些属性，否则将不能正常处理包含该属性的消息；属性的类型值在0x8000到0xffff范围是可选理解属性，这意味着如果STUN代理不能理解它们的话这些属性可以被忽略。\n\nSTUN属性类型集由IANA维护，具体定义详见IETF官方文档 RFC5389。\n\n### 2.3 RFC5389与RFC3489的区别\n\nRFC5389与RFC3489的不同点如下：\n\n- 去掉STUN是一种完整的NAT穿透方案的概念，现在是一种用于提供NAT穿透解决方案的工具。因而，协议的名称变为NAT会话穿透效用；\n- 定义了STUN的用途；\n- 去掉了STUN关于NAT类型检测和绑定生命期发现的用法，去掉了RESPONSE-ADDRESS、CHANGED-ADDRESS、CHANGE-REQUEST、SOURCE-ADDRESS和REFLECTED-FROM属性；\n- 增加了一个固定的32位的魔术字字段，事务ID字段减少了32位长度；\n- 增加了XOR-MAPPED-ADDRESS属性，若魔术字在捆绑请求中出现时，该属性包括在捆绑响应中。否则，RFC3489中的行为是保留的（换句话说，捆绑响应中包括MAPPED-ADDRESS）；\n- 介绍了消息类型字段的正式结构，带有一对明确的位来标识Request、Response、Error-Response或Indication消息。因此，消息类型字段被划分为类别和方法两部分；\n- 明确的指出了STUN的最高2位是0b00，当用于ICE时可以简单的与RTP包区分开来；\n- 增加指纹属性来提供一种明确的方法来检测当STUN协议多路复用时，STUN与其他协议之间的差异；\n- 增加支持IPv6，IPv4客户端可以获取一个IPv6映射地址，反之亦然；\n- 增加一个long-term-credential-based认证机制；\n- 增加了SOFTWARE、REALM、NONCE和ALTERNATE-SERVER属性；\n- 去掉了共享密匙方法，因此PASSWORD属性也去掉了；\n- 去掉了使用连续10秒侦听STUN响应来识别一个攻击的做法；\n- 改变事务计时器来增加TCP友好性；\n- 去掉了STUN例子如集中分离控制和媒体面，代替的，在使用STUN协议时提供了更多的信息；\n- 定义了一类填充机制来改变长度属性的说明；\n- REALM、SERVER、原因语句和NONCE限制在127个字符，USERNAME限制在513个字节以内；\n- 为TCP和TLS改变了DNS SRV规程，UDP仍然和以前保持一致。\n\nIETF官文档，详见：RFC5389、RFC3489。\n\n### 2.4 新特性介绍\n\n> 指纹机制\n\nFINGERPRINT机制是一种可选的用于其他协议多路复用STUN时发送给相同的传输地址时区分STUN数据包的机制，该机制不支持与RFC3489相兼容。\n\n在一些用途中，基于相同的传输地址时多个协议会多路复用STUN消息，例如RTP协议。STUN消息必须首先和应用报文分离开。目前，在STUN报头中有3种固定的字段可以用于该目的。尽管如此，在一些案例中，三种固定字段仍然不能充分的区别开。\n\n当扩展的指纹机制被使用时，STUN代理在发送给其他STUN代理的消息中包括FINGERPRINT属性。当其他STUN代理收到时，除基本的检查之外，还将检查是否包含FINGERPRINT属性及它是否包含正确的值，至此，它将相信这是一个STUN消息。指纹机制帮助STUN代理检查其他协议那些看起来像是STUN消息的消息。\n\n> 通过DNS发现服务器机制\n\nSTUN客户端可以使用DNS来发现STUN服务器的IP地址和端口。客户端必须知道服务器的域名。\n\n当客户端希望找出服务器在公网上的位置就采用捆绑请求/响应事务，SRV（资源记录表）中服务器名称是“stun”。当通过TLS会话采用捆绑请求/响应事务，SRV中服务器名称为“stuns”。STUN用户可以定义额外的DNS资源记录服务名称。\n\nSTUN请求的默认端口是3478，用于TCP和UDP。STUN在TLS上的默认端口是5349。服务器能够在TLS上运行STUN与STUN在TCP上时使用相同的端口，只有服务器软件支持决定初始消息是否是TLS或STUN消息。\n\n如果SRV中没有记录可查，客户端执行A或AAAA记录查找域名。结果将会是1张IP地址表，每一个都可以使用TCP或UDP采用默认端口号连接。通常要求使用TLS，客户端使用STUN在TLS上的默认端口号连接其中一个IP地址。\n\n> 认证和消息完整性机制\n\n- 短期证书机制\n\n短期证书机制假设在STUN事务之前，客户端和服务器已经使用了其他协议来交换了证书，以username和password形式。这个证书是有时间限制的。例如，在ICE用途中，两个终端使用带外方式交换信息来对username和password达成一致，并在媒体会话期间使用。这个证书被用来进行消息完整性检查，用于每个请求和多个响应中。与长期证书机制相比，没有挑战和响应方式，因此，这种证书的时间限制特性的优点是可以阻止重播。\n\n- 长期证书机制\n\n长期证书机制依赖于一个长期证书，username和password在客户端和服务器中是共用的。这个证书从它提供给 用户开始将一直是有效的，直到该用户不再是该系统的用户。这本质上是一个提供给用户username和password的传统的登入方式。    \n\n客户端初始发送一个请求，没有提供任何证书和任何完整性检测。服务器拒绝这个请求，并提供给用户一个范围（用于指导用户或代理选择username和password）和一个nonce。这个nonce提供重放保护。它是一个cookie，由服务器选择，以这样一种方式来标示有效时间或客户端身份是有效的。客户端重试这个请求，这次包括它的username和realm和服务器提供的nonce来回应。服务器确认这个nonce和检查这个message integrity。如果它们匹配，请求则通过认证。如果这个nonce不再有效，即过期了，服务器就拒绝该请求，并提供一个新的nonce。\n\n在随后的到同一服务器的请求，客户端重新使用这个nonce、username和realm，和先前使用的password。这样，随后的请求不会被拒绝直到这个nonce变成无效的。需要注意的是，长期证书机制不能用来保护Indications，由于Indications不能被改变，因此，使用Indications时要么使用短期证书，要么就省略认证和消息完整性。因为长期证书机制对离线字典攻击敏感，部署的时候应该使用很难猜测的密码。\n\n> 备份服务器机制\n\n服务器使用增强的重定向功能将一个客户端转向另一个服务器，通过回应一个错误响应号为300（尝试备份）的错误响应。服务器在错误响应中携带一个ALTERNATE-SERVER属性。\n\n客户端收到错误响应号为300的错误响应后，在该响应中查找ALTERNATE-SERVER属性。若找到一个，客户端就会将当前的事务作废，并重新尝试发送请求到该属性中列出的服务器。请求报文若已经通过认证，则必须使用与先前发送给执行重定向操作的服务器同样的证书。如果客户端在最后5分钟里已经重试发送请求时已经重定向到了一个服务器，它必须忽略重定向操作并将当前的事务作废，这是为了防止无限的重定向循环。\n\n### 2.5 RFC5389与RFC3489的兼容\n\n在RFC3489中：\n\n- UDP是唯一支持的传输协议\n- RFC5389中的魔术字字段是RFC3489中事务ID的一部分，事务ID长128位\n- 没有XOR-MAPPED-ADDRESS属性，绑定方法是使用MAPPED-ADDRESS属性代替\n- 有3个需要强制理解的属性，分别是：RESPONSE-ADDRESS、CHANGE-REQUEST、CHANGED-ADDRESS属性，而RFC5389中不再支持这些属性。\n\n> 客户端处理的改变\n\n客户端想要与RFC3489的服务器互操作，应发送一个使用绑定方法的请求消息，不包含任何消息，使用UDP协议发送给服务器。如果成功，将收到服务器发回的包含MAPPED-ADDRESS属性而不是XOR-MAPPED-ADDRESS属性的成功响应。客户端试图与基于RFC3489的应用服务器互操作必须准备好接收任意一个属性。此外，客户端必须忽略任何在响应中出现的保留的强制理解的属性。RFC3489中规定保留属性中的0x0002、0x0004、0x0005和0x000B可能出现在绑定响应中。\n\n> 服务器处理的改变\n\n服务器能够察觉由RFC3489中的客户端发送的携带有不正确的魔术字的捆绑请求消息。当服务器察觉到RFC3489中的客户端，它应该将捆绑请消息中魔术字域中的值拷贝到捆绑响应中的魔术字字段中，并且插入一个MAPPED-ADDRESS属性代替XOR-MAPPED-ADDRESS属性。\n\n客户端在极少的环境下可能包括RESPONSE-ADDRESS或CHANGE-REQUEST属性中的一个。在这些情况下，服务器把这些属性看做是一个不认识的强制理解的属性，并回应一个错误响应。RFC3489版本中的STUN缺少魔术字和指纹属性这两种能够高可靠性的正确标识其他协议多路复用时的STUN消息。因此，STUN执行与RFC3489兼容时不应该被用于多个协议。\n\n## 3、TURN详解\n\n### 3.1 RFC5766/TURN\n\nTURN，在RFC5766中定义，英文全称Traversal Using Relays around NAT（TURN）：Relay Extensions to Session Traversal Utilities for NAT（STUN），即使用中继穿透NAT：STUN的中继扩展。简单的说，TURN与STUN的共同点都是通过修改应用层中的私网地址达到NAT穿透的效果，异同点是TURN是通过两方通讯的“中间人”方式实现穿透。\n\n如果一个主机位于NAT的后面，在某些情况下它不能够与其他主机点对点直接连接。在这些情况下，它需要使用中间网点提供的中继连接服务。TURN协议就是用来允许主机控制中继的操作并且使用中继与对端交换数据。TURN与其他中继控制协议不同的是它能够允许一个客户端使用一个中继地址与多个对端连接。\n\nTURN协议被设计为ICE的一部分，用于NAT穿越，虽然如此，它也可以在没有ICE的地方单独使用。\n\n### 3.2 操作概述\n\n![image](http://www.52im.net/data/attachment/forum/201610/12/115151bn2gxe2p96x612x2.jpg)\n\n在一个典型组网中，一个TURN客户端连接在一个私有网络中，通过一个或多个NAT来连接到公网。在公网中有一个TURN服务器。在因特网的别处有一个或多个对端是这个TURN客户端希望通讯的。这些对端也有可能是在一个或多个NAT的后面。该客户端使用服务器作为一个中继来发送数据包 到这些对端去，并且从这些对端接收数据包。\n\n客户端通过一个IP地址和端口的组合来与服务器建立会话。客户端使用TURN命令在服务器上创建和操作一个ALLOCATION。一旦这个allocation创建好了，客户端能够在数据发往哪个对端的指示下发送应用数据到这个服务器，服务器将中继这些数据到合适的对端。客户端发送的应用数据包含在TURN消息中，服务器将数据提取出来，并以UDP数据包方式发送给对端。反向上，对端以UDP数据包方式发送应用数据到这个allocation提供的中继传输地址。因为TURN消息总是包含客户端与哪些对端通讯的指示，客户端能够使用单一的allocation来与多个对端通讯。\n\n### 3.3 术语\n\n- TURN client：遵循RFC5766的STUN客户端。\n- TURN server：遵循RFC5766的STUN服务器。\n- Peer：TURN客户端希望连接的主机。TURN服务器为TURN客户端和它的对端中继流量，但Peer并不与TURN服务器使用TURN协议进行交互，它接收从TURN服务器发送过来的数据，并向TURN服务器发送数据。\n- Transport Address：IP地址与端口号的组合。\n- Host Transport Address：客户端或对端的传输地址。\n- Server-Reflexive Transport Address：NAT公网侧的传输地址，该地址由NAT分配，相当于一个特定的主机传输地址。\n- Relayed Transport Address：TURN服务器上的传输地址，用于客户端和对端中继数据。\n- TURN Server Transport Address：TURN服务器上的传输地址，用于客户端发送STUN消息给服务器。\n- Peer Transport Address：服务器看到的对端的传输地址，当对端是在NAT后面，则是对端的服务器反射传输地址。\n- Allocation：通过Allocate请求将中继传输地址提供给客户端，除了中继状态外，还有许可和超时定时器等。\n- 5-tuple：五元组，包括客户端IP地址和端口，服务器IP地址和端口和传输协议（包括UDP、TCP、TLS）的组合。\n- Channel：通道号与对端传输地址的关联，一旦一个通道号与一个对端的传输地址绑定，客户端和服务器就能够利用带宽效应更大的通道数据消息来交换数据。\n- Permission：一个对端允许使用它的IP地址和传输协议来发送数据到TURN服务器，服务器只为从对端发来的并且匹配一个已经存在的许可的流量中继到相应的客户端。\n- Realm：服务器内用于描述服务器或内容的一个字符串，这个realm告诉客户端哪些用户名和密码的组合可用于认证请求。\n- Nonce：服务器随机选择的一个字符串，包含在报文摘要中。为了防止中继攻击，服务器应该有规律的改变这个nonce。\n\n具体协议细节，详见IETF官方文档：RFC5766.\n\n### 3.4 协议交互过程详细举例\n\n以上图为例进行讲解，每个消息中，多个属性包含在消息中并显示它们的值。为了方便阅读，值以人们可读的格式来显示。\n\n![image](http://www.52im.net/data/attachment/forum/201610/12/115958r41hgy1uht78nazu.jpg)\n\n客户端使用10.1.1.2:49271作为传输地址向服务器的传输地址发送Allocate请求。客户端随机选择一个96位的事务ID。该Allocate请求消息包括SOFTWARE属性来提供客户端的软件版本信息；包括LIFETIME属性，指明客户端希望该allocation具有1小时的生命期而非缺省的10分钟；包括REQUESTED-TRANSPORT属性来告诉服务器与对端之间采用UDP协议来传输；包括DONT-FRAGMENT属性因为客户端希望在随后的Send indications中使用DON’T-FRAGMENT属性。\n\n服务器需要任何请求必须是经过认证的，因此服务器拒绝了该最初的Allocation请求，并且回应了携带有错误响应号为401（未授权）的Allocate错误响应；该响应包括一个REALM属性，指明认证的域；还包括一个NONCE属性和一个SOFTWARE属性。\n\n客户端收到了错误响应号为401的Allocate错误响应，将重新尝试发送Allocate请求，此时将包括认证属性。客户端在新的请求中重新选择一个新的事务ID。客户端包括一个USERNAME属性，使用从服务器那收到的realm值来帮助它决定使用哪个值；请求还包括REALM和NONCE属性，这两个属性是从收到的错误响应中拷贝出来的。最后，客户端包括一个MESSAGE-INTEGRITY属性。\n\n服务器收到认证的Allocate请求后，检查每个属性是否正确；然后，产生一个allocation，并给客户端回应Allocate成功响应。服务器在该成功响应中携带一个LIFETIME属性，本例中服务器将客户端请求的1小时生命期减小为20分钟，这是因为这个特定的服务器可能不允许超过20分钟的生命期；该响应包括XOR-RELAYED-ADDRESS属性，值为该allocation的中继传输地址；该响应还包括XOR-MAPPED-ADDRESS属性，值为客户端的server-reflexive地址；该响应也包含一个SOFTWARE属性；最后，包括一个MESSAGE-INTEGRITY属性来证明该响应，确保它的完整性。\n\n![image](http://www.52im.net/data/attachment/forum/201610/12/120031zi6vsrvx24ssg42i.jpg)\n\n接着，客户端为了准备向对端A发送一些应用数据而创建一个permission。这里通过一个CreatePermission请求来做到。该请求携带XOR-PEER-ADDRESS属性包含有确定的请求的IP地址，这里为对端A的地址；需要注意的是，属性中地址的端口号被设置为0在CreatePermission请求中，并且客户端使用的是对端A的server-reflexive地址而不是它的主机地址（私网地址）；客户端在该请求中携带与之前的Allocate请求中一样的username、realm和nonce值，因此该请求被服务器认可。此时在该请求中，客户端没有携带SOFTWARE属性。\n\n服务器收到该CreatePermission请求，产生一个相应的许可，并以CreatePermission成功响应来回应。该响应中只包含了Transaction-ID和MESSAGE-INTEGRITY属性。\n\n![image](http://www.52im.net/data/attachment/forum/201610/12/120053ks33633olaxnpi4l.jpg)\n\n现在客户端使用Send indication来发送应用数据到对端A。对端的server-reflexive传输地址包含在XOR-PEER-ADDRESS属性中，应用数据包含在DATA属性中。客户端已经在应用层上执行了路径MTU发现功能，因此通过DON’T-FRAGMENT属性来告知服务器当通过UDP方式来向对端发送数据时应设置DF位。Indications不能使用长期证书机制来认证，所以该消息中没有MESSAGE-INTEGRITY属性。\n\n服务器收到Send indication后，提取出应用数据封装成UDP格式发给对端A；UDP报文的源传输地址为中继传输地址，并设置DF位。\n\n对端A回应它自己的包含有应用数据的UDP包给服务器。目的地址为服务器的中继传输地址。当服务器收到后，将生成Data indication消息给客户端，携带有XOR-PEER-ADDRESS属性。应用数据包含在DATA属性中。\n\n![image](http://www.52im.net/data/attachment/forum/201610/12/120117zf5gi0ka7fw5o57e.jpg)\n\n客户端现在若要绑定一个通道到对端B，将指定一个空闲的通道号（本例中为0x4000）包含在CHANNEL-NUMBER属性中，对端B的传输地址包含在XOR-PEER-ADDRESS属性中。与以前一样，客户端再次利用上次请求中的username、realm和nonce。\n\n当服务器收到该请求后，服务器绑定这个对端的通道号，为对端B的IP地址安装一个permission，然后给客户端回应一个ChannelBind成功响应消息。\n\n![image](http://www.52im.net/data/attachment/forum/201610/12/120134g98040e74ziwfiwz.jpg)\n\n客户端现在发送一个ChannelData消息给服务器，携带有发送给对端B的数据。这个消息不是一个STUN消息，因此没有事务ID。它之有3个字段：通道号、数据、数据长度；服务器收到后，检查通道号后发现当前已经绑定了，就以UDP方式发送数据给对端B。\n\n接着，对端B发送UDP数据包回应给服务器的中继传输地址。服务器收到后，回应给客户端ChannelData消息，包含UDP数据包中的数据。服务器知道是给哪个客户端发送ChannelData消息，这是因为收到的UDP数据包中的目的地址（即服务器的中继传输地址），并且知道使用的是哪个通道号，这是因为通道已经与相应的传输地址绑定了。\n\n![image](http://www.52im.net/data/attachment/forum/201610/12/120157sixfnelrqciqexgd.jpg)\n\n有时候，20分钟的生命期已经到了，客户端需要刷新allocation。此时通过发送Refresh请求来进行。该请求包含最后一次使用的username、realm和nonce，还包含SOFTWARE属性。当服务器收到这个Refresh请求时，它注意到这个nonce值已经超期了，则给客户端回应一个错误响应号为438（过期Nonce）的Refresh错误响应，并提供一个新的nonce值。可护端将重试该请求，此时携带新的nonce值。若第二次尝试被接受，服务器将回应一个成功响应。需要注意的是，此时客户端在请求中没有携带LIFETIME属性，所以服务器刷新客户端的allocation时采用缺省的10分钟生命期。\n\n## 4、ICE简明介绍\n\n### 4.1 简介\n\nICE的全称Interactive Connectivity Establishment（互动式连接建立），由IETF的MMUSIC工作组开发出来的，它所提供的是一种框架，使各种NAT穿透技术可以实现统一。ICE跟STUN和TURN不一样，ICE不是一种协议，而是一个框架（Framework），它整合了STUN和TURN。\n\n### 4.2 应用模型\n\n![image](http://www.52im.net/data/attachment/forum/201610/12/120427sj60zrara770aql5.png)\n\n如上图所示，如果A想与B通信，那么其过程如下：\n\n- A收集所有的IP地址，并找出其中可以从STUN服务器和TURN服务器收到流量的地址；\n- A向STUN服务器发送一份地址列表，然后按照排序的地址列表向B发送启动信息，目的是实现节点间的通信；\n- B向启动信息中的每一个地址发送一条STUN请求；\n- A将第一条接收到的STUN请求的回复信息发送给B；\n- B接到STUN回复后，从中找出那些可在A和B之间实现通信的地址；\n- 用列表中的排序列最高的地址进一步的设备间通信。\n\n由于该技术是建立在多种NAT穿透协议的基础之上，并且提供了一个统一的框架，所以ICE具备了所有这些技术的优点，同时还避免了任何单个协议可能存在的缺陷。因此，ICE可以实现在未知网络拓扑结构中实现的设备互连，而且不需要进行对手配置。另外，由于该技术不需要为VoIP流量手动打开防火墙，所以也不会产生潜在的安全隐患。\n\n## 5、本文总结\n\n在现实Internet网络环境中，大多数计算机主机都位于防火墙或NAT之后，只有少部分主机能够直接接入Internet。很多时候，我们希望网络中的两台主机能够直接进行通信（即所谓的P2P通信），而不需要其它公共服务器的中转。由于主机可能位于防火墙或NAT之后，在进行P2P通信之前，我们需要进行检测以确认它们之间能否进行P2P通信以及如何通信。这种技术通常被称为NAT穿透（NAT Traversal）。\n\nRFC3489中定义的STUN，即简单地用UDP穿过NAT（STUN）是个轻量级的协议。它允许应用发现它们与公共互联网之间存在的NAT和防火墙及其他类型。它还为应用提供判断NAT给它们分配的公共网际协议（IP）地址。STUN可工作在许多现存NAT上，并且不需要它们做任何特别的行为。它允许广泛的各类的应用穿越现存的NAT设施。\n\nRFC5389中对STUN协议进行了修订，将其定位于为穿透NAT提供工具，即NAT会话穿透效用是一个用于其他解决NAT穿透问题协议的协议。它可以用于终端设备检查由NAT分配给终端的IP地址和端口号。同时，它也被用来检查两个终端之间的连接性，好比是一种维持NAT绑定表项的保活协议。STUN本身并不是一种完整的NAT穿透解决方案。它相当于是一种NAT穿透解决方案中的工具。这是与先前的版本相比最重要的改变。之前的RFC3489中定义的STUN是一个完整的穿透NAT解决方案。此外，最大的区别是支持TCP穿透。\n\nRFC5766中对STUN协议再次进行了扩展，即中继穿透NAT：STUN的扩展。TURN与STUN的共同点都是通过修改应用层中的私网地址达到NAT穿透的效用，异同点是TUN采用了两方通讯的“中间人”方式实现穿透，突破了原先STUN协议无法在两台主机不能够点对点直接连接下提供作用的限制。\n\n技术无止境，NAT穿透技术仍在不断更新中，这里只对STUN/TURN协议作了简单的介绍，具体细节请参考RFC3489/5389/5766。\n","source":"_posts/p2p3.md","raw":"---\ntitle: P2P技术详解(三)：P2P技术之STUN、TURN、ICE详解\ndate: 2018-09-06 17:28:06\ntags: p2p\n---\n\n## 1、内容概述\n\n在现实Internet网络环境中，大多数计算机主机都位于防火墙或NAT之后，只有少部分主机能够直接接入Internet。很多时候，我们希望网络中的两台主机能够直接进行通信，即所谓的P2P通信，而不需要其他公共服务器的中转。由于主机可能位于防火墙或NAT之后，在进行P2P通信之前，我们需要进行检测以确认它们之间能否进行P2P通信以及如何通信。这种技术通常称为NAT穿透（NAT Traversal）。最常见的NAT穿透是基于UDP的技术，如RFC3489中定义的STUN协议。\n\nSTUN，首先在RFC3489中定义，作为一个完整的NAT穿透解决方案，英文全称是Simple Traversal of UDP Through NATs，即简单的用UDP穿透NAT。\n\n在新的RFC5389修订中把STUN协议定位于为穿透NAT提供工具，而不是一个完整的解决方案，英文全称是Session Traversal Utilities for NAT，即NAT会话穿透效用。RFC5389与RFC3489除了名称变化外，最大的区别是支持TCP穿透。\n\nTURN，首先在RFC5766中定义，英文全称是Traversal Using Relays around NAT:Relay Extensions to Session Traversal Utilities for NAT，即使用中继穿透NAT:STUN的扩展。简单的说，TURN与STURN的共同点都是通过修改应用层中的私网地址达到NAT穿透的效果，异同点是TURN是通过两方通讯的“中间人”方式实现穿透。\n\nICE跟STUN和TURN不一样，ICE不是一种协议，而是一个框架（Framework），它整合了STUN和TURN。\n\n## 2、STUN详解\n\n了解STUN之前，我们需要了解NAT的种类。\n\nNAT对待UDP的实现方式有4种，分别如下：\n\n<!-- more -->\n\nFull Cone NAT：\n\n> 完全锥形NAT，所有从同一个内网IP和端口号发送过来的请求都会被映射成同一个外网IP和端口号，并且任何一个外网主机都可以通过这个映射的外网IP和端口号向这台内网主机发送包。\n\nRestricted Cone NAT：\n\n> 限制锥形NAT，它也是所有从同一个内网IP和端口号发送过来的请求都会被映射成同一个外网IP和端口号。与完全锥形不同的是，外网主机只能够向先前已经向它发送过数据包的内网主机发送包。\n\nPort Restricted Cone NAT：\n\n> 端口限制锥形NAT，与限制锥形NAT很相似，只不过它包括端口号。也就是说，一台IP地址X和端口P的外网主机想给内网主机发送包，必须是这台内网主机先前已经给这个IP地址X和端口P发送过数据包。\n\nSymmetric NAT：\n\n> 对称NAT，所有从同一个内网IP和端口号发送到一个特定的目的IP和端口号的请求，都会被映射到同一个IP和端口号。如果同一台主机使用相同的源地址和端口号发送包，但是发往不同的目的地，NAT将会使用不同的映射。此外，只有收到数据的外网主机才可以反过来向内网主机发送包。\n\n### 2.1 RFC3489/STUN\n\nSTUN（Simple Traversal of User Datagram Protocol Through Network Address Translators），即简单的用UDP穿透NAT，是个轻量级的协议，是基于UDP的完整的穿透NAT的解决方案。它允许应用程序发现它们与公共互联网之间存在的NAT和防火墙及其他类型。它也可以让应用程序确定NAT分配给它们的公网IP地址和端口号。STUN是一种Client/Server的协议，也是一种Request/Response的协议，默认端口号是3478。（IETF官方文档RFC3489/STUN点此进入）\n\n- 报文结构\n\n【Ø  消息头】\n\n所有的STUN消息都包含20个字节的消息头，包括16位的消息类型，16位的消息长度和128位的事务ID。\n\n![image](http://www.52im.net/data/attachment/forum/201610/12/112409m1f0zv1t36x1jfbf.png)\n\n消息类型许可的值如下：\n\n0x0001：捆绑请求\n\n0x0101：捆绑响应\n\n0x0111：捆绑错误响应\n\n0x0002：共享私密请求\n\n0x0102：共享私密响应\n\n0x0112：共享私密错误响应\n\n消息长度，是消息大小的字节数，但不包括20字节的头部。事务ID，128位的标识符，用于随机请求和响应，请求与其相应的所有响应具有相同的标识符。\n\n【Ø  消息属性】\n\n消息头之后是0或多个属性，每个属性进行TLV编码，包括16位的属性类型、16位的属性长度和变长属性值。\n\n![image](http://www.52im.net/data/attachment/forum/201610/12/112409kqyke5fxgkccfwqv.png)\n\n属性类型定义如下：\n\n- MAPPED-ADDRESS：MAPPED-ADDRESS属性表示映射过的IP地址和端口。它包括8位的地址族，16位的端口号及长度固定的IP地址。\n- RESPONSE-ADDRESS：RESPONSE-ADDRESS属性表示响应的目的地址\n- CHASNGE-REQUEST：客户使用32位的CHANGE-REQUEST属性来请求服务器使用不同的地址或端口号来发送响应。\n- SOURCE-ADDRESS：SOURCE-ADDRESS属性出现在捆绑响应中，它表示服务器发送响应的源IP地址和端口。\n- CHANGED-ADDRESS：如果捆绑请求的CHANGE-REQUEST属性中的“改变IP”和“改变端口”标志设置了，则CHANGED-ADDRESS属性表示响应发出的IP地址和端口号。\n- USERNAME：USERNAME属性用于消息的完整性检查，用于消息完整性检查中标识共享私密。USERNAME通常出现在共享私密响应中，与PASSWORD一起。当使用消息完整性检查时，可有选择地出现在捆绑请求中。\n- PASSWORD：PASSWORD属性用在共享私密响应中，与USERNAME一起。PASSWORD的值是变长的，用作共享私密，它的长度必须是4字节的倍数，以保证属性与边界对齐。\n- MESSAGE-INTEGRITY：MESSAGE-INTEGRITY属性包含STUN消息的HMAC-SHA1，它可以出现在捆绑请求或捆绑响应中；MESSAGE-INTEGRITY属性必须是任何STUN消息的最后一个属性。它的内容决定了HMAC输入的Key值。\n- ERROR-CODE：ERROR-CODE属性出现在捆绑错误响应或共享私密错误响应中。它的响应号数值范围从100到699。\n- UNKNOWN-ATTRIBUTES：UNKNOWN-ATTRIBUTES属性只存在于其ERROR-CODE属性中的响应号为420的捆绑错误响应或共享私密错误响应中。\n- REFLECTED-FROM：REFLECTED-FROM属性只存在于其对应的捆绑请求包含RESPONSE-ADDRESS属性的捆绑响应中。属性包含请求发出的源IP地址，它的目的是提供跟踪能力，这样STUN就不能被用作DOS攻击的反射器。\n\n具体的ERROR-CODE（响应号），与它们缺省的原因语句一起，目前定义如下：\n\n- 400（错误请求）：请求变形了。客户在修改先前的尝试前不应该重试该请求。\n- 401（未授权）：捆绑请求没有包含MESSAGE-INTERITY属性。\n- 420（未知属性）：服务器不认识请求中的强制属性。\n- 430（过期资格）：捆绑请求没有包含MESSAGE-INTEGRITY属性，但它使用过期\n的共享私密。客户应该获得新的共享私密并再次重试。\n- 431（完整性检查失败）：捆绑请求包含MESSAGE-INTEGRITY属性，但HMAC验\n证失败。这可能是潜在攻击的表现，或者客户端实现错误\n- 432（丢失用户名）：捆绑请求包含MESSAGE-INTEGRITY属性，但没有\nUSERNAME属性。完整性检查中两项都必须存在。\n- 433（使用TLS）：共享私密请求已经通过TLS（Transport Layer Security，即安全\n传输层协议）发送，但没有在TLS上收到。\n- 500（服务器错误）：服务器遇到临时错误，客户应该再次尝试。\n- 600（全局失败）：服务器拒绝完成请求，客户不应该重试。\n\n属性空间分为可选部分与强制部分，值超过0x7fff的属性是可选的，即客户或服务器即使不认识该属性也能够处理该消息；值小于或等于0x7fff的属性是强制理解的，即除非理解该属性，否则客户或服务器就不能处理该消息。\n\n> 实现原理\n\n![image](http://www.52im.net/data/attachment/forum/201610/12/112611tggg98eyyezpuqys.jpg)\n\nSTUN协议的完整交互过程如上，下面我们来介绍具体实现步骤。\n\n一般情况下，客户会配置STUN服务器提供者的域名，该域名被解析为IP地址和SRV过程的端口号。服务器名是“stun”，使用UDP协议发送捆绑请求，使用TCP协议发送共享私密请求。STUN协议的缺省端口号为3478。\n\n若要提供完整性检查，STUN在客户和服务器间使用128位的共享私密，作为在捆绑请求和捆绑响应中的密匙。\n\n首先，客户通过发现过程获得它将与之建立TCP连接的IP地址和端口号。客户打开该地址和端口的连接，开始TLS协商，验证服务器的标识。客户发送共享私密请求。该请求没有属性，只有头。服务器生成响应。\n\n客户会在该连接上生成多个请求，但在获得用户名和密码后关闭该连接。\n\n服务器收到共享私密请求，验证从TLS连接上到达的该请求；如果不是通过TLS收到的请求，则生成共享私密错误响应，并设置ERROR-CODE属性为响应号433；这里区分两种情况：若通过TCP收到请求，则错误响应通过收到请求的相同连接发送；若通过UDP收到请求，则错误响应发送回请求送出的源IP和端口。\n\n服务器检查请求中的任何属性，当其中有不理解的小于或等于0x7fff的值，则生成共享私密错误响应，设置ERROR-CODE属性为响应号420,并包括UNKNOWN-ATTRIBUTE属性，列出它不理解的小于或等于0x7fff的属性的值。该错误响应通过TLS连接发送。\n\n若请求正确，服务器创建共享私密响应，包含与请求中相同的事务ID，并包含USERNAME和PASSWORD属性。用户名在10分钟内有效。\n\n共享私密响应通过与收到请求的相同的TLS连接发送，服务器保持连接打开状态，由客户关闭它。\n\n接着，客户发送捆绑请求，携带的属性包括：\n\n- 可选属性：RESPONSE-ADDRESS属性和CHANGE-REQUEST属性；\n- 强制属性：MESSAGE-INTEGRITY属性和USERNAME属性。\n\n客户发送捆绑请求，通过客户重传来提供可靠性。客户开始用100ms的间隔重传，每次重传间隔加倍，直至1.6秒。之间间隔1.6秒的重传继续，直到收到响应或总共已经发送了9次。因此，若9500ms后，还未收到响应，客户认为传输已经失败。\n\n服务器检查捆绑请求的MESSAGE-INTEGRITY属性，不存在则生成捆绑错误响应，设置ERROR-CODE属性为响应号401；若存在，计算请求的HMACKey值。\n\n服务器检查USERNAME属性，不存在则生成捆绑错误响应，设置ERROR-CODE属性为响应号432；若存在，但不认识该USERNAME的共享私密（例如，它超时了），生成捆绑错误响应，设置ERROR-CODE属性为响应号430。\n\n若服务器知道该共享私密，但所计算的HMAC与请求的不同，生成捆绑错误响应，设置ERROR-CODE属性为响应号431。\n\n假设消息完整性检查通过了，服务器检查请求中的任何属性的值，若遇到不理解的小于或等于0x7fff的值，生成捆绑错误响应，设置ERROR-CODE属性为响应号420，该响应包含UNKNOWN-ATTRIBUTE属性，并列出不理解的小于或等于0x7fff的属性。\n\n若请求正确，服务器生成单个捆绑响应，包含与捆绑请求相同的事务ID。服务器在捆绑响应中加入MAPPED-ADDRESS属性，该属性的IP地址和端口号为捆绑请求的源IP地址和端口号。\n\n捆绑响应的源地址和端口号取决于捆绑请求中CHANGE-REQUEST属性的值及捆绑请求收到的地址和端口号相关。总结如下：\n\n![image](http://www.52im.net/data/attachment/forum/201610/12/112735tq1uhlhhll11qiux.png)\n\n服务器在捆绑响应中加入SOURCE-ADDRESS属性，包含用于发送捆绑响应的源地址和端口号；加入CHANGED-ADDRESS属性，包含源IP地址和端口号。\n\n如果捆绑请求中包含了USERNAME和MESSAGE-INTEGRITY属性，则服务器在捆绑响应中加入MESSAGE-INTEGRITY属性。\n\n如果捆绑请求包含RESPONSE-ADDRESS属性，则服务器在捆绑响应中加入REFLECTED-FROM属性：如果捆绑请求使用从共享私密请求获得的用户名进行认证，则REFLECTED-FROM属性包含共享私密请求到达的源IP地址和端口号；若请求中的用户名不是使用共享私密分配的，则REFLECTED-FROM属性包含获得该用户名的实体的源IP地址和端口号；若请求中没有用户名，且服务器愿意处理该请求，则REFLECTED-FROM属性包含请求发出的源IP地址和端口号。\n\n服务器不会重传响应，可靠性通过客户周期性地重发请求来保障，每个请求都会触发服务器进行响应。\n\n客户端判断响应的类型是捆绑错误响应还是捆绑响应。捆绑错误响应通常在请求发送的源地址和端口收到；捆绑响应通常在请求中的RESPONSE-ADDRESS属性的地址和端口收到，若没有该属性，则捆绑响应将在请求发送的源地址和端口号收到。\n\n- 若是捆绑错误响应，客户检查响应中的ERROR-CODE属性的响应号：400至499之间的未知属性按属性400处理，500至599之间的未知属性按500处理，600至699之间的未知属性按600处理。任何100和399之间的响应都会使请求重传中止，但其他则忽略；若客户收到响应的属性类型大于0x7fff，则忽略该属性，若小于或等于0x7fff，则请求重传停止，并忽略整个响应；\n- 若是捆绑响应，客户检查响应的MESSAGE-INTEGRITY属性：如果不存在，客户在请求中加入MESSAGE-INTEGRITY属性，并放弃该响应；如果存在，客户计算响应的HMAC。如果计算出的HMAC与响应中的不同，则放弃该响应，并警告客户可能受到了攻击；若计算出的HMAC与响应中的匹配，则过程继续；\n- 不论收到捆绑响应还是捆绑错误响应，都将中止该请求的重传。客户在第一次响应后继续监听捆绑请求的响应10秒钟，如果这期间它收到任何消息类型不同的响应或不同的MAPPED-ADDRESS属性，它将警告用户可能受到攻击；并且，如果客户收到的捆绑响应次数超过它发送的捆绑请求数的两倍，它将警告用户可能受到攻击；若捆绑响应经过认证，上述攻击并未导致客户丢弃MAPPED-ADDRESS，则客户可以使用该MAPPED-ADDRESS和SOURCE-ADDRESS属性。\n\n> STUN功能举例\n\n客户通过带外方式获得STUN服务器信息后，就打开对应的地址和端口的连接，并开始与STUN服务器进行TLS协商。一旦打开了连接，客户就通过TCP协议发送共享私密请求，服务器生成共享私密响应。STUN在客户和服务器间使用共享私密，用作捆绑请求和捆绑响应中的密匙。之后，客户使用UDP协议向STUN服务器发送捆绑请求，当捆绑请求消息到达服务器的时候，它可能经过了一个或者多个NAT。结果是STUN服务器收到的捆绑请求消息的源IP地址被映射成最靠近STUN服务器的NAT的IP地址，STUN服务器把这个源IP地址和端口号复制到一个捆绑响应消息中，发送回拥有这个IP地址和端口号的客户端。\n\n当STUN客户端收到捆绑响应消息之后，它会将自己发送捆绑请求时绑定的本地IP地址和端口号同捆绑响应消息中的IP地址和端口号进行比较，如果不匹配，就表示客户端正处于一个或者多个NAT的前面。\n\n在Full-Cone NAT的情况下，在捆绑响应消息中的IP地址和端口是属于公网的，公网上的任何主机都可以使用这个IP地址和端口号向这个应用程序发送数据包，应用程序只需要在刚才发送捆绑请求的IP地址和端口上监听即可。\n\n当然，客户可能并不在一个Full-Cone NAT的前面，实际上，它并不知道自己在一个什么类型的NAT的前面。为了确定NAT的类型，客户端使用附加的捆绑请求。具体过程是很灵活的，但一般都会像下面这样工作：客户端再发送一个捆绑请求，这次发往另一个IP地址，但是使用的是跟上一次同一个源IP地址和源端口号，如果返回的数据包里面的IP地址和端口号和第一次返回的数据包中的不同，客户端就会知道它是在一个对称NAT的前面。客户端为了确认自己是否在一个完全锥形NAT的前面，客户端可以发送一个带有标志的捆绑请求，这个标志告诉服务器使用另一个IP地址和端口发送捆绑响应。换句话说，如果客户端使X/Y的IP地址端口对向A/B的IP地址端口对发送捆绑请求，服务器就会使用源IP地址和源端口号为C/D的地址端口对向X/Y发送捆绑响应。如果客户端收到了这个响应，它就知道它是在一个Full-Cone NAT前面。\n\nSTUN协议允许客户端请求服务器从收到捆绑请求的IP地址往回发捆绑响应，但是要使用不同的端口号。这可以用来检查客户端是否在Port Restricted Cone NAT的前面还是在Restricted Cone NAT的前面。\n\n### 2.2 RFC5389/STUN\n\nSTUN协议在RFC5389中被重新命名为Session Traversal Utilities for NAT，即NAT会话穿透效用。在这里，NAT会话穿透效用被定位为一个用于其他解决NAT穿透问题协议的协议。它可以用于终端设备检查由NAT分配给终端的IP地址和端口号。同时，它也被用来检查两个终端之间的连接性，好比是一种维持NAT绑定表项的保活协议。STUN可以用于多种NAT类型，并不需要它们提供特殊的行为。\n\nSTUN本身不再是一种完整的NAT穿透解决方案，它相当于是一种NAT穿透解决方案中的工具。这是与RFC3489/STUN版本相比最重要的改变。\n\n> STUN用途\n\n目前定义了三种STUN用途：\n\n- Interactive Connectivity Establishment（ICE）[MMUSIC-ICE]，交互式连接建立\n- Client-initiated connections for SIP [SIP-OUTBOUND]，用于SIP的客户端初始化连接\n- NAT Behavior Discovery [BEHAVE-NAT]，NAT行为发现\n\n> 报文结构\n\n【Ø  消息头】\n\nSTUN消息头为20字节，后面紧跟0或多个属性。STUN头部包含一STUN消息类型、magic cookie、事务ID和消息长度。\n\n![image](http://www.52im.net/data/attachment/forum/201610/12/114036v0l0xcxjj6l6lc94.png)\n\n每个STUN消息的最高位前2位必须为0。当STUN协议为多个协议多路复用时若使用的是同一个端口，这可以用于与其他协议区分STUN数据包。消息类型确定消息的类别（如请求、成功回应、失败回应、标志）。虽然这里有四种消息类型，但可以分为2类事务：请求/响应事务、标志事务。\n\n消息类型字段可进一步划分为下面结构：\n\n![image](http://www.52im.net/data/attachment/forum/201610/12/113902e1ci02g21bks8cmf.png)\n\n消息类型定义如下：\n\n- 0b00，表示请求\n- 0b01，表示标志\n- 0b10，表示成功响应\n- 0b11，表示错误响应\n\n魔术字域必须包含固定的值0x2112A442。在RFC3489中，该域是事务ID的一部分。配置魔术字允许服务器检测客户是否理解某些在改进的版本中增加的属性。另外，还可用于STUN多路复用时与其他协议的包进行区分。\n\n96位的事务ID用于唯一的识别STUN事务。对于请求/响应事务，事务ID由STUN客户端来选择；对于标志事务，由代理（代理指支持STUN的客户端或服务器）来选择并发送。它主要服务于与请求相关的响应，因此它也扮演着一个帮助阻止确定类型的攻击的角色。服务器使用事务ID来唯一的标识出所有客户端的每一个事务。事务ID本身必须是唯一的，并且随机的从0到2的96-1次方中选择。重新发送相同的请求时，也必须使用新的事务ID。成功或错误响应必须携带与相对应的请求相同的事务ID。\n\n消息长度字段不包括20字节的STUN头部。所有的STUN属性必须填充为4字节的倍数。消息长度字段的最后2位总是为0，这为区分STUN包与其他协议的包提供了另外一种方法。\n\n【Ø  消息属性】\n\nSTUN头之后是0或多个属性。每个属性都采用TLV编码，16位的类型、16位的长度及可变长度的值。每个STUN属性必须是4字节边界对齐。\n\n![image](http://www.52im.net/data/attachment/forum/201610/12/114019vcfzuicfi6vumdfz.png)\n\n属性空间被划分为2个范围。属性的类型值在0x0000到0x7fff是强制理解属性，这意味着除非STUN代理能够理解这些属性，否则将不能正常处理包含该属性的消息；属性的类型值在0x8000到0xffff范围是可选理解属性，这意味着如果STUN代理不能理解它们的话这些属性可以被忽略。\n\nSTUN属性类型集由IANA维护，具体定义详见IETF官方文档 RFC5389。\n\n### 2.3 RFC5389与RFC3489的区别\n\nRFC5389与RFC3489的不同点如下：\n\n- 去掉STUN是一种完整的NAT穿透方案的概念，现在是一种用于提供NAT穿透解决方案的工具。因而，协议的名称变为NAT会话穿透效用；\n- 定义了STUN的用途；\n- 去掉了STUN关于NAT类型检测和绑定生命期发现的用法，去掉了RESPONSE-ADDRESS、CHANGED-ADDRESS、CHANGE-REQUEST、SOURCE-ADDRESS和REFLECTED-FROM属性；\n- 增加了一个固定的32位的魔术字字段，事务ID字段减少了32位长度；\n- 增加了XOR-MAPPED-ADDRESS属性，若魔术字在捆绑请求中出现时，该属性包括在捆绑响应中。否则，RFC3489中的行为是保留的（换句话说，捆绑响应中包括MAPPED-ADDRESS）；\n- 介绍了消息类型字段的正式结构，带有一对明确的位来标识Request、Response、Error-Response或Indication消息。因此，消息类型字段被划分为类别和方法两部分；\n- 明确的指出了STUN的最高2位是0b00，当用于ICE时可以简单的与RTP包区分开来；\n- 增加指纹属性来提供一种明确的方法来检测当STUN协议多路复用时，STUN与其他协议之间的差异；\n- 增加支持IPv6，IPv4客户端可以获取一个IPv6映射地址，反之亦然；\n- 增加一个long-term-credential-based认证机制；\n- 增加了SOFTWARE、REALM、NONCE和ALTERNATE-SERVER属性；\n- 去掉了共享密匙方法，因此PASSWORD属性也去掉了；\n- 去掉了使用连续10秒侦听STUN响应来识别一个攻击的做法；\n- 改变事务计时器来增加TCP友好性；\n- 去掉了STUN例子如集中分离控制和媒体面，代替的，在使用STUN协议时提供了更多的信息；\n- 定义了一类填充机制来改变长度属性的说明；\n- REALM、SERVER、原因语句和NONCE限制在127个字符，USERNAME限制在513个字节以内；\n- 为TCP和TLS改变了DNS SRV规程，UDP仍然和以前保持一致。\n\nIETF官文档，详见：RFC5389、RFC3489。\n\n### 2.4 新特性介绍\n\n> 指纹机制\n\nFINGERPRINT机制是一种可选的用于其他协议多路复用STUN时发送给相同的传输地址时区分STUN数据包的机制，该机制不支持与RFC3489相兼容。\n\n在一些用途中，基于相同的传输地址时多个协议会多路复用STUN消息，例如RTP协议。STUN消息必须首先和应用报文分离开。目前，在STUN报头中有3种固定的字段可以用于该目的。尽管如此，在一些案例中，三种固定字段仍然不能充分的区别开。\n\n当扩展的指纹机制被使用时，STUN代理在发送给其他STUN代理的消息中包括FINGERPRINT属性。当其他STUN代理收到时，除基本的检查之外，还将检查是否包含FINGERPRINT属性及它是否包含正确的值，至此，它将相信这是一个STUN消息。指纹机制帮助STUN代理检查其他协议那些看起来像是STUN消息的消息。\n\n> 通过DNS发现服务器机制\n\nSTUN客户端可以使用DNS来发现STUN服务器的IP地址和端口。客户端必须知道服务器的域名。\n\n当客户端希望找出服务器在公网上的位置就采用捆绑请求/响应事务，SRV（资源记录表）中服务器名称是“stun”。当通过TLS会话采用捆绑请求/响应事务，SRV中服务器名称为“stuns”。STUN用户可以定义额外的DNS资源记录服务名称。\n\nSTUN请求的默认端口是3478，用于TCP和UDP。STUN在TLS上的默认端口是5349。服务器能够在TLS上运行STUN与STUN在TCP上时使用相同的端口，只有服务器软件支持决定初始消息是否是TLS或STUN消息。\n\n如果SRV中没有记录可查，客户端执行A或AAAA记录查找域名。结果将会是1张IP地址表，每一个都可以使用TCP或UDP采用默认端口号连接。通常要求使用TLS，客户端使用STUN在TLS上的默认端口号连接其中一个IP地址。\n\n> 认证和消息完整性机制\n\n- 短期证书机制\n\n短期证书机制假设在STUN事务之前，客户端和服务器已经使用了其他协议来交换了证书，以username和password形式。这个证书是有时间限制的。例如，在ICE用途中，两个终端使用带外方式交换信息来对username和password达成一致，并在媒体会话期间使用。这个证书被用来进行消息完整性检查，用于每个请求和多个响应中。与长期证书机制相比，没有挑战和响应方式，因此，这种证书的时间限制特性的优点是可以阻止重播。\n\n- 长期证书机制\n\n长期证书机制依赖于一个长期证书，username和password在客户端和服务器中是共用的。这个证书从它提供给 用户开始将一直是有效的，直到该用户不再是该系统的用户。这本质上是一个提供给用户username和password的传统的登入方式。    \n\n客户端初始发送一个请求，没有提供任何证书和任何完整性检测。服务器拒绝这个请求，并提供给用户一个范围（用于指导用户或代理选择username和password）和一个nonce。这个nonce提供重放保护。它是一个cookie，由服务器选择，以这样一种方式来标示有效时间或客户端身份是有效的。客户端重试这个请求，这次包括它的username和realm和服务器提供的nonce来回应。服务器确认这个nonce和检查这个message integrity。如果它们匹配，请求则通过认证。如果这个nonce不再有效，即过期了，服务器就拒绝该请求，并提供一个新的nonce。\n\n在随后的到同一服务器的请求，客户端重新使用这个nonce、username和realm，和先前使用的password。这样，随后的请求不会被拒绝直到这个nonce变成无效的。需要注意的是，长期证书机制不能用来保护Indications，由于Indications不能被改变，因此，使用Indications时要么使用短期证书，要么就省略认证和消息完整性。因为长期证书机制对离线字典攻击敏感，部署的时候应该使用很难猜测的密码。\n\n> 备份服务器机制\n\n服务器使用增强的重定向功能将一个客户端转向另一个服务器，通过回应一个错误响应号为300（尝试备份）的错误响应。服务器在错误响应中携带一个ALTERNATE-SERVER属性。\n\n客户端收到错误响应号为300的错误响应后，在该响应中查找ALTERNATE-SERVER属性。若找到一个，客户端就会将当前的事务作废，并重新尝试发送请求到该属性中列出的服务器。请求报文若已经通过认证，则必须使用与先前发送给执行重定向操作的服务器同样的证书。如果客户端在最后5分钟里已经重试发送请求时已经重定向到了一个服务器，它必须忽略重定向操作并将当前的事务作废，这是为了防止无限的重定向循环。\n\n### 2.5 RFC5389与RFC3489的兼容\n\n在RFC3489中：\n\n- UDP是唯一支持的传输协议\n- RFC5389中的魔术字字段是RFC3489中事务ID的一部分，事务ID长128位\n- 没有XOR-MAPPED-ADDRESS属性，绑定方法是使用MAPPED-ADDRESS属性代替\n- 有3个需要强制理解的属性，分别是：RESPONSE-ADDRESS、CHANGE-REQUEST、CHANGED-ADDRESS属性，而RFC5389中不再支持这些属性。\n\n> 客户端处理的改变\n\n客户端想要与RFC3489的服务器互操作，应发送一个使用绑定方法的请求消息，不包含任何消息，使用UDP协议发送给服务器。如果成功，将收到服务器发回的包含MAPPED-ADDRESS属性而不是XOR-MAPPED-ADDRESS属性的成功响应。客户端试图与基于RFC3489的应用服务器互操作必须准备好接收任意一个属性。此外，客户端必须忽略任何在响应中出现的保留的强制理解的属性。RFC3489中规定保留属性中的0x0002、0x0004、0x0005和0x000B可能出现在绑定响应中。\n\n> 服务器处理的改变\n\n服务器能够察觉由RFC3489中的客户端发送的携带有不正确的魔术字的捆绑请求消息。当服务器察觉到RFC3489中的客户端，它应该将捆绑请消息中魔术字域中的值拷贝到捆绑响应中的魔术字字段中，并且插入一个MAPPED-ADDRESS属性代替XOR-MAPPED-ADDRESS属性。\n\n客户端在极少的环境下可能包括RESPONSE-ADDRESS或CHANGE-REQUEST属性中的一个。在这些情况下，服务器把这些属性看做是一个不认识的强制理解的属性，并回应一个错误响应。RFC3489版本中的STUN缺少魔术字和指纹属性这两种能够高可靠性的正确标识其他协议多路复用时的STUN消息。因此，STUN执行与RFC3489兼容时不应该被用于多个协议。\n\n## 3、TURN详解\n\n### 3.1 RFC5766/TURN\n\nTURN，在RFC5766中定义，英文全称Traversal Using Relays around NAT（TURN）：Relay Extensions to Session Traversal Utilities for NAT（STUN），即使用中继穿透NAT：STUN的中继扩展。简单的说，TURN与STUN的共同点都是通过修改应用层中的私网地址达到NAT穿透的效果，异同点是TURN是通过两方通讯的“中间人”方式实现穿透。\n\n如果一个主机位于NAT的后面，在某些情况下它不能够与其他主机点对点直接连接。在这些情况下，它需要使用中间网点提供的中继连接服务。TURN协议就是用来允许主机控制中继的操作并且使用中继与对端交换数据。TURN与其他中继控制协议不同的是它能够允许一个客户端使用一个中继地址与多个对端连接。\n\nTURN协议被设计为ICE的一部分，用于NAT穿越，虽然如此，它也可以在没有ICE的地方单独使用。\n\n### 3.2 操作概述\n\n![image](http://www.52im.net/data/attachment/forum/201610/12/115151bn2gxe2p96x612x2.jpg)\n\n在一个典型组网中，一个TURN客户端连接在一个私有网络中，通过一个或多个NAT来连接到公网。在公网中有一个TURN服务器。在因特网的别处有一个或多个对端是这个TURN客户端希望通讯的。这些对端也有可能是在一个或多个NAT的后面。该客户端使用服务器作为一个中继来发送数据包 到这些对端去，并且从这些对端接收数据包。\n\n客户端通过一个IP地址和端口的组合来与服务器建立会话。客户端使用TURN命令在服务器上创建和操作一个ALLOCATION。一旦这个allocation创建好了，客户端能够在数据发往哪个对端的指示下发送应用数据到这个服务器，服务器将中继这些数据到合适的对端。客户端发送的应用数据包含在TURN消息中，服务器将数据提取出来，并以UDP数据包方式发送给对端。反向上，对端以UDP数据包方式发送应用数据到这个allocation提供的中继传输地址。因为TURN消息总是包含客户端与哪些对端通讯的指示，客户端能够使用单一的allocation来与多个对端通讯。\n\n### 3.3 术语\n\n- TURN client：遵循RFC5766的STUN客户端。\n- TURN server：遵循RFC5766的STUN服务器。\n- Peer：TURN客户端希望连接的主机。TURN服务器为TURN客户端和它的对端中继流量，但Peer并不与TURN服务器使用TURN协议进行交互，它接收从TURN服务器发送过来的数据，并向TURN服务器发送数据。\n- Transport Address：IP地址与端口号的组合。\n- Host Transport Address：客户端或对端的传输地址。\n- Server-Reflexive Transport Address：NAT公网侧的传输地址，该地址由NAT分配，相当于一个特定的主机传输地址。\n- Relayed Transport Address：TURN服务器上的传输地址，用于客户端和对端中继数据。\n- TURN Server Transport Address：TURN服务器上的传输地址，用于客户端发送STUN消息给服务器。\n- Peer Transport Address：服务器看到的对端的传输地址，当对端是在NAT后面，则是对端的服务器反射传输地址。\n- Allocation：通过Allocate请求将中继传输地址提供给客户端，除了中继状态外，还有许可和超时定时器等。\n- 5-tuple：五元组，包括客户端IP地址和端口，服务器IP地址和端口和传输协议（包括UDP、TCP、TLS）的组合。\n- Channel：通道号与对端传输地址的关联，一旦一个通道号与一个对端的传输地址绑定，客户端和服务器就能够利用带宽效应更大的通道数据消息来交换数据。\n- Permission：一个对端允许使用它的IP地址和传输协议来发送数据到TURN服务器，服务器只为从对端发来的并且匹配一个已经存在的许可的流量中继到相应的客户端。\n- Realm：服务器内用于描述服务器或内容的一个字符串，这个realm告诉客户端哪些用户名和密码的组合可用于认证请求。\n- Nonce：服务器随机选择的一个字符串，包含在报文摘要中。为了防止中继攻击，服务器应该有规律的改变这个nonce。\n\n具体协议细节，详见IETF官方文档：RFC5766.\n\n### 3.4 协议交互过程详细举例\n\n以上图为例进行讲解，每个消息中，多个属性包含在消息中并显示它们的值。为了方便阅读，值以人们可读的格式来显示。\n\n![image](http://www.52im.net/data/attachment/forum/201610/12/115958r41hgy1uht78nazu.jpg)\n\n客户端使用10.1.1.2:49271作为传输地址向服务器的传输地址发送Allocate请求。客户端随机选择一个96位的事务ID。该Allocate请求消息包括SOFTWARE属性来提供客户端的软件版本信息；包括LIFETIME属性，指明客户端希望该allocation具有1小时的生命期而非缺省的10分钟；包括REQUESTED-TRANSPORT属性来告诉服务器与对端之间采用UDP协议来传输；包括DONT-FRAGMENT属性因为客户端希望在随后的Send indications中使用DON’T-FRAGMENT属性。\n\n服务器需要任何请求必须是经过认证的，因此服务器拒绝了该最初的Allocation请求，并且回应了携带有错误响应号为401（未授权）的Allocate错误响应；该响应包括一个REALM属性，指明认证的域；还包括一个NONCE属性和一个SOFTWARE属性。\n\n客户端收到了错误响应号为401的Allocate错误响应，将重新尝试发送Allocate请求，此时将包括认证属性。客户端在新的请求中重新选择一个新的事务ID。客户端包括一个USERNAME属性，使用从服务器那收到的realm值来帮助它决定使用哪个值；请求还包括REALM和NONCE属性，这两个属性是从收到的错误响应中拷贝出来的。最后，客户端包括一个MESSAGE-INTEGRITY属性。\n\n服务器收到认证的Allocate请求后，检查每个属性是否正确；然后，产生一个allocation，并给客户端回应Allocate成功响应。服务器在该成功响应中携带一个LIFETIME属性，本例中服务器将客户端请求的1小时生命期减小为20分钟，这是因为这个特定的服务器可能不允许超过20分钟的生命期；该响应包括XOR-RELAYED-ADDRESS属性，值为该allocation的中继传输地址；该响应还包括XOR-MAPPED-ADDRESS属性，值为客户端的server-reflexive地址；该响应也包含一个SOFTWARE属性；最后，包括一个MESSAGE-INTEGRITY属性来证明该响应，确保它的完整性。\n\n![image](http://www.52im.net/data/attachment/forum/201610/12/120031zi6vsrvx24ssg42i.jpg)\n\n接着，客户端为了准备向对端A发送一些应用数据而创建一个permission。这里通过一个CreatePermission请求来做到。该请求携带XOR-PEER-ADDRESS属性包含有确定的请求的IP地址，这里为对端A的地址；需要注意的是，属性中地址的端口号被设置为0在CreatePermission请求中，并且客户端使用的是对端A的server-reflexive地址而不是它的主机地址（私网地址）；客户端在该请求中携带与之前的Allocate请求中一样的username、realm和nonce值，因此该请求被服务器认可。此时在该请求中，客户端没有携带SOFTWARE属性。\n\n服务器收到该CreatePermission请求，产生一个相应的许可，并以CreatePermission成功响应来回应。该响应中只包含了Transaction-ID和MESSAGE-INTEGRITY属性。\n\n![image](http://www.52im.net/data/attachment/forum/201610/12/120053ks33633olaxnpi4l.jpg)\n\n现在客户端使用Send indication来发送应用数据到对端A。对端的server-reflexive传输地址包含在XOR-PEER-ADDRESS属性中，应用数据包含在DATA属性中。客户端已经在应用层上执行了路径MTU发现功能，因此通过DON’T-FRAGMENT属性来告知服务器当通过UDP方式来向对端发送数据时应设置DF位。Indications不能使用长期证书机制来认证，所以该消息中没有MESSAGE-INTEGRITY属性。\n\n服务器收到Send indication后，提取出应用数据封装成UDP格式发给对端A；UDP报文的源传输地址为中继传输地址，并设置DF位。\n\n对端A回应它自己的包含有应用数据的UDP包给服务器。目的地址为服务器的中继传输地址。当服务器收到后，将生成Data indication消息给客户端，携带有XOR-PEER-ADDRESS属性。应用数据包含在DATA属性中。\n\n![image](http://www.52im.net/data/attachment/forum/201610/12/120117zf5gi0ka7fw5o57e.jpg)\n\n客户端现在若要绑定一个通道到对端B，将指定一个空闲的通道号（本例中为0x4000）包含在CHANNEL-NUMBER属性中，对端B的传输地址包含在XOR-PEER-ADDRESS属性中。与以前一样，客户端再次利用上次请求中的username、realm和nonce。\n\n当服务器收到该请求后，服务器绑定这个对端的通道号，为对端B的IP地址安装一个permission，然后给客户端回应一个ChannelBind成功响应消息。\n\n![image](http://www.52im.net/data/attachment/forum/201610/12/120134g98040e74ziwfiwz.jpg)\n\n客户端现在发送一个ChannelData消息给服务器，携带有发送给对端B的数据。这个消息不是一个STUN消息，因此没有事务ID。它之有3个字段：通道号、数据、数据长度；服务器收到后，检查通道号后发现当前已经绑定了，就以UDP方式发送数据给对端B。\n\n接着，对端B发送UDP数据包回应给服务器的中继传输地址。服务器收到后，回应给客户端ChannelData消息，包含UDP数据包中的数据。服务器知道是给哪个客户端发送ChannelData消息，这是因为收到的UDP数据包中的目的地址（即服务器的中继传输地址），并且知道使用的是哪个通道号，这是因为通道已经与相应的传输地址绑定了。\n\n![image](http://www.52im.net/data/attachment/forum/201610/12/120157sixfnelrqciqexgd.jpg)\n\n有时候，20分钟的生命期已经到了，客户端需要刷新allocation。此时通过发送Refresh请求来进行。该请求包含最后一次使用的username、realm和nonce，还包含SOFTWARE属性。当服务器收到这个Refresh请求时，它注意到这个nonce值已经超期了，则给客户端回应一个错误响应号为438（过期Nonce）的Refresh错误响应，并提供一个新的nonce值。可护端将重试该请求，此时携带新的nonce值。若第二次尝试被接受，服务器将回应一个成功响应。需要注意的是，此时客户端在请求中没有携带LIFETIME属性，所以服务器刷新客户端的allocation时采用缺省的10分钟生命期。\n\n## 4、ICE简明介绍\n\n### 4.1 简介\n\nICE的全称Interactive Connectivity Establishment（互动式连接建立），由IETF的MMUSIC工作组开发出来的，它所提供的是一种框架，使各种NAT穿透技术可以实现统一。ICE跟STUN和TURN不一样，ICE不是一种协议，而是一个框架（Framework），它整合了STUN和TURN。\n\n### 4.2 应用模型\n\n![image](http://www.52im.net/data/attachment/forum/201610/12/120427sj60zrara770aql5.png)\n\n如上图所示，如果A想与B通信，那么其过程如下：\n\n- A收集所有的IP地址，并找出其中可以从STUN服务器和TURN服务器收到流量的地址；\n- A向STUN服务器发送一份地址列表，然后按照排序的地址列表向B发送启动信息，目的是实现节点间的通信；\n- B向启动信息中的每一个地址发送一条STUN请求；\n- A将第一条接收到的STUN请求的回复信息发送给B；\n- B接到STUN回复后，从中找出那些可在A和B之间实现通信的地址；\n- 用列表中的排序列最高的地址进一步的设备间通信。\n\n由于该技术是建立在多种NAT穿透协议的基础之上，并且提供了一个统一的框架，所以ICE具备了所有这些技术的优点，同时还避免了任何单个协议可能存在的缺陷。因此，ICE可以实现在未知网络拓扑结构中实现的设备互连，而且不需要进行对手配置。另外，由于该技术不需要为VoIP流量手动打开防火墙，所以也不会产生潜在的安全隐患。\n\n## 5、本文总结\n\n在现实Internet网络环境中，大多数计算机主机都位于防火墙或NAT之后，只有少部分主机能够直接接入Internet。很多时候，我们希望网络中的两台主机能够直接进行通信（即所谓的P2P通信），而不需要其它公共服务器的中转。由于主机可能位于防火墙或NAT之后，在进行P2P通信之前，我们需要进行检测以确认它们之间能否进行P2P通信以及如何通信。这种技术通常被称为NAT穿透（NAT Traversal）。\n\nRFC3489中定义的STUN，即简单地用UDP穿过NAT（STUN）是个轻量级的协议。它允许应用发现它们与公共互联网之间存在的NAT和防火墙及其他类型。它还为应用提供判断NAT给它们分配的公共网际协议（IP）地址。STUN可工作在许多现存NAT上，并且不需要它们做任何特别的行为。它允许广泛的各类的应用穿越现存的NAT设施。\n\nRFC5389中对STUN协议进行了修订，将其定位于为穿透NAT提供工具，即NAT会话穿透效用是一个用于其他解决NAT穿透问题协议的协议。它可以用于终端设备检查由NAT分配给终端的IP地址和端口号。同时，它也被用来检查两个终端之间的连接性，好比是一种维持NAT绑定表项的保活协议。STUN本身并不是一种完整的NAT穿透解决方案。它相当于是一种NAT穿透解决方案中的工具。这是与先前的版本相比最重要的改变。之前的RFC3489中定义的STUN是一个完整的穿透NAT解决方案。此外，最大的区别是支持TCP穿透。\n\nRFC5766中对STUN协议再次进行了扩展，即中继穿透NAT：STUN的扩展。TURN与STUN的共同点都是通过修改应用层中的私网地址达到NAT穿透的效用，异同点是TUN采用了两方通讯的“中间人”方式实现穿透，突破了原先STUN协议无法在两台主机不能够点对点直接连接下提供作用的限制。\n\n技术无止境，NAT穿透技术仍在不断更新中，这里只对STUN/TURN协议作了简单的介绍，具体细节请参考RFC3489/5389/5766。\n","slug":"p2p3","published":1,"updated":"2018-09-06T09:30:10.030Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlqdfcwh0005owv3q4l72zy8","content":"<h2 id=\"1、内容概述\"><a href=\"#1、内容概述\" class=\"headerlink\" title=\"1、内容概述\"></a>1、内容概述</h2><p>在现实Internet网络环境中，大多数计算机主机都位于防火墙或NAT之后，只有少部分主机能够直接接入Internet。很多时候，我们希望网络中的两台主机能够直接进行通信，即所谓的P2P通信，而不需要其他公共服务器的中转。由于主机可能位于防火墙或NAT之后，在进行P2P通信之前，我们需要进行检测以确认它们之间能否进行P2P通信以及如何通信。这种技术通常称为NAT穿透（NAT Traversal）。最常见的NAT穿透是基于UDP的技术，如RFC3489中定义的STUN协议。</p>\n<p>STUN，首先在RFC3489中定义，作为一个完整的NAT穿透解决方案，英文全称是Simple Traversal of UDP Through NATs，即简单的用UDP穿透NAT。</p>\n<p>在新的RFC5389修订中把STUN协议定位于为穿透NAT提供工具，而不是一个完整的解决方案，英文全称是Session Traversal Utilities for NAT，即NAT会话穿透效用。RFC5389与RFC3489除了名称变化外，最大的区别是支持TCP穿透。</p>\n<p>TURN，首先在RFC5766中定义，英文全称是Traversal Using Relays around NAT:Relay Extensions to Session Traversal Utilities for NAT，即使用中继穿透NAT:STUN的扩展。简单的说，TURN与STURN的共同点都是通过修改应用层中的私网地址达到NAT穿透的效果，异同点是TURN是通过两方通讯的“中间人”方式实现穿透。</p>\n<p>ICE跟STUN和TURN不一样，ICE不是一种协议，而是一个框架（Framework），它整合了STUN和TURN。</p>\n<h2 id=\"2、STUN详解\"><a href=\"#2、STUN详解\" class=\"headerlink\" title=\"2、STUN详解\"></a>2、STUN详解</h2><p>了解STUN之前，我们需要了解NAT的种类。</p>\n<p>NAT对待UDP的实现方式有4种，分别如下：</p>\n<a id=\"more\"></a>\n<p>Full Cone NAT：</p>\n<blockquote>\n<p>完全锥形NAT，所有从同一个内网IP和端口号发送过来的请求都会被映射成同一个外网IP和端口号，并且任何一个外网主机都可以通过这个映射的外网IP和端口号向这台内网主机发送包。</p>\n</blockquote>\n<p>Restricted Cone NAT：</p>\n<blockquote>\n<p>限制锥形NAT，它也是所有从同一个内网IP和端口号发送过来的请求都会被映射成同一个外网IP和端口号。与完全锥形不同的是，外网主机只能够向先前已经向它发送过数据包的内网主机发送包。</p>\n</blockquote>\n<p>Port Restricted Cone NAT：</p>\n<blockquote>\n<p>端口限制锥形NAT，与限制锥形NAT很相似，只不过它包括端口号。也就是说，一台IP地址X和端口P的外网主机想给内网主机发送包，必须是这台内网主机先前已经给这个IP地址X和端口P发送过数据包。</p>\n</blockquote>\n<p>Symmetric NAT：</p>\n<blockquote>\n<p>对称NAT，所有从同一个内网IP和端口号发送到一个特定的目的IP和端口号的请求，都会被映射到同一个IP和端口号。如果同一台主机使用相同的源地址和端口号发送包，但是发往不同的目的地，NAT将会使用不同的映射。此外，只有收到数据的外网主机才可以反过来向内网主机发送包。</p>\n</blockquote>\n<h3 id=\"2-1-RFC3489-STUN\"><a href=\"#2-1-RFC3489-STUN\" class=\"headerlink\" title=\"2.1 RFC3489/STUN\"></a>2.1 RFC3489/STUN</h3><p>STUN（Simple Traversal of User Datagram Protocol Through Network Address Translators），即简单的用UDP穿透NAT，是个轻量级的协议，是基于UDP的完整的穿透NAT的解决方案。它允许应用程序发现它们与公共互联网之间存在的NAT和防火墙及其他类型。它也可以让应用程序确定NAT分配给它们的公网IP地址和端口号。STUN是一种Client/Server的协议，也是一种Request/Response的协议，默认端口号是3478。（IETF官方文档RFC3489/STUN点此进入）</p>\n<ul>\n<li>报文结构</li>\n</ul>\n<p>【Ø  消息头】</p>\n<p>所有的STUN消息都包含20个字节的消息头，包括16位的消息类型，16位的消息长度和128位的事务ID。</p>\n<p><img src=\"http://www.52im.net/data/attachment/forum/201610/12/112409m1f0zv1t36x1jfbf.png\" alt=\"image\"></p>\n<p>消息类型许可的值如下：</p>\n<p>0x0001：捆绑请求</p>\n<p>0x0101：捆绑响应</p>\n<p>0x0111：捆绑错误响应</p>\n<p>0x0002：共享私密请求</p>\n<p>0x0102：共享私密响应</p>\n<p>0x0112：共享私密错误响应</p>\n<p>消息长度，是消息大小的字节数，但不包括20字节的头部。事务ID，128位的标识符，用于随机请求和响应，请求与其相应的所有响应具有相同的标识符。</p>\n<p>【Ø  消息属性】</p>\n<p>消息头之后是0或多个属性，每个属性进行TLV编码，包括16位的属性类型、16位的属性长度和变长属性值。</p>\n<p><img src=\"http://www.52im.net/data/attachment/forum/201610/12/112409kqyke5fxgkccfwqv.png\" alt=\"image\"></p>\n<p>属性类型定义如下：</p>\n<ul>\n<li>MAPPED-ADDRESS：MAPPED-ADDRESS属性表示映射过的IP地址和端口。它包括8位的地址族，16位的端口号及长度固定的IP地址。</li>\n<li>RESPONSE-ADDRESS：RESPONSE-ADDRESS属性表示响应的目的地址</li>\n<li>CHASNGE-REQUEST：客户使用32位的CHANGE-REQUEST属性来请求服务器使用不同的地址或端口号来发送响应。</li>\n<li>SOURCE-ADDRESS：SOURCE-ADDRESS属性出现在捆绑响应中，它表示服务器发送响应的源IP地址和端口。</li>\n<li>CHANGED-ADDRESS：如果捆绑请求的CHANGE-REQUEST属性中的“改变IP”和“改变端口”标志设置了，则CHANGED-ADDRESS属性表示响应发出的IP地址和端口号。</li>\n<li>USERNAME：USERNAME属性用于消息的完整性检查，用于消息完整性检查中标识共享私密。USERNAME通常出现在共享私密响应中，与PASSWORD一起。当使用消息完整性检查时，可有选择地出现在捆绑请求中。</li>\n<li>PASSWORD：PASSWORD属性用在共享私密响应中，与USERNAME一起。PASSWORD的值是变长的，用作共享私密，它的长度必须是4字节的倍数，以保证属性与边界对齐。</li>\n<li>MESSAGE-INTEGRITY：MESSAGE-INTEGRITY属性包含STUN消息的HMAC-SHA1，它可以出现在捆绑请求或捆绑响应中；MESSAGE-INTEGRITY属性必须是任何STUN消息的最后一个属性。它的内容决定了HMAC输入的Key值。</li>\n<li>ERROR-CODE：ERROR-CODE属性出现在捆绑错误响应或共享私密错误响应中。它的响应号数值范围从100到699。</li>\n<li>UNKNOWN-ATTRIBUTES：UNKNOWN-ATTRIBUTES属性只存在于其ERROR-CODE属性中的响应号为420的捆绑错误响应或共享私密错误响应中。</li>\n<li>REFLECTED-FROM：REFLECTED-FROM属性只存在于其对应的捆绑请求包含RESPONSE-ADDRESS属性的捆绑响应中。属性包含请求发出的源IP地址，它的目的是提供跟踪能力，这样STUN就不能被用作DOS攻击的反射器。</li>\n</ul>\n<p>具体的ERROR-CODE（响应号），与它们缺省的原因语句一起，目前定义如下：</p>\n<ul>\n<li>400（错误请求）：请求变形了。客户在修改先前的尝试前不应该重试该请求。</li>\n<li>401（未授权）：捆绑请求没有包含MESSAGE-INTERITY属性。</li>\n<li>420（未知属性）：服务器不认识请求中的强制属性。</li>\n<li>430（过期资格）：捆绑请求没有包含MESSAGE-INTEGRITY属性，但它使用过期<br>的共享私密。客户应该获得新的共享私密并再次重试。</li>\n<li>431（完整性检查失败）：捆绑请求包含MESSAGE-INTEGRITY属性，但HMAC验<br>证失败。这可能是潜在攻击的表现，或者客户端实现错误</li>\n<li>432（丢失用户名）：捆绑请求包含MESSAGE-INTEGRITY属性，但没有<br>USERNAME属性。完整性检查中两项都必须存在。</li>\n<li>433（使用TLS）：共享私密请求已经通过TLS（Transport Layer Security，即安全<br>传输层协议）发送，但没有在TLS上收到。</li>\n<li>500（服务器错误）：服务器遇到临时错误，客户应该再次尝试。</li>\n<li>600（全局失败）：服务器拒绝完成请求，客户不应该重试。</li>\n</ul>\n<p>属性空间分为可选部分与强制部分，值超过0x7fff的属性是可选的，即客户或服务器即使不认识该属性也能够处理该消息；值小于或等于0x7fff的属性是强制理解的，即除非理解该属性，否则客户或服务器就不能处理该消息。</p>\n<blockquote>\n<p>实现原理</p>\n</blockquote>\n<p><img src=\"http://www.52im.net/data/attachment/forum/201610/12/112611tggg98eyyezpuqys.jpg\" alt=\"image\"></p>\n<p>STUN协议的完整交互过程如上，下面我们来介绍具体实现步骤。</p>\n<p>一般情况下，客户会配置STUN服务器提供者的域名，该域名被解析为IP地址和SRV过程的端口号。服务器名是“stun”，使用UDP协议发送捆绑请求，使用TCP协议发送共享私密请求。STUN协议的缺省端口号为3478。</p>\n<p>若要提供完整性检查，STUN在客户和服务器间使用128位的共享私密，作为在捆绑请求和捆绑响应中的密匙。</p>\n<p>首先，客户通过发现过程获得它将与之建立TCP连接的IP地址和端口号。客户打开该地址和端口的连接，开始TLS协商，验证服务器的标识。客户发送共享私密请求。该请求没有属性，只有头。服务器生成响应。</p>\n<p>客户会在该连接上生成多个请求，但在获得用户名和密码后关闭该连接。</p>\n<p>服务器收到共享私密请求，验证从TLS连接上到达的该请求；如果不是通过TLS收到的请求，则生成共享私密错误响应，并设置ERROR-CODE属性为响应号433；这里区分两种情况：若通过TCP收到请求，则错误响应通过收到请求的相同连接发送；若通过UDP收到请求，则错误响应发送回请求送出的源IP和端口。</p>\n<p>服务器检查请求中的任何属性，当其中有不理解的小于或等于0x7fff的值，则生成共享私密错误响应，设置ERROR-CODE属性为响应号420,并包括UNKNOWN-ATTRIBUTE属性，列出它不理解的小于或等于0x7fff的属性的值。该错误响应通过TLS连接发送。</p>\n<p>若请求正确，服务器创建共享私密响应，包含与请求中相同的事务ID，并包含USERNAME和PASSWORD属性。用户名在10分钟内有效。</p>\n<p>共享私密响应通过与收到请求的相同的TLS连接发送，服务器保持连接打开状态，由客户关闭它。</p>\n<p>接着，客户发送捆绑请求，携带的属性包括：</p>\n<ul>\n<li>可选属性：RESPONSE-ADDRESS属性和CHANGE-REQUEST属性；</li>\n<li>强制属性：MESSAGE-INTEGRITY属性和USERNAME属性。</li>\n</ul>\n<p>客户发送捆绑请求，通过客户重传来提供可靠性。客户开始用100ms的间隔重传，每次重传间隔加倍，直至1.6秒。之间间隔1.6秒的重传继续，直到收到响应或总共已经发送了9次。因此，若9500ms后，还未收到响应，客户认为传输已经失败。</p>\n<p>服务器检查捆绑请求的MESSAGE-INTEGRITY属性，不存在则生成捆绑错误响应，设置ERROR-CODE属性为响应号401；若存在，计算请求的HMACKey值。</p>\n<p>服务器检查USERNAME属性，不存在则生成捆绑错误响应，设置ERROR-CODE属性为响应号432；若存在，但不认识该USERNAME的共享私密（例如，它超时了），生成捆绑错误响应，设置ERROR-CODE属性为响应号430。</p>\n<p>若服务器知道该共享私密，但所计算的HMAC与请求的不同，生成捆绑错误响应，设置ERROR-CODE属性为响应号431。</p>\n<p>假设消息完整性检查通过了，服务器检查请求中的任何属性的值，若遇到不理解的小于或等于0x7fff的值，生成捆绑错误响应，设置ERROR-CODE属性为响应号420，该响应包含UNKNOWN-ATTRIBUTE属性，并列出不理解的小于或等于0x7fff的属性。</p>\n<p>若请求正确，服务器生成单个捆绑响应，包含与捆绑请求相同的事务ID。服务器在捆绑响应中加入MAPPED-ADDRESS属性，该属性的IP地址和端口号为捆绑请求的源IP地址和端口号。</p>\n<p>捆绑响应的源地址和端口号取决于捆绑请求中CHANGE-REQUEST属性的值及捆绑请求收到的地址和端口号相关。总结如下：</p>\n<p><img src=\"http://www.52im.net/data/attachment/forum/201610/12/112735tq1uhlhhll11qiux.png\" alt=\"image\"></p>\n<p>服务器在捆绑响应中加入SOURCE-ADDRESS属性，包含用于发送捆绑响应的源地址和端口号；加入CHANGED-ADDRESS属性，包含源IP地址和端口号。</p>\n<p>如果捆绑请求中包含了USERNAME和MESSAGE-INTEGRITY属性，则服务器在捆绑响应中加入MESSAGE-INTEGRITY属性。</p>\n<p>如果捆绑请求包含RESPONSE-ADDRESS属性，则服务器在捆绑响应中加入REFLECTED-FROM属性：如果捆绑请求使用从共享私密请求获得的用户名进行认证，则REFLECTED-FROM属性包含共享私密请求到达的源IP地址和端口号；若请求中的用户名不是使用共享私密分配的，则REFLECTED-FROM属性包含获得该用户名的实体的源IP地址和端口号；若请求中没有用户名，且服务器愿意处理该请求，则REFLECTED-FROM属性包含请求发出的源IP地址和端口号。</p>\n<p>服务器不会重传响应，可靠性通过客户周期性地重发请求来保障，每个请求都会触发服务器进行响应。</p>\n<p>客户端判断响应的类型是捆绑错误响应还是捆绑响应。捆绑错误响应通常在请求发送的源地址和端口收到；捆绑响应通常在请求中的RESPONSE-ADDRESS属性的地址和端口收到，若没有该属性，则捆绑响应将在请求发送的源地址和端口号收到。</p>\n<ul>\n<li>若是捆绑错误响应，客户检查响应中的ERROR-CODE属性的响应号：400至499之间的未知属性按属性400处理，500至599之间的未知属性按500处理，600至699之间的未知属性按600处理。任何100和399之间的响应都会使请求重传中止，但其他则忽略；若客户收到响应的属性类型大于0x7fff，则忽略该属性，若小于或等于0x7fff，则请求重传停止，并忽略整个响应；</li>\n<li>若是捆绑响应，客户检查响应的MESSAGE-INTEGRITY属性：如果不存在，客户在请求中加入MESSAGE-INTEGRITY属性，并放弃该响应；如果存在，客户计算响应的HMAC。如果计算出的HMAC与响应中的不同，则放弃该响应，并警告客户可能受到了攻击；若计算出的HMAC与响应中的匹配，则过程继续；</li>\n<li>不论收到捆绑响应还是捆绑错误响应，都将中止该请求的重传。客户在第一次响应后继续监听捆绑请求的响应10秒钟，如果这期间它收到任何消息类型不同的响应或不同的MAPPED-ADDRESS属性，它将警告用户可能受到攻击；并且，如果客户收到的捆绑响应次数超过它发送的捆绑请求数的两倍，它将警告用户可能受到攻击；若捆绑响应经过认证，上述攻击并未导致客户丢弃MAPPED-ADDRESS，则客户可以使用该MAPPED-ADDRESS和SOURCE-ADDRESS属性。</li>\n</ul>\n<blockquote>\n<p>STUN功能举例</p>\n</blockquote>\n<p>客户通过带外方式获得STUN服务器信息后，就打开对应的地址和端口的连接，并开始与STUN服务器进行TLS协商。一旦打开了连接，客户就通过TCP协议发送共享私密请求，服务器生成共享私密响应。STUN在客户和服务器间使用共享私密，用作捆绑请求和捆绑响应中的密匙。之后，客户使用UDP协议向STUN服务器发送捆绑请求，当捆绑请求消息到达服务器的时候，它可能经过了一个或者多个NAT。结果是STUN服务器收到的捆绑请求消息的源IP地址被映射成最靠近STUN服务器的NAT的IP地址，STUN服务器把这个源IP地址和端口号复制到一个捆绑响应消息中，发送回拥有这个IP地址和端口号的客户端。</p>\n<p>当STUN客户端收到捆绑响应消息之后，它会将自己发送捆绑请求时绑定的本地IP地址和端口号同捆绑响应消息中的IP地址和端口号进行比较，如果不匹配，就表示客户端正处于一个或者多个NAT的前面。</p>\n<p>在Full-Cone NAT的情况下，在捆绑响应消息中的IP地址和端口是属于公网的，公网上的任何主机都可以使用这个IP地址和端口号向这个应用程序发送数据包，应用程序只需要在刚才发送捆绑请求的IP地址和端口上监听即可。</p>\n<p>当然，客户可能并不在一个Full-Cone NAT的前面，实际上，它并不知道自己在一个什么类型的NAT的前面。为了确定NAT的类型，客户端使用附加的捆绑请求。具体过程是很灵活的，但一般都会像下面这样工作：客户端再发送一个捆绑请求，这次发往另一个IP地址，但是使用的是跟上一次同一个源IP地址和源端口号，如果返回的数据包里面的IP地址和端口号和第一次返回的数据包中的不同，客户端就会知道它是在一个对称NAT的前面。客户端为了确认自己是否在一个完全锥形NAT的前面，客户端可以发送一个带有标志的捆绑请求，这个标志告诉服务器使用另一个IP地址和端口发送捆绑响应。换句话说，如果客户端使X/Y的IP地址端口对向A/B的IP地址端口对发送捆绑请求，服务器就会使用源IP地址和源端口号为C/D的地址端口对向X/Y发送捆绑响应。如果客户端收到了这个响应，它就知道它是在一个Full-Cone NAT前面。</p>\n<p>STUN协议允许客户端请求服务器从收到捆绑请求的IP地址往回发捆绑响应，但是要使用不同的端口号。这可以用来检查客户端是否在Port Restricted Cone NAT的前面还是在Restricted Cone NAT的前面。</p>\n<h3 id=\"2-2-RFC5389-STUN\"><a href=\"#2-2-RFC5389-STUN\" class=\"headerlink\" title=\"2.2 RFC5389/STUN\"></a>2.2 RFC5389/STUN</h3><p>STUN协议在RFC5389中被重新命名为Session Traversal Utilities for NAT，即NAT会话穿透效用。在这里，NAT会话穿透效用被定位为一个用于其他解决NAT穿透问题协议的协议。它可以用于终端设备检查由NAT分配给终端的IP地址和端口号。同时，它也被用来检查两个终端之间的连接性，好比是一种维持NAT绑定表项的保活协议。STUN可以用于多种NAT类型，并不需要它们提供特殊的行为。</p>\n<p>STUN本身不再是一种完整的NAT穿透解决方案，它相当于是一种NAT穿透解决方案中的工具。这是与RFC3489/STUN版本相比最重要的改变。</p>\n<blockquote>\n<p>STUN用途</p>\n</blockquote>\n<p>目前定义了三种STUN用途：</p>\n<ul>\n<li>Interactive Connectivity Establishment（ICE）[MMUSIC-ICE]，交互式连接建立</li>\n<li>Client-initiated connections for SIP [SIP-OUTBOUND]，用于SIP的客户端初始化连接</li>\n<li>NAT Behavior Discovery [BEHAVE-NAT]，NAT行为发现</li>\n</ul>\n<blockquote>\n<p>报文结构</p>\n</blockquote>\n<p>【Ø  消息头】</p>\n<p>STUN消息头为20字节，后面紧跟0或多个属性。STUN头部包含一STUN消息类型、magic cookie、事务ID和消息长度。</p>\n<p><img src=\"http://www.52im.net/data/attachment/forum/201610/12/114036v0l0xcxjj6l6lc94.png\" alt=\"image\"></p>\n<p>每个STUN消息的最高位前2位必须为0。当STUN协议为多个协议多路复用时若使用的是同一个端口，这可以用于与其他协议区分STUN数据包。消息类型确定消息的类别（如请求、成功回应、失败回应、标志）。虽然这里有四种消息类型，但可以分为2类事务：请求/响应事务、标志事务。</p>\n<p>消息类型字段可进一步划分为下面结构：</p>\n<p><img src=\"http://www.52im.net/data/attachment/forum/201610/12/113902e1ci02g21bks8cmf.png\" alt=\"image\"></p>\n<p>消息类型定义如下：</p>\n<ul>\n<li>0b00，表示请求</li>\n<li>0b01，表示标志</li>\n<li>0b10，表示成功响应</li>\n<li>0b11，表示错误响应</li>\n</ul>\n<p>魔术字域必须包含固定的值0x2112A442。在RFC3489中，该域是事务ID的一部分。配置魔术字允许服务器检测客户是否理解某些在改进的版本中增加的属性。另外，还可用于STUN多路复用时与其他协议的包进行区分。</p>\n<p>96位的事务ID用于唯一的识别STUN事务。对于请求/响应事务，事务ID由STUN客户端来选择；对于标志事务，由代理（代理指支持STUN的客户端或服务器）来选择并发送。它主要服务于与请求相关的响应，因此它也扮演着一个帮助阻止确定类型的攻击的角色。服务器使用事务ID来唯一的标识出所有客户端的每一个事务。事务ID本身必须是唯一的，并且随机的从0到2的96-1次方中选择。重新发送相同的请求时，也必须使用新的事务ID。成功或错误响应必须携带与相对应的请求相同的事务ID。</p>\n<p>消息长度字段不包括20字节的STUN头部。所有的STUN属性必须填充为4字节的倍数。消息长度字段的最后2位总是为0，这为区分STUN包与其他协议的包提供了另外一种方法。</p>\n<p>【Ø  消息属性】</p>\n<p>STUN头之后是0或多个属性。每个属性都采用TLV编码，16位的类型、16位的长度及可变长度的值。每个STUN属性必须是4字节边界对齐。</p>\n<p><img src=\"http://www.52im.net/data/attachment/forum/201610/12/114019vcfzuicfi6vumdfz.png\" alt=\"image\"></p>\n<p>属性空间被划分为2个范围。属性的类型值在0x0000到0x7fff是强制理解属性，这意味着除非STUN代理能够理解这些属性，否则将不能正常处理包含该属性的消息；属性的类型值在0x8000到0xffff范围是可选理解属性，这意味着如果STUN代理不能理解它们的话这些属性可以被忽略。</p>\n<p>STUN属性类型集由IANA维护，具体定义详见IETF官方文档 RFC5389。</p>\n<h3 id=\"2-3-RFC5389与RFC3489的区别\"><a href=\"#2-3-RFC5389与RFC3489的区别\" class=\"headerlink\" title=\"2.3 RFC5389与RFC3489的区别\"></a>2.3 RFC5389与RFC3489的区别</h3><p>RFC5389与RFC3489的不同点如下：</p>\n<ul>\n<li>去掉STUN是一种完整的NAT穿透方案的概念，现在是一种用于提供NAT穿透解决方案的工具。因而，协议的名称变为NAT会话穿透效用；</li>\n<li>定义了STUN的用途；</li>\n<li>去掉了STUN关于NAT类型检测和绑定生命期发现的用法，去掉了RESPONSE-ADDRESS、CHANGED-ADDRESS、CHANGE-REQUEST、SOURCE-ADDRESS和REFLECTED-FROM属性；</li>\n<li>增加了一个固定的32位的魔术字字段，事务ID字段减少了32位长度；</li>\n<li>增加了XOR-MAPPED-ADDRESS属性，若魔术字在捆绑请求中出现时，该属性包括在捆绑响应中。否则，RFC3489中的行为是保留的（换句话说，捆绑响应中包括MAPPED-ADDRESS）；</li>\n<li>介绍了消息类型字段的正式结构，带有一对明确的位来标识Request、Response、Error-Response或Indication消息。因此，消息类型字段被划分为类别和方法两部分；</li>\n<li>明确的指出了STUN的最高2位是0b00，当用于ICE时可以简单的与RTP包区分开来；</li>\n<li>增加指纹属性来提供一种明确的方法来检测当STUN协议多路复用时，STUN与其他协议之间的差异；</li>\n<li>增加支持IPv6，IPv4客户端可以获取一个IPv6映射地址，反之亦然；</li>\n<li>增加一个long-term-credential-based认证机制；</li>\n<li>增加了SOFTWARE、REALM、NONCE和ALTERNATE-SERVER属性；</li>\n<li>去掉了共享密匙方法，因此PASSWORD属性也去掉了；</li>\n<li>去掉了使用连续10秒侦听STUN响应来识别一个攻击的做法；</li>\n<li>改变事务计时器来增加TCP友好性；</li>\n<li>去掉了STUN例子如集中分离控制和媒体面，代替的，在使用STUN协议时提供了更多的信息；</li>\n<li>定义了一类填充机制来改变长度属性的说明；</li>\n<li>REALM、SERVER、原因语句和NONCE限制在127个字符，USERNAME限制在513个字节以内；</li>\n<li>为TCP和TLS改变了DNS SRV规程，UDP仍然和以前保持一致。</li>\n</ul>\n<p>IETF官文档，详见：RFC5389、RFC3489。</p>\n<h3 id=\"2-4-新特性介绍\"><a href=\"#2-4-新特性介绍\" class=\"headerlink\" title=\"2.4 新特性介绍\"></a>2.4 新特性介绍</h3><blockquote>\n<p>指纹机制</p>\n</blockquote>\n<p>FINGERPRINT机制是一种可选的用于其他协议多路复用STUN时发送给相同的传输地址时区分STUN数据包的机制，该机制不支持与RFC3489相兼容。</p>\n<p>在一些用途中，基于相同的传输地址时多个协议会多路复用STUN消息，例如RTP协议。STUN消息必须首先和应用报文分离开。目前，在STUN报头中有3种固定的字段可以用于该目的。尽管如此，在一些案例中，三种固定字段仍然不能充分的区别开。</p>\n<p>当扩展的指纹机制被使用时，STUN代理在发送给其他STUN代理的消息中包括FINGERPRINT属性。当其他STUN代理收到时，除基本的检查之外，还将检查是否包含FINGERPRINT属性及它是否包含正确的值，至此，它将相信这是一个STUN消息。指纹机制帮助STUN代理检查其他协议那些看起来像是STUN消息的消息。</p>\n<blockquote>\n<p>通过DNS发现服务器机制</p>\n</blockquote>\n<p>STUN客户端可以使用DNS来发现STUN服务器的IP地址和端口。客户端必须知道服务器的域名。</p>\n<p>当客户端希望找出服务器在公网上的位置就采用捆绑请求/响应事务，SRV（资源记录表）中服务器名称是“stun”。当通过TLS会话采用捆绑请求/响应事务，SRV中服务器名称为“stuns”。STUN用户可以定义额外的DNS资源记录服务名称。</p>\n<p>STUN请求的默认端口是3478，用于TCP和UDP。STUN在TLS上的默认端口是5349。服务器能够在TLS上运行STUN与STUN在TCP上时使用相同的端口，只有服务器软件支持决定初始消息是否是TLS或STUN消息。</p>\n<p>如果SRV中没有记录可查，客户端执行A或AAAA记录查找域名。结果将会是1张IP地址表，每一个都可以使用TCP或UDP采用默认端口号连接。通常要求使用TLS，客户端使用STUN在TLS上的默认端口号连接其中一个IP地址。</p>\n<blockquote>\n<p>认证和消息完整性机制</p>\n</blockquote>\n<ul>\n<li>短期证书机制</li>\n</ul>\n<p>短期证书机制假设在STUN事务之前，客户端和服务器已经使用了其他协议来交换了证书，以username和password形式。这个证书是有时间限制的。例如，在ICE用途中，两个终端使用带外方式交换信息来对username和password达成一致，并在媒体会话期间使用。这个证书被用来进行消息完整性检查，用于每个请求和多个响应中。与长期证书机制相比，没有挑战和响应方式，因此，这种证书的时间限制特性的优点是可以阻止重播。</p>\n<ul>\n<li>长期证书机制</li>\n</ul>\n<p>长期证书机制依赖于一个长期证书，username和password在客户端和服务器中是共用的。这个证书从它提供给 用户开始将一直是有效的，直到该用户不再是该系统的用户。这本质上是一个提供给用户username和password的传统的登入方式。    </p>\n<p>客户端初始发送一个请求，没有提供任何证书和任何完整性检测。服务器拒绝这个请求，并提供给用户一个范围（用于指导用户或代理选择username和password）和一个nonce。这个nonce提供重放保护。它是一个cookie，由服务器选择，以这样一种方式来标示有效时间或客户端身份是有效的。客户端重试这个请求，这次包括它的username和realm和服务器提供的nonce来回应。服务器确认这个nonce和检查这个message integrity。如果它们匹配，请求则通过认证。如果这个nonce不再有效，即过期了，服务器就拒绝该请求，并提供一个新的nonce。</p>\n<p>在随后的到同一服务器的请求，客户端重新使用这个nonce、username和realm，和先前使用的password。这样，随后的请求不会被拒绝直到这个nonce变成无效的。需要注意的是，长期证书机制不能用来保护Indications，由于Indications不能被改变，因此，使用Indications时要么使用短期证书，要么就省略认证和消息完整性。因为长期证书机制对离线字典攻击敏感，部署的时候应该使用很难猜测的密码。</p>\n<blockquote>\n<p>备份服务器机制</p>\n</blockquote>\n<p>服务器使用增强的重定向功能将一个客户端转向另一个服务器，通过回应一个错误响应号为300（尝试备份）的错误响应。服务器在错误响应中携带一个ALTERNATE-SERVER属性。</p>\n<p>客户端收到错误响应号为300的错误响应后，在该响应中查找ALTERNATE-SERVER属性。若找到一个，客户端就会将当前的事务作废，并重新尝试发送请求到该属性中列出的服务器。请求报文若已经通过认证，则必须使用与先前发送给执行重定向操作的服务器同样的证书。如果客户端在最后5分钟里已经重试发送请求时已经重定向到了一个服务器，它必须忽略重定向操作并将当前的事务作废，这是为了防止无限的重定向循环。</p>\n<h3 id=\"2-5-RFC5389与RFC3489的兼容\"><a href=\"#2-5-RFC5389与RFC3489的兼容\" class=\"headerlink\" title=\"2.5 RFC5389与RFC3489的兼容\"></a>2.5 RFC5389与RFC3489的兼容</h3><p>在RFC3489中：</p>\n<ul>\n<li>UDP是唯一支持的传输协议</li>\n<li>RFC5389中的魔术字字段是RFC3489中事务ID的一部分，事务ID长128位</li>\n<li>没有XOR-MAPPED-ADDRESS属性，绑定方法是使用MAPPED-ADDRESS属性代替</li>\n<li>有3个需要强制理解的属性，分别是：RESPONSE-ADDRESS、CHANGE-REQUEST、CHANGED-ADDRESS属性，而RFC5389中不再支持这些属性。</li>\n</ul>\n<blockquote>\n<p>客户端处理的改变</p>\n</blockquote>\n<p>客户端想要与RFC3489的服务器互操作，应发送一个使用绑定方法的请求消息，不包含任何消息，使用UDP协议发送给服务器。如果成功，将收到服务器发回的包含MAPPED-ADDRESS属性而不是XOR-MAPPED-ADDRESS属性的成功响应。客户端试图与基于RFC3489的应用服务器互操作必须准备好接收任意一个属性。此外，客户端必须忽略任何在响应中出现的保留的强制理解的属性。RFC3489中规定保留属性中的0x0002、0x0004、0x0005和0x000B可能出现在绑定响应中。</p>\n<blockquote>\n<p>服务器处理的改变</p>\n</blockquote>\n<p>服务器能够察觉由RFC3489中的客户端发送的携带有不正确的魔术字的捆绑请求消息。当服务器察觉到RFC3489中的客户端，它应该将捆绑请消息中魔术字域中的值拷贝到捆绑响应中的魔术字字段中，并且插入一个MAPPED-ADDRESS属性代替XOR-MAPPED-ADDRESS属性。</p>\n<p>客户端在极少的环境下可能包括RESPONSE-ADDRESS或CHANGE-REQUEST属性中的一个。在这些情况下，服务器把这些属性看做是一个不认识的强制理解的属性，并回应一个错误响应。RFC3489版本中的STUN缺少魔术字和指纹属性这两种能够高可靠性的正确标识其他协议多路复用时的STUN消息。因此，STUN执行与RFC3489兼容时不应该被用于多个协议。</p>\n<h2 id=\"3、TURN详解\"><a href=\"#3、TURN详解\" class=\"headerlink\" title=\"3、TURN详解\"></a>3、TURN详解</h2><h3 id=\"3-1-RFC5766-TURN\"><a href=\"#3-1-RFC5766-TURN\" class=\"headerlink\" title=\"3.1 RFC5766/TURN\"></a>3.1 RFC5766/TURN</h3><p>TURN，在RFC5766中定义，英文全称Traversal Using Relays around NAT（TURN）：Relay Extensions to Session Traversal Utilities for NAT（STUN），即使用中继穿透NAT：STUN的中继扩展。简单的说，TURN与STUN的共同点都是通过修改应用层中的私网地址达到NAT穿透的效果，异同点是TURN是通过两方通讯的“中间人”方式实现穿透。</p>\n<p>如果一个主机位于NAT的后面，在某些情况下它不能够与其他主机点对点直接连接。在这些情况下，它需要使用中间网点提供的中继连接服务。TURN协议就是用来允许主机控制中继的操作并且使用中继与对端交换数据。TURN与其他中继控制协议不同的是它能够允许一个客户端使用一个中继地址与多个对端连接。</p>\n<p>TURN协议被设计为ICE的一部分，用于NAT穿越，虽然如此，它也可以在没有ICE的地方单独使用。</p>\n<h3 id=\"3-2-操作概述\"><a href=\"#3-2-操作概述\" class=\"headerlink\" title=\"3.2 操作概述\"></a>3.2 操作概述</h3><p><img src=\"http://www.52im.net/data/attachment/forum/201610/12/115151bn2gxe2p96x612x2.jpg\" alt=\"image\"></p>\n<p>在一个典型组网中，一个TURN客户端连接在一个私有网络中，通过一个或多个NAT来连接到公网。在公网中有一个TURN服务器。在因特网的别处有一个或多个对端是这个TURN客户端希望通讯的。这些对端也有可能是在一个或多个NAT的后面。该客户端使用服务器作为一个中继来发送数据包 到这些对端去，并且从这些对端接收数据包。</p>\n<p>客户端通过一个IP地址和端口的组合来与服务器建立会话。客户端使用TURN命令在服务器上创建和操作一个ALLOCATION。一旦这个allocation创建好了，客户端能够在数据发往哪个对端的指示下发送应用数据到这个服务器，服务器将中继这些数据到合适的对端。客户端发送的应用数据包含在TURN消息中，服务器将数据提取出来，并以UDP数据包方式发送给对端。反向上，对端以UDP数据包方式发送应用数据到这个allocation提供的中继传输地址。因为TURN消息总是包含客户端与哪些对端通讯的指示，客户端能够使用单一的allocation来与多个对端通讯。</p>\n<h3 id=\"3-3-术语\"><a href=\"#3-3-术语\" class=\"headerlink\" title=\"3.3 术语\"></a>3.3 术语</h3><ul>\n<li>TURN client：遵循RFC5766的STUN客户端。</li>\n<li>TURN server：遵循RFC5766的STUN服务器。</li>\n<li>Peer：TURN客户端希望连接的主机。TURN服务器为TURN客户端和它的对端中继流量，但Peer并不与TURN服务器使用TURN协议进行交互，它接收从TURN服务器发送过来的数据，并向TURN服务器发送数据。</li>\n<li>Transport Address：IP地址与端口号的组合。</li>\n<li>Host Transport Address：客户端或对端的传输地址。</li>\n<li>Server-Reflexive Transport Address：NAT公网侧的传输地址，该地址由NAT分配，相当于一个特定的主机传输地址。</li>\n<li>Relayed Transport Address：TURN服务器上的传输地址，用于客户端和对端中继数据。</li>\n<li>TURN Server Transport Address：TURN服务器上的传输地址，用于客户端发送STUN消息给服务器。</li>\n<li>Peer Transport Address：服务器看到的对端的传输地址，当对端是在NAT后面，则是对端的服务器反射传输地址。</li>\n<li>Allocation：通过Allocate请求将中继传输地址提供给客户端，除了中继状态外，还有许可和超时定时器等。</li>\n<li>5-tuple：五元组，包括客户端IP地址和端口，服务器IP地址和端口和传输协议（包括UDP、TCP、TLS）的组合。</li>\n<li>Channel：通道号与对端传输地址的关联，一旦一个通道号与一个对端的传输地址绑定，客户端和服务器就能够利用带宽效应更大的通道数据消息来交换数据。</li>\n<li>Permission：一个对端允许使用它的IP地址和传输协议来发送数据到TURN服务器，服务器只为从对端发来的并且匹配一个已经存在的许可的流量中继到相应的客户端。</li>\n<li>Realm：服务器内用于描述服务器或内容的一个字符串，这个realm告诉客户端哪些用户名和密码的组合可用于认证请求。</li>\n<li>Nonce：服务器随机选择的一个字符串，包含在报文摘要中。为了防止中继攻击，服务器应该有规律的改变这个nonce。</li>\n</ul>\n<p>具体协议细节，详见IETF官方文档：RFC5766.</p>\n<h3 id=\"3-4-协议交互过程详细举例\"><a href=\"#3-4-协议交互过程详细举例\" class=\"headerlink\" title=\"3.4 协议交互过程详细举例\"></a>3.4 协议交互过程详细举例</h3><p>以上图为例进行讲解，每个消息中，多个属性包含在消息中并显示它们的值。为了方便阅读，值以人们可读的格式来显示。</p>\n<p><img src=\"http://www.52im.net/data/attachment/forum/201610/12/115958r41hgy1uht78nazu.jpg\" alt=\"image\"></p>\n<p>客户端使用10.1.1.2:49271作为传输地址向服务器的传输地址发送Allocate请求。客户端随机选择一个96位的事务ID。该Allocate请求消息包括SOFTWARE属性来提供客户端的软件版本信息；包括LIFETIME属性，指明客户端希望该allocation具有1小时的生命期而非缺省的10分钟；包括REQUESTED-TRANSPORT属性来告诉服务器与对端之间采用UDP协议来传输；包括DONT-FRAGMENT属性因为客户端希望在随后的Send indications中使用DON’T-FRAGMENT属性。</p>\n<p>服务器需要任何请求必须是经过认证的，因此服务器拒绝了该最初的Allocation请求，并且回应了携带有错误响应号为401（未授权）的Allocate错误响应；该响应包括一个REALM属性，指明认证的域；还包括一个NONCE属性和一个SOFTWARE属性。</p>\n<p>客户端收到了错误响应号为401的Allocate错误响应，将重新尝试发送Allocate请求，此时将包括认证属性。客户端在新的请求中重新选择一个新的事务ID。客户端包括一个USERNAME属性，使用从服务器那收到的realm值来帮助它决定使用哪个值；请求还包括REALM和NONCE属性，这两个属性是从收到的错误响应中拷贝出来的。最后，客户端包括一个MESSAGE-INTEGRITY属性。</p>\n<p>服务器收到认证的Allocate请求后，检查每个属性是否正确；然后，产生一个allocation，并给客户端回应Allocate成功响应。服务器在该成功响应中携带一个LIFETIME属性，本例中服务器将客户端请求的1小时生命期减小为20分钟，这是因为这个特定的服务器可能不允许超过20分钟的生命期；该响应包括XOR-RELAYED-ADDRESS属性，值为该allocation的中继传输地址；该响应还包括XOR-MAPPED-ADDRESS属性，值为客户端的server-reflexive地址；该响应也包含一个SOFTWARE属性；最后，包括一个MESSAGE-INTEGRITY属性来证明该响应，确保它的完整性。</p>\n<p><img src=\"http://www.52im.net/data/attachment/forum/201610/12/120031zi6vsrvx24ssg42i.jpg\" alt=\"image\"></p>\n<p>接着，客户端为了准备向对端A发送一些应用数据而创建一个permission。这里通过一个CreatePermission请求来做到。该请求携带XOR-PEER-ADDRESS属性包含有确定的请求的IP地址，这里为对端A的地址；需要注意的是，属性中地址的端口号被设置为0在CreatePermission请求中，并且客户端使用的是对端A的server-reflexive地址而不是它的主机地址（私网地址）；客户端在该请求中携带与之前的Allocate请求中一样的username、realm和nonce值，因此该请求被服务器认可。此时在该请求中，客户端没有携带SOFTWARE属性。</p>\n<p>服务器收到该CreatePermission请求，产生一个相应的许可，并以CreatePermission成功响应来回应。该响应中只包含了Transaction-ID和MESSAGE-INTEGRITY属性。</p>\n<p><img src=\"http://www.52im.net/data/attachment/forum/201610/12/120053ks33633olaxnpi4l.jpg\" alt=\"image\"></p>\n<p>现在客户端使用Send indication来发送应用数据到对端A。对端的server-reflexive传输地址包含在XOR-PEER-ADDRESS属性中，应用数据包含在DATA属性中。客户端已经在应用层上执行了路径MTU发现功能，因此通过DON’T-FRAGMENT属性来告知服务器当通过UDP方式来向对端发送数据时应设置DF位。Indications不能使用长期证书机制来认证，所以该消息中没有MESSAGE-INTEGRITY属性。</p>\n<p>服务器收到Send indication后，提取出应用数据封装成UDP格式发给对端A；UDP报文的源传输地址为中继传输地址，并设置DF位。</p>\n<p>对端A回应它自己的包含有应用数据的UDP包给服务器。目的地址为服务器的中继传输地址。当服务器收到后，将生成Data indication消息给客户端，携带有XOR-PEER-ADDRESS属性。应用数据包含在DATA属性中。</p>\n<p><img src=\"http://www.52im.net/data/attachment/forum/201610/12/120117zf5gi0ka7fw5o57e.jpg\" alt=\"image\"></p>\n<p>客户端现在若要绑定一个通道到对端B，将指定一个空闲的通道号（本例中为0x4000）包含在CHANNEL-NUMBER属性中，对端B的传输地址包含在XOR-PEER-ADDRESS属性中。与以前一样，客户端再次利用上次请求中的username、realm和nonce。</p>\n<p>当服务器收到该请求后，服务器绑定这个对端的通道号，为对端B的IP地址安装一个permission，然后给客户端回应一个ChannelBind成功响应消息。</p>\n<p><img src=\"http://www.52im.net/data/attachment/forum/201610/12/120134g98040e74ziwfiwz.jpg\" alt=\"image\"></p>\n<p>客户端现在发送一个ChannelData消息给服务器，携带有发送给对端B的数据。这个消息不是一个STUN消息，因此没有事务ID。它之有3个字段：通道号、数据、数据长度；服务器收到后，检查通道号后发现当前已经绑定了，就以UDP方式发送数据给对端B。</p>\n<p>接着，对端B发送UDP数据包回应给服务器的中继传输地址。服务器收到后，回应给客户端ChannelData消息，包含UDP数据包中的数据。服务器知道是给哪个客户端发送ChannelData消息，这是因为收到的UDP数据包中的目的地址（即服务器的中继传输地址），并且知道使用的是哪个通道号，这是因为通道已经与相应的传输地址绑定了。</p>\n<p><img src=\"http://www.52im.net/data/attachment/forum/201610/12/120157sixfnelrqciqexgd.jpg\" alt=\"image\"></p>\n<p>有时候，20分钟的生命期已经到了，客户端需要刷新allocation。此时通过发送Refresh请求来进行。该请求包含最后一次使用的username、realm和nonce，还包含SOFTWARE属性。当服务器收到这个Refresh请求时，它注意到这个nonce值已经超期了，则给客户端回应一个错误响应号为438（过期Nonce）的Refresh错误响应，并提供一个新的nonce值。可护端将重试该请求，此时携带新的nonce值。若第二次尝试被接受，服务器将回应一个成功响应。需要注意的是，此时客户端在请求中没有携带LIFETIME属性，所以服务器刷新客户端的allocation时采用缺省的10分钟生命期。</p>\n<h2 id=\"4、ICE简明介绍\"><a href=\"#4、ICE简明介绍\" class=\"headerlink\" title=\"4、ICE简明介绍\"></a>4、ICE简明介绍</h2><h3 id=\"4-1-简介\"><a href=\"#4-1-简介\" class=\"headerlink\" title=\"4.1 简介\"></a>4.1 简介</h3><p>ICE的全称Interactive Connectivity Establishment（互动式连接建立），由IETF的MMUSIC工作组开发出来的，它所提供的是一种框架，使各种NAT穿透技术可以实现统一。ICE跟STUN和TURN不一样，ICE不是一种协议，而是一个框架（Framework），它整合了STUN和TURN。</p>\n<h3 id=\"4-2-应用模型\"><a href=\"#4-2-应用模型\" class=\"headerlink\" title=\"4.2 应用模型\"></a>4.2 应用模型</h3><p><img src=\"http://www.52im.net/data/attachment/forum/201610/12/120427sj60zrara770aql5.png\" alt=\"image\"></p>\n<p>如上图所示，如果A想与B通信，那么其过程如下：</p>\n<ul>\n<li>A收集所有的IP地址，并找出其中可以从STUN服务器和TURN服务器收到流量的地址；</li>\n<li>A向STUN服务器发送一份地址列表，然后按照排序的地址列表向B发送启动信息，目的是实现节点间的通信；</li>\n<li>B向启动信息中的每一个地址发送一条STUN请求；</li>\n<li>A将第一条接收到的STUN请求的回复信息发送给B；</li>\n<li>B接到STUN回复后，从中找出那些可在A和B之间实现通信的地址；</li>\n<li>用列表中的排序列最高的地址进一步的设备间通信。</li>\n</ul>\n<p>由于该技术是建立在多种NAT穿透协议的基础之上，并且提供了一个统一的框架，所以ICE具备了所有这些技术的优点，同时还避免了任何单个协议可能存在的缺陷。因此，ICE可以实现在未知网络拓扑结构中实现的设备互连，而且不需要进行对手配置。另外，由于该技术不需要为VoIP流量手动打开防火墙，所以也不会产生潜在的安全隐患。</p>\n<h2 id=\"5、本文总结\"><a href=\"#5、本文总结\" class=\"headerlink\" title=\"5、本文总结\"></a>5、本文总结</h2><p>在现实Internet网络环境中，大多数计算机主机都位于防火墙或NAT之后，只有少部分主机能够直接接入Internet。很多时候，我们希望网络中的两台主机能够直接进行通信（即所谓的P2P通信），而不需要其它公共服务器的中转。由于主机可能位于防火墙或NAT之后，在进行P2P通信之前，我们需要进行检测以确认它们之间能否进行P2P通信以及如何通信。这种技术通常被称为NAT穿透（NAT Traversal）。</p>\n<p>RFC3489中定义的STUN，即简单地用UDP穿过NAT（STUN）是个轻量级的协议。它允许应用发现它们与公共互联网之间存在的NAT和防火墙及其他类型。它还为应用提供判断NAT给它们分配的公共网际协议（IP）地址。STUN可工作在许多现存NAT上，并且不需要它们做任何特别的行为。它允许广泛的各类的应用穿越现存的NAT设施。</p>\n<p>RFC5389中对STUN协议进行了修订，将其定位于为穿透NAT提供工具，即NAT会话穿透效用是一个用于其他解决NAT穿透问题协议的协议。它可以用于终端设备检查由NAT分配给终端的IP地址和端口号。同时，它也被用来检查两个终端之间的连接性，好比是一种维持NAT绑定表项的保活协议。STUN本身并不是一种完整的NAT穿透解决方案。它相当于是一种NAT穿透解决方案中的工具。这是与先前的版本相比最重要的改变。之前的RFC3489中定义的STUN是一个完整的穿透NAT解决方案。此外，最大的区别是支持TCP穿透。</p>\n<p>RFC5766中对STUN协议再次进行了扩展，即中继穿透NAT：STUN的扩展。TURN与STUN的共同点都是通过修改应用层中的私网地址达到NAT穿透的效用，异同点是TUN采用了两方通讯的“中间人”方式实现穿透，突破了原先STUN协议无法在两台主机不能够点对点直接连接下提供作用的限制。</p>\n<p>技术无止境，NAT穿透技术仍在不断更新中，这里只对STUN/TURN协议作了简单的介绍，具体细节请参考RFC3489/5389/5766。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"1、内容概述\"><a href=\"#1、内容概述\" class=\"headerlink\" title=\"1、内容概述\"></a>1、内容概述</h2><p>在现实Internet网络环境中，大多数计算机主机都位于防火墙或NAT之后，只有少部分主机能够直接接入Internet。很多时候，我们希望网络中的两台主机能够直接进行通信，即所谓的P2P通信，而不需要其他公共服务器的中转。由于主机可能位于防火墙或NAT之后，在进行P2P通信之前，我们需要进行检测以确认它们之间能否进行P2P通信以及如何通信。这种技术通常称为NAT穿透（NAT Traversal）。最常见的NAT穿透是基于UDP的技术，如RFC3489中定义的STUN协议。</p>\n<p>STUN，首先在RFC3489中定义，作为一个完整的NAT穿透解决方案，英文全称是Simple Traversal of UDP Through NATs，即简单的用UDP穿透NAT。</p>\n<p>在新的RFC5389修订中把STUN协议定位于为穿透NAT提供工具，而不是一个完整的解决方案，英文全称是Session Traversal Utilities for NAT，即NAT会话穿透效用。RFC5389与RFC3489除了名称变化外，最大的区别是支持TCP穿透。</p>\n<p>TURN，首先在RFC5766中定义，英文全称是Traversal Using Relays around NAT:Relay Extensions to Session Traversal Utilities for NAT，即使用中继穿透NAT:STUN的扩展。简单的说，TURN与STURN的共同点都是通过修改应用层中的私网地址达到NAT穿透的效果，异同点是TURN是通过两方通讯的“中间人”方式实现穿透。</p>\n<p>ICE跟STUN和TURN不一样，ICE不是一种协议，而是一个框架（Framework），它整合了STUN和TURN。</p>\n<h2 id=\"2、STUN详解\"><a href=\"#2、STUN详解\" class=\"headerlink\" title=\"2、STUN详解\"></a>2、STUN详解</h2><p>了解STUN之前，我们需要了解NAT的种类。</p>\n<p>NAT对待UDP的实现方式有4种，分别如下：</p>","more":"<p>Full Cone NAT：</p>\n<blockquote>\n<p>完全锥形NAT，所有从同一个内网IP和端口号发送过来的请求都会被映射成同一个外网IP和端口号，并且任何一个外网主机都可以通过这个映射的外网IP和端口号向这台内网主机发送包。</p>\n</blockquote>\n<p>Restricted Cone NAT：</p>\n<blockquote>\n<p>限制锥形NAT，它也是所有从同一个内网IP和端口号发送过来的请求都会被映射成同一个外网IP和端口号。与完全锥形不同的是，外网主机只能够向先前已经向它发送过数据包的内网主机发送包。</p>\n</blockquote>\n<p>Port Restricted Cone NAT：</p>\n<blockquote>\n<p>端口限制锥形NAT，与限制锥形NAT很相似，只不过它包括端口号。也就是说，一台IP地址X和端口P的外网主机想给内网主机发送包，必须是这台内网主机先前已经给这个IP地址X和端口P发送过数据包。</p>\n</blockquote>\n<p>Symmetric NAT：</p>\n<blockquote>\n<p>对称NAT，所有从同一个内网IP和端口号发送到一个特定的目的IP和端口号的请求，都会被映射到同一个IP和端口号。如果同一台主机使用相同的源地址和端口号发送包，但是发往不同的目的地，NAT将会使用不同的映射。此外，只有收到数据的外网主机才可以反过来向内网主机发送包。</p>\n</blockquote>\n<h3 id=\"2-1-RFC3489-STUN\"><a href=\"#2-1-RFC3489-STUN\" class=\"headerlink\" title=\"2.1 RFC3489/STUN\"></a>2.1 RFC3489/STUN</h3><p>STUN（Simple Traversal of User Datagram Protocol Through Network Address Translators），即简单的用UDP穿透NAT，是个轻量级的协议，是基于UDP的完整的穿透NAT的解决方案。它允许应用程序发现它们与公共互联网之间存在的NAT和防火墙及其他类型。它也可以让应用程序确定NAT分配给它们的公网IP地址和端口号。STUN是一种Client/Server的协议，也是一种Request/Response的协议，默认端口号是3478。（IETF官方文档RFC3489/STUN点此进入）</p>\n<ul>\n<li>报文结构</li>\n</ul>\n<p>【Ø  消息头】</p>\n<p>所有的STUN消息都包含20个字节的消息头，包括16位的消息类型，16位的消息长度和128位的事务ID。</p>\n<p><img src=\"http://www.52im.net/data/attachment/forum/201610/12/112409m1f0zv1t36x1jfbf.png\" alt=\"image\"></p>\n<p>消息类型许可的值如下：</p>\n<p>0x0001：捆绑请求</p>\n<p>0x0101：捆绑响应</p>\n<p>0x0111：捆绑错误响应</p>\n<p>0x0002：共享私密请求</p>\n<p>0x0102：共享私密响应</p>\n<p>0x0112：共享私密错误响应</p>\n<p>消息长度，是消息大小的字节数，但不包括20字节的头部。事务ID，128位的标识符，用于随机请求和响应，请求与其相应的所有响应具有相同的标识符。</p>\n<p>【Ø  消息属性】</p>\n<p>消息头之后是0或多个属性，每个属性进行TLV编码，包括16位的属性类型、16位的属性长度和变长属性值。</p>\n<p><img src=\"http://www.52im.net/data/attachment/forum/201610/12/112409kqyke5fxgkccfwqv.png\" alt=\"image\"></p>\n<p>属性类型定义如下：</p>\n<ul>\n<li>MAPPED-ADDRESS：MAPPED-ADDRESS属性表示映射过的IP地址和端口。它包括8位的地址族，16位的端口号及长度固定的IP地址。</li>\n<li>RESPONSE-ADDRESS：RESPONSE-ADDRESS属性表示响应的目的地址</li>\n<li>CHASNGE-REQUEST：客户使用32位的CHANGE-REQUEST属性来请求服务器使用不同的地址或端口号来发送响应。</li>\n<li>SOURCE-ADDRESS：SOURCE-ADDRESS属性出现在捆绑响应中，它表示服务器发送响应的源IP地址和端口。</li>\n<li>CHANGED-ADDRESS：如果捆绑请求的CHANGE-REQUEST属性中的“改变IP”和“改变端口”标志设置了，则CHANGED-ADDRESS属性表示响应发出的IP地址和端口号。</li>\n<li>USERNAME：USERNAME属性用于消息的完整性检查，用于消息完整性检查中标识共享私密。USERNAME通常出现在共享私密响应中，与PASSWORD一起。当使用消息完整性检查时，可有选择地出现在捆绑请求中。</li>\n<li>PASSWORD：PASSWORD属性用在共享私密响应中，与USERNAME一起。PASSWORD的值是变长的，用作共享私密，它的长度必须是4字节的倍数，以保证属性与边界对齐。</li>\n<li>MESSAGE-INTEGRITY：MESSAGE-INTEGRITY属性包含STUN消息的HMAC-SHA1，它可以出现在捆绑请求或捆绑响应中；MESSAGE-INTEGRITY属性必须是任何STUN消息的最后一个属性。它的内容决定了HMAC输入的Key值。</li>\n<li>ERROR-CODE：ERROR-CODE属性出现在捆绑错误响应或共享私密错误响应中。它的响应号数值范围从100到699。</li>\n<li>UNKNOWN-ATTRIBUTES：UNKNOWN-ATTRIBUTES属性只存在于其ERROR-CODE属性中的响应号为420的捆绑错误响应或共享私密错误响应中。</li>\n<li>REFLECTED-FROM：REFLECTED-FROM属性只存在于其对应的捆绑请求包含RESPONSE-ADDRESS属性的捆绑响应中。属性包含请求发出的源IP地址，它的目的是提供跟踪能力，这样STUN就不能被用作DOS攻击的反射器。</li>\n</ul>\n<p>具体的ERROR-CODE（响应号），与它们缺省的原因语句一起，目前定义如下：</p>\n<ul>\n<li>400（错误请求）：请求变形了。客户在修改先前的尝试前不应该重试该请求。</li>\n<li>401（未授权）：捆绑请求没有包含MESSAGE-INTERITY属性。</li>\n<li>420（未知属性）：服务器不认识请求中的强制属性。</li>\n<li>430（过期资格）：捆绑请求没有包含MESSAGE-INTEGRITY属性，但它使用过期<br>的共享私密。客户应该获得新的共享私密并再次重试。</li>\n<li>431（完整性检查失败）：捆绑请求包含MESSAGE-INTEGRITY属性，但HMAC验<br>证失败。这可能是潜在攻击的表现，或者客户端实现错误</li>\n<li>432（丢失用户名）：捆绑请求包含MESSAGE-INTEGRITY属性，但没有<br>USERNAME属性。完整性检查中两项都必须存在。</li>\n<li>433（使用TLS）：共享私密请求已经通过TLS（Transport Layer Security，即安全<br>传输层协议）发送，但没有在TLS上收到。</li>\n<li>500（服务器错误）：服务器遇到临时错误，客户应该再次尝试。</li>\n<li>600（全局失败）：服务器拒绝完成请求，客户不应该重试。</li>\n</ul>\n<p>属性空间分为可选部分与强制部分，值超过0x7fff的属性是可选的，即客户或服务器即使不认识该属性也能够处理该消息；值小于或等于0x7fff的属性是强制理解的，即除非理解该属性，否则客户或服务器就不能处理该消息。</p>\n<blockquote>\n<p>实现原理</p>\n</blockquote>\n<p><img src=\"http://www.52im.net/data/attachment/forum/201610/12/112611tggg98eyyezpuqys.jpg\" alt=\"image\"></p>\n<p>STUN协议的完整交互过程如上，下面我们来介绍具体实现步骤。</p>\n<p>一般情况下，客户会配置STUN服务器提供者的域名，该域名被解析为IP地址和SRV过程的端口号。服务器名是“stun”，使用UDP协议发送捆绑请求，使用TCP协议发送共享私密请求。STUN协议的缺省端口号为3478。</p>\n<p>若要提供完整性检查，STUN在客户和服务器间使用128位的共享私密，作为在捆绑请求和捆绑响应中的密匙。</p>\n<p>首先，客户通过发现过程获得它将与之建立TCP连接的IP地址和端口号。客户打开该地址和端口的连接，开始TLS协商，验证服务器的标识。客户发送共享私密请求。该请求没有属性，只有头。服务器生成响应。</p>\n<p>客户会在该连接上生成多个请求，但在获得用户名和密码后关闭该连接。</p>\n<p>服务器收到共享私密请求，验证从TLS连接上到达的该请求；如果不是通过TLS收到的请求，则生成共享私密错误响应，并设置ERROR-CODE属性为响应号433；这里区分两种情况：若通过TCP收到请求，则错误响应通过收到请求的相同连接发送；若通过UDP收到请求，则错误响应发送回请求送出的源IP和端口。</p>\n<p>服务器检查请求中的任何属性，当其中有不理解的小于或等于0x7fff的值，则生成共享私密错误响应，设置ERROR-CODE属性为响应号420,并包括UNKNOWN-ATTRIBUTE属性，列出它不理解的小于或等于0x7fff的属性的值。该错误响应通过TLS连接发送。</p>\n<p>若请求正确，服务器创建共享私密响应，包含与请求中相同的事务ID，并包含USERNAME和PASSWORD属性。用户名在10分钟内有效。</p>\n<p>共享私密响应通过与收到请求的相同的TLS连接发送，服务器保持连接打开状态，由客户关闭它。</p>\n<p>接着，客户发送捆绑请求，携带的属性包括：</p>\n<ul>\n<li>可选属性：RESPONSE-ADDRESS属性和CHANGE-REQUEST属性；</li>\n<li>强制属性：MESSAGE-INTEGRITY属性和USERNAME属性。</li>\n</ul>\n<p>客户发送捆绑请求，通过客户重传来提供可靠性。客户开始用100ms的间隔重传，每次重传间隔加倍，直至1.6秒。之间间隔1.6秒的重传继续，直到收到响应或总共已经发送了9次。因此，若9500ms后，还未收到响应，客户认为传输已经失败。</p>\n<p>服务器检查捆绑请求的MESSAGE-INTEGRITY属性，不存在则生成捆绑错误响应，设置ERROR-CODE属性为响应号401；若存在，计算请求的HMACKey值。</p>\n<p>服务器检查USERNAME属性，不存在则生成捆绑错误响应，设置ERROR-CODE属性为响应号432；若存在，但不认识该USERNAME的共享私密（例如，它超时了），生成捆绑错误响应，设置ERROR-CODE属性为响应号430。</p>\n<p>若服务器知道该共享私密，但所计算的HMAC与请求的不同，生成捆绑错误响应，设置ERROR-CODE属性为响应号431。</p>\n<p>假设消息完整性检查通过了，服务器检查请求中的任何属性的值，若遇到不理解的小于或等于0x7fff的值，生成捆绑错误响应，设置ERROR-CODE属性为响应号420，该响应包含UNKNOWN-ATTRIBUTE属性，并列出不理解的小于或等于0x7fff的属性。</p>\n<p>若请求正确，服务器生成单个捆绑响应，包含与捆绑请求相同的事务ID。服务器在捆绑响应中加入MAPPED-ADDRESS属性，该属性的IP地址和端口号为捆绑请求的源IP地址和端口号。</p>\n<p>捆绑响应的源地址和端口号取决于捆绑请求中CHANGE-REQUEST属性的值及捆绑请求收到的地址和端口号相关。总结如下：</p>\n<p><img src=\"http://www.52im.net/data/attachment/forum/201610/12/112735tq1uhlhhll11qiux.png\" alt=\"image\"></p>\n<p>服务器在捆绑响应中加入SOURCE-ADDRESS属性，包含用于发送捆绑响应的源地址和端口号；加入CHANGED-ADDRESS属性，包含源IP地址和端口号。</p>\n<p>如果捆绑请求中包含了USERNAME和MESSAGE-INTEGRITY属性，则服务器在捆绑响应中加入MESSAGE-INTEGRITY属性。</p>\n<p>如果捆绑请求包含RESPONSE-ADDRESS属性，则服务器在捆绑响应中加入REFLECTED-FROM属性：如果捆绑请求使用从共享私密请求获得的用户名进行认证，则REFLECTED-FROM属性包含共享私密请求到达的源IP地址和端口号；若请求中的用户名不是使用共享私密分配的，则REFLECTED-FROM属性包含获得该用户名的实体的源IP地址和端口号；若请求中没有用户名，且服务器愿意处理该请求，则REFLECTED-FROM属性包含请求发出的源IP地址和端口号。</p>\n<p>服务器不会重传响应，可靠性通过客户周期性地重发请求来保障，每个请求都会触发服务器进行响应。</p>\n<p>客户端判断响应的类型是捆绑错误响应还是捆绑响应。捆绑错误响应通常在请求发送的源地址和端口收到；捆绑响应通常在请求中的RESPONSE-ADDRESS属性的地址和端口收到，若没有该属性，则捆绑响应将在请求发送的源地址和端口号收到。</p>\n<ul>\n<li>若是捆绑错误响应，客户检查响应中的ERROR-CODE属性的响应号：400至499之间的未知属性按属性400处理，500至599之间的未知属性按500处理，600至699之间的未知属性按600处理。任何100和399之间的响应都会使请求重传中止，但其他则忽略；若客户收到响应的属性类型大于0x7fff，则忽略该属性，若小于或等于0x7fff，则请求重传停止，并忽略整个响应；</li>\n<li>若是捆绑响应，客户检查响应的MESSAGE-INTEGRITY属性：如果不存在，客户在请求中加入MESSAGE-INTEGRITY属性，并放弃该响应；如果存在，客户计算响应的HMAC。如果计算出的HMAC与响应中的不同，则放弃该响应，并警告客户可能受到了攻击；若计算出的HMAC与响应中的匹配，则过程继续；</li>\n<li>不论收到捆绑响应还是捆绑错误响应，都将中止该请求的重传。客户在第一次响应后继续监听捆绑请求的响应10秒钟，如果这期间它收到任何消息类型不同的响应或不同的MAPPED-ADDRESS属性，它将警告用户可能受到攻击；并且，如果客户收到的捆绑响应次数超过它发送的捆绑请求数的两倍，它将警告用户可能受到攻击；若捆绑响应经过认证，上述攻击并未导致客户丢弃MAPPED-ADDRESS，则客户可以使用该MAPPED-ADDRESS和SOURCE-ADDRESS属性。</li>\n</ul>\n<blockquote>\n<p>STUN功能举例</p>\n</blockquote>\n<p>客户通过带外方式获得STUN服务器信息后，就打开对应的地址和端口的连接，并开始与STUN服务器进行TLS协商。一旦打开了连接，客户就通过TCP协议发送共享私密请求，服务器生成共享私密响应。STUN在客户和服务器间使用共享私密，用作捆绑请求和捆绑响应中的密匙。之后，客户使用UDP协议向STUN服务器发送捆绑请求，当捆绑请求消息到达服务器的时候，它可能经过了一个或者多个NAT。结果是STUN服务器收到的捆绑请求消息的源IP地址被映射成最靠近STUN服务器的NAT的IP地址，STUN服务器把这个源IP地址和端口号复制到一个捆绑响应消息中，发送回拥有这个IP地址和端口号的客户端。</p>\n<p>当STUN客户端收到捆绑响应消息之后，它会将自己发送捆绑请求时绑定的本地IP地址和端口号同捆绑响应消息中的IP地址和端口号进行比较，如果不匹配，就表示客户端正处于一个或者多个NAT的前面。</p>\n<p>在Full-Cone NAT的情况下，在捆绑响应消息中的IP地址和端口是属于公网的，公网上的任何主机都可以使用这个IP地址和端口号向这个应用程序发送数据包，应用程序只需要在刚才发送捆绑请求的IP地址和端口上监听即可。</p>\n<p>当然，客户可能并不在一个Full-Cone NAT的前面，实际上，它并不知道自己在一个什么类型的NAT的前面。为了确定NAT的类型，客户端使用附加的捆绑请求。具体过程是很灵活的，但一般都会像下面这样工作：客户端再发送一个捆绑请求，这次发往另一个IP地址，但是使用的是跟上一次同一个源IP地址和源端口号，如果返回的数据包里面的IP地址和端口号和第一次返回的数据包中的不同，客户端就会知道它是在一个对称NAT的前面。客户端为了确认自己是否在一个完全锥形NAT的前面，客户端可以发送一个带有标志的捆绑请求，这个标志告诉服务器使用另一个IP地址和端口发送捆绑响应。换句话说，如果客户端使X/Y的IP地址端口对向A/B的IP地址端口对发送捆绑请求，服务器就会使用源IP地址和源端口号为C/D的地址端口对向X/Y发送捆绑响应。如果客户端收到了这个响应，它就知道它是在一个Full-Cone NAT前面。</p>\n<p>STUN协议允许客户端请求服务器从收到捆绑请求的IP地址往回发捆绑响应，但是要使用不同的端口号。这可以用来检查客户端是否在Port Restricted Cone NAT的前面还是在Restricted Cone NAT的前面。</p>\n<h3 id=\"2-2-RFC5389-STUN\"><a href=\"#2-2-RFC5389-STUN\" class=\"headerlink\" title=\"2.2 RFC5389/STUN\"></a>2.2 RFC5389/STUN</h3><p>STUN协议在RFC5389中被重新命名为Session Traversal Utilities for NAT，即NAT会话穿透效用。在这里，NAT会话穿透效用被定位为一个用于其他解决NAT穿透问题协议的协议。它可以用于终端设备检查由NAT分配给终端的IP地址和端口号。同时，它也被用来检查两个终端之间的连接性，好比是一种维持NAT绑定表项的保活协议。STUN可以用于多种NAT类型，并不需要它们提供特殊的行为。</p>\n<p>STUN本身不再是一种完整的NAT穿透解决方案，它相当于是一种NAT穿透解决方案中的工具。这是与RFC3489/STUN版本相比最重要的改变。</p>\n<blockquote>\n<p>STUN用途</p>\n</blockquote>\n<p>目前定义了三种STUN用途：</p>\n<ul>\n<li>Interactive Connectivity Establishment（ICE）[MMUSIC-ICE]，交互式连接建立</li>\n<li>Client-initiated connections for SIP [SIP-OUTBOUND]，用于SIP的客户端初始化连接</li>\n<li>NAT Behavior Discovery [BEHAVE-NAT]，NAT行为发现</li>\n</ul>\n<blockquote>\n<p>报文结构</p>\n</blockquote>\n<p>【Ø  消息头】</p>\n<p>STUN消息头为20字节，后面紧跟0或多个属性。STUN头部包含一STUN消息类型、magic cookie、事务ID和消息长度。</p>\n<p><img src=\"http://www.52im.net/data/attachment/forum/201610/12/114036v0l0xcxjj6l6lc94.png\" alt=\"image\"></p>\n<p>每个STUN消息的最高位前2位必须为0。当STUN协议为多个协议多路复用时若使用的是同一个端口，这可以用于与其他协议区分STUN数据包。消息类型确定消息的类别（如请求、成功回应、失败回应、标志）。虽然这里有四种消息类型，但可以分为2类事务：请求/响应事务、标志事务。</p>\n<p>消息类型字段可进一步划分为下面结构：</p>\n<p><img src=\"http://www.52im.net/data/attachment/forum/201610/12/113902e1ci02g21bks8cmf.png\" alt=\"image\"></p>\n<p>消息类型定义如下：</p>\n<ul>\n<li>0b00，表示请求</li>\n<li>0b01，表示标志</li>\n<li>0b10，表示成功响应</li>\n<li>0b11，表示错误响应</li>\n</ul>\n<p>魔术字域必须包含固定的值0x2112A442。在RFC3489中，该域是事务ID的一部分。配置魔术字允许服务器检测客户是否理解某些在改进的版本中增加的属性。另外，还可用于STUN多路复用时与其他协议的包进行区分。</p>\n<p>96位的事务ID用于唯一的识别STUN事务。对于请求/响应事务，事务ID由STUN客户端来选择；对于标志事务，由代理（代理指支持STUN的客户端或服务器）来选择并发送。它主要服务于与请求相关的响应，因此它也扮演着一个帮助阻止确定类型的攻击的角色。服务器使用事务ID来唯一的标识出所有客户端的每一个事务。事务ID本身必须是唯一的，并且随机的从0到2的96-1次方中选择。重新发送相同的请求时，也必须使用新的事务ID。成功或错误响应必须携带与相对应的请求相同的事务ID。</p>\n<p>消息长度字段不包括20字节的STUN头部。所有的STUN属性必须填充为4字节的倍数。消息长度字段的最后2位总是为0，这为区分STUN包与其他协议的包提供了另外一种方法。</p>\n<p>【Ø  消息属性】</p>\n<p>STUN头之后是0或多个属性。每个属性都采用TLV编码，16位的类型、16位的长度及可变长度的值。每个STUN属性必须是4字节边界对齐。</p>\n<p><img src=\"http://www.52im.net/data/attachment/forum/201610/12/114019vcfzuicfi6vumdfz.png\" alt=\"image\"></p>\n<p>属性空间被划分为2个范围。属性的类型值在0x0000到0x7fff是强制理解属性，这意味着除非STUN代理能够理解这些属性，否则将不能正常处理包含该属性的消息；属性的类型值在0x8000到0xffff范围是可选理解属性，这意味着如果STUN代理不能理解它们的话这些属性可以被忽略。</p>\n<p>STUN属性类型集由IANA维护，具体定义详见IETF官方文档 RFC5389。</p>\n<h3 id=\"2-3-RFC5389与RFC3489的区别\"><a href=\"#2-3-RFC5389与RFC3489的区别\" class=\"headerlink\" title=\"2.3 RFC5389与RFC3489的区别\"></a>2.3 RFC5389与RFC3489的区别</h3><p>RFC5389与RFC3489的不同点如下：</p>\n<ul>\n<li>去掉STUN是一种完整的NAT穿透方案的概念，现在是一种用于提供NAT穿透解决方案的工具。因而，协议的名称变为NAT会话穿透效用；</li>\n<li>定义了STUN的用途；</li>\n<li>去掉了STUN关于NAT类型检测和绑定生命期发现的用法，去掉了RESPONSE-ADDRESS、CHANGED-ADDRESS、CHANGE-REQUEST、SOURCE-ADDRESS和REFLECTED-FROM属性；</li>\n<li>增加了一个固定的32位的魔术字字段，事务ID字段减少了32位长度；</li>\n<li>增加了XOR-MAPPED-ADDRESS属性，若魔术字在捆绑请求中出现时，该属性包括在捆绑响应中。否则，RFC3489中的行为是保留的（换句话说，捆绑响应中包括MAPPED-ADDRESS）；</li>\n<li>介绍了消息类型字段的正式结构，带有一对明确的位来标识Request、Response、Error-Response或Indication消息。因此，消息类型字段被划分为类别和方法两部分；</li>\n<li>明确的指出了STUN的最高2位是0b00，当用于ICE时可以简单的与RTP包区分开来；</li>\n<li>增加指纹属性来提供一种明确的方法来检测当STUN协议多路复用时，STUN与其他协议之间的差异；</li>\n<li>增加支持IPv6，IPv4客户端可以获取一个IPv6映射地址，反之亦然；</li>\n<li>增加一个long-term-credential-based认证机制；</li>\n<li>增加了SOFTWARE、REALM、NONCE和ALTERNATE-SERVER属性；</li>\n<li>去掉了共享密匙方法，因此PASSWORD属性也去掉了；</li>\n<li>去掉了使用连续10秒侦听STUN响应来识别一个攻击的做法；</li>\n<li>改变事务计时器来增加TCP友好性；</li>\n<li>去掉了STUN例子如集中分离控制和媒体面，代替的，在使用STUN协议时提供了更多的信息；</li>\n<li>定义了一类填充机制来改变长度属性的说明；</li>\n<li>REALM、SERVER、原因语句和NONCE限制在127个字符，USERNAME限制在513个字节以内；</li>\n<li>为TCP和TLS改变了DNS SRV规程，UDP仍然和以前保持一致。</li>\n</ul>\n<p>IETF官文档，详见：RFC5389、RFC3489。</p>\n<h3 id=\"2-4-新特性介绍\"><a href=\"#2-4-新特性介绍\" class=\"headerlink\" title=\"2.4 新特性介绍\"></a>2.4 新特性介绍</h3><blockquote>\n<p>指纹机制</p>\n</blockquote>\n<p>FINGERPRINT机制是一种可选的用于其他协议多路复用STUN时发送给相同的传输地址时区分STUN数据包的机制，该机制不支持与RFC3489相兼容。</p>\n<p>在一些用途中，基于相同的传输地址时多个协议会多路复用STUN消息，例如RTP协议。STUN消息必须首先和应用报文分离开。目前，在STUN报头中有3种固定的字段可以用于该目的。尽管如此，在一些案例中，三种固定字段仍然不能充分的区别开。</p>\n<p>当扩展的指纹机制被使用时，STUN代理在发送给其他STUN代理的消息中包括FINGERPRINT属性。当其他STUN代理收到时，除基本的检查之外，还将检查是否包含FINGERPRINT属性及它是否包含正确的值，至此，它将相信这是一个STUN消息。指纹机制帮助STUN代理检查其他协议那些看起来像是STUN消息的消息。</p>\n<blockquote>\n<p>通过DNS发现服务器机制</p>\n</blockquote>\n<p>STUN客户端可以使用DNS来发现STUN服务器的IP地址和端口。客户端必须知道服务器的域名。</p>\n<p>当客户端希望找出服务器在公网上的位置就采用捆绑请求/响应事务，SRV（资源记录表）中服务器名称是“stun”。当通过TLS会话采用捆绑请求/响应事务，SRV中服务器名称为“stuns”。STUN用户可以定义额外的DNS资源记录服务名称。</p>\n<p>STUN请求的默认端口是3478，用于TCP和UDP。STUN在TLS上的默认端口是5349。服务器能够在TLS上运行STUN与STUN在TCP上时使用相同的端口，只有服务器软件支持决定初始消息是否是TLS或STUN消息。</p>\n<p>如果SRV中没有记录可查，客户端执行A或AAAA记录查找域名。结果将会是1张IP地址表，每一个都可以使用TCP或UDP采用默认端口号连接。通常要求使用TLS，客户端使用STUN在TLS上的默认端口号连接其中一个IP地址。</p>\n<blockquote>\n<p>认证和消息完整性机制</p>\n</blockquote>\n<ul>\n<li>短期证书机制</li>\n</ul>\n<p>短期证书机制假设在STUN事务之前，客户端和服务器已经使用了其他协议来交换了证书，以username和password形式。这个证书是有时间限制的。例如，在ICE用途中，两个终端使用带外方式交换信息来对username和password达成一致，并在媒体会话期间使用。这个证书被用来进行消息完整性检查，用于每个请求和多个响应中。与长期证书机制相比，没有挑战和响应方式，因此，这种证书的时间限制特性的优点是可以阻止重播。</p>\n<ul>\n<li>长期证书机制</li>\n</ul>\n<p>长期证书机制依赖于一个长期证书，username和password在客户端和服务器中是共用的。这个证书从它提供给 用户开始将一直是有效的，直到该用户不再是该系统的用户。这本质上是一个提供给用户username和password的传统的登入方式。    </p>\n<p>客户端初始发送一个请求，没有提供任何证书和任何完整性检测。服务器拒绝这个请求，并提供给用户一个范围（用于指导用户或代理选择username和password）和一个nonce。这个nonce提供重放保护。它是一个cookie，由服务器选择，以这样一种方式来标示有效时间或客户端身份是有效的。客户端重试这个请求，这次包括它的username和realm和服务器提供的nonce来回应。服务器确认这个nonce和检查这个message integrity。如果它们匹配，请求则通过认证。如果这个nonce不再有效，即过期了，服务器就拒绝该请求，并提供一个新的nonce。</p>\n<p>在随后的到同一服务器的请求，客户端重新使用这个nonce、username和realm，和先前使用的password。这样，随后的请求不会被拒绝直到这个nonce变成无效的。需要注意的是，长期证书机制不能用来保护Indications，由于Indications不能被改变，因此，使用Indications时要么使用短期证书，要么就省略认证和消息完整性。因为长期证书机制对离线字典攻击敏感，部署的时候应该使用很难猜测的密码。</p>\n<blockquote>\n<p>备份服务器机制</p>\n</blockquote>\n<p>服务器使用增强的重定向功能将一个客户端转向另一个服务器，通过回应一个错误响应号为300（尝试备份）的错误响应。服务器在错误响应中携带一个ALTERNATE-SERVER属性。</p>\n<p>客户端收到错误响应号为300的错误响应后，在该响应中查找ALTERNATE-SERVER属性。若找到一个，客户端就会将当前的事务作废，并重新尝试发送请求到该属性中列出的服务器。请求报文若已经通过认证，则必须使用与先前发送给执行重定向操作的服务器同样的证书。如果客户端在最后5分钟里已经重试发送请求时已经重定向到了一个服务器，它必须忽略重定向操作并将当前的事务作废，这是为了防止无限的重定向循环。</p>\n<h3 id=\"2-5-RFC5389与RFC3489的兼容\"><a href=\"#2-5-RFC5389与RFC3489的兼容\" class=\"headerlink\" title=\"2.5 RFC5389与RFC3489的兼容\"></a>2.5 RFC5389与RFC3489的兼容</h3><p>在RFC3489中：</p>\n<ul>\n<li>UDP是唯一支持的传输协议</li>\n<li>RFC5389中的魔术字字段是RFC3489中事务ID的一部分，事务ID长128位</li>\n<li>没有XOR-MAPPED-ADDRESS属性，绑定方法是使用MAPPED-ADDRESS属性代替</li>\n<li>有3个需要强制理解的属性，分别是：RESPONSE-ADDRESS、CHANGE-REQUEST、CHANGED-ADDRESS属性，而RFC5389中不再支持这些属性。</li>\n</ul>\n<blockquote>\n<p>客户端处理的改变</p>\n</blockquote>\n<p>客户端想要与RFC3489的服务器互操作，应发送一个使用绑定方法的请求消息，不包含任何消息，使用UDP协议发送给服务器。如果成功，将收到服务器发回的包含MAPPED-ADDRESS属性而不是XOR-MAPPED-ADDRESS属性的成功响应。客户端试图与基于RFC3489的应用服务器互操作必须准备好接收任意一个属性。此外，客户端必须忽略任何在响应中出现的保留的强制理解的属性。RFC3489中规定保留属性中的0x0002、0x0004、0x0005和0x000B可能出现在绑定响应中。</p>\n<blockquote>\n<p>服务器处理的改变</p>\n</blockquote>\n<p>服务器能够察觉由RFC3489中的客户端发送的携带有不正确的魔术字的捆绑请求消息。当服务器察觉到RFC3489中的客户端，它应该将捆绑请消息中魔术字域中的值拷贝到捆绑响应中的魔术字字段中，并且插入一个MAPPED-ADDRESS属性代替XOR-MAPPED-ADDRESS属性。</p>\n<p>客户端在极少的环境下可能包括RESPONSE-ADDRESS或CHANGE-REQUEST属性中的一个。在这些情况下，服务器把这些属性看做是一个不认识的强制理解的属性，并回应一个错误响应。RFC3489版本中的STUN缺少魔术字和指纹属性这两种能够高可靠性的正确标识其他协议多路复用时的STUN消息。因此，STUN执行与RFC3489兼容时不应该被用于多个协议。</p>\n<h2 id=\"3、TURN详解\"><a href=\"#3、TURN详解\" class=\"headerlink\" title=\"3、TURN详解\"></a>3、TURN详解</h2><h3 id=\"3-1-RFC5766-TURN\"><a href=\"#3-1-RFC5766-TURN\" class=\"headerlink\" title=\"3.1 RFC5766/TURN\"></a>3.1 RFC5766/TURN</h3><p>TURN，在RFC5766中定义，英文全称Traversal Using Relays around NAT（TURN）：Relay Extensions to Session Traversal Utilities for NAT（STUN），即使用中继穿透NAT：STUN的中继扩展。简单的说，TURN与STUN的共同点都是通过修改应用层中的私网地址达到NAT穿透的效果，异同点是TURN是通过两方通讯的“中间人”方式实现穿透。</p>\n<p>如果一个主机位于NAT的后面，在某些情况下它不能够与其他主机点对点直接连接。在这些情况下，它需要使用中间网点提供的中继连接服务。TURN协议就是用来允许主机控制中继的操作并且使用中继与对端交换数据。TURN与其他中继控制协议不同的是它能够允许一个客户端使用一个中继地址与多个对端连接。</p>\n<p>TURN协议被设计为ICE的一部分，用于NAT穿越，虽然如此，它也可以在没有ICE的地方单独使用。</p>\n<h3 id=\"3-2-操作概述\"><a href=\"#3-2-操作概述\" class=\"headerlink\" title=\"3.2 操作概述\"></a>3.2 操作概述</h3><p><img src=\"http://www.52im.net/data/attachment/forum/201610/12/115151bn2gxe2p96x612x2.jpg\" alt=\"image\"></p>\n<p>在一个典型组网中，一个TURN客户端连接在一个私有网络中，通过一个或多个NAT来连接到公网。在公网中有一个TURN服务器。在因特网的别处有一个或多个对端是这个TURN客户端希望通讯的。这些对端也有可能是在一个或多个NAT的后面。该客户端使用服务器作为一个中继来发送数据包 到这些对端去，并且从这些对端接收数据包。</p>\n<p>客户端通过一个IP地址和端口的组合来与服务器建立会话。客户端使用TURN命令在服务器上创建和操作一个ALLOCATION。一旦这个allocation创建好了，客户端能够在数据发往哪个对端的指示下发送应用数据到这个服务器，服务器将中继这些数据到合适的对端。客户端发送的应用数据包含在TURN消息中，服务器将数据提取出来，并以UDP数据包方式发送给对端。反向上，对端以UDP数据包方式发送应用数据到这个allocation提供的中继传输地址。因为TURN消息总是包含客户端与哪些对端通讯的指示，客户端能够使用单一的allocation来与多个对端通讯。</p>\n<h3 id=\"3-3-术语\"><a href=\"#3-3-术语\" class=\"headerlink\" title=\"3.3 术语\"></a>3.3 术语</h3><ul>\n<li>TURN client：遵循RFC5766的STUN客户端。</li>\n<li>TURN server：遵循RFC5766的STUN服务器。</li>\n<li>Peer：TURN客户端希望连接的主机。TURN服务器为TURN客户端和它的对端中继流量，但Peer并不与TURN服务器使用TURN协议进行交互，它接收从TURN服务器发送过来的数据，并向TURN服务器发送数据。</li>\n<li>Transport Address：IP地址与端口号的组合。</li>\n<li>Host Transport Address：客户端或对端的传输地址。</li>\n<li>Server-Reflexive Transport Address：NAT公网侧的传输地址，该地址由NAT分配，相当于一个特定的主机传输地址。</li>\n<li>Relayed Transport Address：TURN服务器上的传输地址，用于客户端和对端中继数据。</li>\n<li>TURN Server Transport Address：TURN服务器上的传输地址，用于客户端发送STUN消息给服务器。</li>\n<li>Peer Transport Address：服务器看到的对端的传输地址，当对端是在NAT后面，则是对端的服务器反射传输地址。</li>\n<li>Allocation：通过Allocate请求将中继传输地址提供给客户端，除了中继状态外，还有许可和超时定时器等。</li>\n<li>5-tuple：五元组，包括客户端IP地址和端口，服务器IP地址和端口和传输协议（包括UDP、TCP、TLS）的组合。</li>\n<li>Channel：通道号与对端传输地址的关联，一旦一个通道号与一个对端的传输地址绑定，客户端和服务器就能够利用带宽效应更大的通道数据消息来交换数据。</li>\n<li>Permission：一个对端允许使用它的IP地址和传输协议来发送数据到TURN服务器，服务器只为从对端发来的并且匹配一个已经存在的许可的流量中继到相应的客户端。</li>\n<li>Realm：服务器内用于描述服务器或内容的一个字符串，这个realm告诉客户端哪些用户名和密码的组合可用于认证请求。</li>\n<li>Nonce：服务器随机选择的一个字符串，包含在报文摘要中。为了防止中继攻击，服务器应该有规律的改变这个nonce。</li>\n</ul>\n<p>具体协议细节，详见IETF官方文档：RFC5766.</p>\n<h3 id=\"3-4-协议交互过程详细举例\"><a href=\"#3-4-协议交互过程详细举例\" class=\"headerlink\" title=\"3.4 协议交互过程详细举例\"></a>3.4 协议交互过程详细举例</h3><p>以上图为例进行讲解，每个消息中，多个属性包含在消息中并显示它们的值。为了方便阅读，值以人们可读的格式来显示。</p>\n<p><img src=\"http://www.52im.net/data/attachment/forum/201610/12/115958r41hgy1uht78nazu.jpg\" alt=\"image\"></p>\n<p>客户端使用10.1.1.2:49271作为传输地址向服务器的传输地址发送Allocate请求。客户端随机选择一个96位的事务ID。该Allocate请求消息包括SOFTWARE属性来提供客户端的软件版本信息；包括LIFETIME属性，指明客户端希望该allocation具有1小时的生命期而非缺省的10分钟；包括REQUESTED-TRANSPORT属性来告诉服务器与对端之间采用UDP协议来传输；包括DONT-FRAGMENT属性因为客户端希望在随后的Send indications中使用DON’T-FRAGMENT属性。</p>\n<p>服务器需要任何请求必须是经过认证的，因此服务器拒绝了该最初的Allocation请求，并且回应了携带有错误响应号为401（未授权）的Allocate错误响应；该响应包括一个REALM属性，指明认证的域；还包括一个NONCE属性和一个SOFTWARE属性。</p>\n<p>客户端收到了错误响应号为401的Allocate错误响应，将重新尝试发送Allocate请求，此时将包括认证属性。客户端在新的请求中重新选择一个新的事务ID。客户端包括一个USERNAME属性，使用从服务器那收到的realm值来帮助它决定使用哪个值；请求还包括REALM和NONCE属性，这两个属性是从收到的错误响应中拷贝出来的。最后，客户端包括一个MESSAGE-INTEGRITY属性。</p>\n<p>服务器收到认证的Allocate请求后，检查每个属性是否正确；然后，产生一个allocation，并给客户端回应Allocate成功响应。服务器在该成功响应中携带一个LIFETIME属性，本例中服务器将客户端请求的1小时生命期减小为20分钟，这是因为这个特定的服务器可能不允许超过20分钟的生命期；该响应包括XOR-RELAYED-ADDRESS属性，值为该allocation的中继传输地址；该响应还包括XOR-MAPPED-ADDRESS属性，值为客户端的server-reflexive地址；该响应也包含一个SOFTWARE属性；最后，包括一个MESSAGE-INTEGRITY属性来证明该响应，确保它的完整性。</p>\n<p><img src=\"http://www.52im.net/data/attachment/forum/201610/12/120031zi6vsrvx24ssg42i.jpg\" alt=\"image\"></p>\n<p>接着，客户端为了准备向对端A发送一些应用数据而创建一个permission。这里通过一个CreatePermission请求来做到。该请求携带XOR-PEER-ADDRESS属性包含有确定的请求的IP地址，这里为对端A的地址；需要注意的是，属性中地址的端口号被设置为0在CreatePermission请求中，并且客户端使用的是对端A的server-reflexive地址而不是它的主机地址（私网地址）；客户端在该请求中携带与之前的Allocate请求中一样的username、realm和nonce值，因此该请求被服务器认可。此时在该请求中，客户端没有携带SOFTWARE属性。</p>\n<p>服务器收到该CreatePermission请求，产生一个相应的许可，并以CreatePermission成功响应来回应。该响应中只包含了Transaction-ID和MESSAGE-INTEGRITY属性。</p>\n<p><img src=\"http://www.52im.net/data/attachment/forum/201610/12/120053ks33633olaxnpi4l.jpg\" alt=\"image\"></p>\n<p>现在客户端使用Send indication来发送应用数据到对端A。对端的server-reflexive传输地址包含在XOR-PEER-ADDRESS属性中，应用数据包含在DATA属性中。客户端已经在应用层上执行了路径MTU发现功能，因此通过DON’T-FRAGMENT属性来告知服务器当通过UDP方式来向对端发送数据时应设置DF位。Indications不能使用长期证书机制来认证，所以该消息中没有MESSAGE-INTEGRITY属性。</p>\n<p>服务器收到Send indication后，提取出应用数据封装成UDP格式发给对端A；UDP报文的源传输地址为中继传输地址，并设置DF位。</p>\n<p>对端A回应它自己的包含有应用数据的UDP包给服务器。目的地址为服务器的中继传输地址。当服务器收到后，将生成Data indication消息给客户端，携带有XOR-PEER-ADDRESS属性。应用数据包含在DATA属性中。</p>\n<p><img src=\"http://www.52im.net/data/attachment/forum/201610/12/120117zf5gi0ka7fw5o57e.jpg\" alt=\"image\"></p>\n<p>客户端现在若要绑定一个通道到对端B，将指定一个空闲的通道号（本例中为0x4000）包含在CHANNEL-NUMBER属性中，对端B的传输地址包含在XOR-PEER-ADDRESS属性中。与以前一样，客户端再次利用上次请求中的username、realm和nonce。</p>\n<p>当服务器收到该请求后，服务器绑定这个对端的通道号，为对端B的IP地址安装一个permission，然后给客户端回应一个ChannelBind成功响应消息。</p>\n<p><img src=\"http://www.52im.net/data/attachment/forum/201610/12/120134g98040e74ziwfiwz.jpg\" alt=\"image\"></p>\n<p>客户端现在发送一个ChannelData消息给服务器，携带有发送给对端B的数据。这个消息不是一个STUN消息，因此没有事务ID。它之有3个字段：通道号、数据、数据长度；服务器收到后，检查通道号后发现当前已经绑定了，就以UDP方式发送数据给对端B。</p>\n<p>接着，对端B发送UDP数据包回应给服务器的中继传输地址。服务器收到后，回应给客户端ChannelData消息，包含UDP数据包中的数据。服务器知道是给哪个客户端发送ChannelData消息，这是因为收到的UDP数据包中的目的地址（即服务器的中继传输地址），并且知道使用的是哪个通道号，这是因为通道已经与相应的传输地址绑定了。</p>\n<p><img src=\"http://www.52im.net/data/attachment/forum/201610/12/120157sixfnelrqciqexgd.jpg\" alt=\"image\"></p>\n<p>有时候，20分钟的生命期已经到了，客户端需要刷新allocation。此时通过发送Refresh请求来进行。该请求包含最后一次使用的username、realm和nonce，还包含SOFTWARE属性。当服务器收到这个Refresh请求时，它注意到这个nonce值已经超期了，则给客户端回应一个错误响应号为438（过期Nonce）的Refresh错误响应，并提供一个新的nonce值。可护端将重试该请求，此时携带新的nonce值。若第二次尝试被接受，服务器将回应一个成功响应。需要注意的是，此时客户端在请求中没有携带LIFETIME属性，所以服务器刷新客户端的allocation时采用缺省的10分钟生命期。</p>\n<h2 id=\"4、ICE简明介绍\"><a href=\"#4、ICE简明介绍\" class=\"headerlink\" title=\"4、ICE简明介绍\"></a>4、ICE简明介绍</h2><h3 id=\"4-1-简介\"><a href=\"#4-1-简介\" class=\"headerlink\" title=\"4.1 简介\"></a>4.1 简介</h3><p>ICE的全称Interactive Connectivity Establishment（互动式连接建立），由IETF的MMUSIC工作组开发出来的，它所提供的是一种框架，使各种NAT穿透技术可以实现统一。ICE跟STUN和TURN不一样，ICE不是一种协议，而是一个框架（Framework），它整合了STUN和TURN。</p>\n<h3 id=\"4-2-应用模型\"><a href=\"#4-2-应用模型\" class=\"headerlink\" title=\"4.2 应用模型\"></a>4.2 应用模型</h3><p><img src=\"http://www.52im.net/data/attachment/forum/201610/12/120427sj60zrara770aql5.png\" alt=\"image\"></p>\n<p>如上图所示，如果A想与B通信，那么其过程如下：</p>\n<ul>\n<li>A收集所有的IP地址，并找出其中可以从STUN服务器和TURN服务器收到流量的地址；</li>\n<li>A向STUN服务器发送一份地址列表，然后按照排序的地址列表向B发送启动信息，目的是实现节点间的通信；</li>\n<li>B向启动信息中的每一个地址发送一条STUN请求；</li>\n<li>A将第一条接收到的STUN请求的回复信息发送给B；</li>\n<li>B接到STUN回复后，从中找出那些可在A和B之间实现通信的地址；</li>\n<li>用列表中的排序列最高的地址进一步的设备间通信。</li>\n</ul>\n<p>由于该技术是建立在多种NAT穿透协议的基础之上，并且提供了一个统一的框架，所以ICE具备了所有这些技术的优点，同时还避免了任何单个协议可能存在的缺陷。因此，ICE可以实现在未知网络拓扑结构中实现的设备互连，而且不需要进行对手配置。另外，由于该技术不需要为VoIP流量手动打开防火墙，所以也不会产生潜在的安全隐患。</p>\n<h2 id=\"5、本文总结\"><a href=\"#5、本文总结\" class=\"headerlink\" title=\"5、本文总结\"></a>5、本文总结</h2><p>在现实Internet网络环境中，大多数计算机主机都位于防火墙或NAT之后，只有少部分主机能够直接接入Internet。很多时候，我们希望网络中的两台主机能够直接进行通信（即所谓的P2P通信），而不需要其它公共服务器的中转。由于主机可能位于防火墙或NAT之后，在进行P2P通信之前，我们需要进行检测以确认它们之间能否进行P2P通信以及如何通信。这种技术通常被称为NAT穿透（NAT Traversal）。</p>\n<p>RFC3489中定义的STUN，即简单地用UDP穿过NAT（STUN）是个轻量级的协议。它允许应用发现它们与公共互联网之间存在的NAT和防火墙及其他类型。它还为应用提供判断NAT给它们分配的公共网际协议（IP）地址。STUN可工作在许多现存NAT上，并且不需要它们做任何特别的行为。它允许广泛的各类的应用穿越现存的NAT设施。</p>\n<p>RFC5389中对STUN协议进行了修订，将其定位于为穿透NAT提供工具，即NAT会话穿透效用是一个用于其他解决NAT穿透问题协议的协议。它可以用于终端设备检查由NAT分配给终端的IP地址和端口号。同时，它也被用来检查两个终端之间的连接性，好比是一种维持NAT绑定表项的保活协议。STUN本身并不是一种完整的NAT穿透解决方案。它相当于是一种NAT穿透解决方案中的工具。这是与先前的版本相比最重要的改变。之前的RFC3489中定义的STUN是一个完整的穿透NAT解决方案。此外，最大的区别是支持TCP穿透。</p>\n<p>RFC5766中对STUN协议再次进行了扩展，即中继穿透NAT：STUN的扩展。TURN与STUN的共同点都是通过修改应用层中的私网地址达到NAT穿透的效用，异同点是TUN采用了两方通讯的“中间人”方式实现穿透，突破了原先STUN协议无法在两台主机不能够点对点直接连接下提供作用的限制。</p>\n<p>技术无止境，NAT穿透技术仍在不断更新中，这里只对STUN/TURN协议作了简单的介绍，具体细节请参考RFC3489/5389/5766。</p>"},{"title":"Go 异常处理机制——defer, error, panic, recover","date":"2018-07-27T07:00:17.000Z","_content":"### 1. 如果项目中的代码、使用的标准库以及第三方库在运行时内部捕获了异常并通过合适的 error 对象返回给调用者，那我们可以尽量少甚至可以不用 panic 函数。\n### 2. 如果无法保证上面的情况，那为了确保程序在运行时不会因为 未知的未知 导致崩溃，那 panic 函数的使用可能不得不加在任何需要的地方。\n### 3. 我们应该认识到，panic是我们和计算机都不希望看到的，应该在设计开发的时候充分考虑使用场景可能出现的情况，处理好 已知的未知，在确定需要的地方使用 panic 机制。\n\n# defer \n\ndefer关键字用来标记最后执行的Go语句，一般用在资源释放、关闭连接等操作，会在函数关闭前调用。\n\n多个defer的定义与执行类似于栈的操作：先进后出，最先定义的最后执行。\n\n<!-- more -->\n\n请先看下边几段代码，然后判断一下各自输出内容：\n```\n// 示例代码一：\nfunc funcA() int {\n    x := 5\n    defer func() {\n        x += 1\n    }()\n    return x\n}\n// 示例代码二：\nfunc funcB() (x int) {\n    defer func() {\n        x += 1\n    }()\n    return 5\n}\n\n// 示例代码三：\nfunc funcC() (y int) {\n    x := 5\n    defer func() {\n        x += 1\n    }()\n    return x\n}\n \n// 示例代码四：\nfunc funcD() (x int) {\n    defer func(x int) {\n        x += 1\n    }(x)\n    return 5\n}\n```\n解析这几段代码，主要需要理解清楚以下几点知识：\n### 1. return语句的处理过程\n\nreturn xxx 语句并不是一条原子指令，其在执行的时候会进行语句分解成 返回变量=xxx return，最后执行return\n\n### 2. defer语句执行时机\n\n上文说过，defer语句是在函数关闭的时候调用，确切的说是在执行return语句的时候调用，注意，是return 不是return xxx\n\n### 3. 函数参数的传递方式\n\nGo语言中普通的函数参数的传递方式是值传递，即新辟内存拷贝变量值，不包括slice和map，这两种类型是引用传递\n\n### 4. 变量赋值的传递方式\n\nGo语言变量的赋值跟函数参数类似，也是值拷贝，不包括slice和map，这两种类型是内存引用\n\n按照以上原则，解析代码：\n```\n// 解析代码一：返回temp的值，在将x赋值给temp后，temp未发生改变，最终返回值为5\nfunc funcA() int {\n    x := 5\n    temp=x      #temp变量表示未显示声明的return变量\n    func() {\n        x += 1\n    }()\n    return\n}\n\n// 解析代码二：返回x的值，先对其复制5，接着函数中改变为6，最终返回值为6\nfunc funcB() (x int) {\n    x = 5\n    func() {\n        x += 1\n    }()\n    return\n}\n\n// 解析代码三：返回y的值，在将x赋值给y后，y未发生改变，最终返回值为5\nfunc funcC() (y int) {\n    x := 5\n    y = x       #这里是值拷贝\n    func() {\n        x += 1\n    }()\n    return\n}\n\n// 解析代码四：返回x的值，传递x到匿名函数中执行时，传递的是x的拷贝，不影响外部x的值，最终返回值为5\nfunc funcD() (x int) {\n    x := 5\n    func(x int) { #这里是值拷贝\n        x += 1\n    }(x)\n    return\n}\n```\n# Error\nGo语言 通过支持多返回值，让在运行时返回详细的错误信息给调用者变得非常方便。我们可以在编码中通过实现 error 接口类型来生成错误信息，error 接口的定义如下：\n```\ntype error interface {\n    Error() string\n}\n```\n还是通过下面的例子来看看：\n```\npackage main\n\nimport (\n\t\"fmt\"\n)\n\n// 定义一个 DivideError 结构\ntype DivideError struct {\n\tdividee int\n\tdivider int\n}\n\n// 实现 \t`error` 接口\nfunc (de *DivideError) Error() string {\n\tstrFormat := `\n\tCannot proceed, the divider is zero.\n\tdividee: %d\n\tdivider: 0`\n\treturn fmt.Sprintf(strFormat, de.dividee)\n}\n\n// 定义 `int` 类型除法运算的函数\nfunc Divide(varDividee int, varDivider int) (result int, errorMsg string) {\n\tif varDivider == 0 {\n\t\tdData := DivideError{\n\t\t\tdividee: varDividee,\n\t\t\tdivider: varDivider,\n\t\t}\n\t\terrorMsg = dData.Error()\n\t\treturn\n\t} else {\n\t\treturn varDividee / varDivider, \"\"\n\t}\n\n}\n\nfunc main() {\n\n\t// 正常情况\n\tif result, errorMsg := Divide(100, 10); errorMsg == \"\" {\n\t\tfmt.Println(\"100/10 = \", result)\n\t}\n\t// 当被除数为零的时候会返回错误信息\n\tif _, errorMsg := Divide(100, 0); errorMsg != \"\" {\n\t\tfmt.Println(\"errorMsg is: \", errorMsg)\n\t}\n\n}\n```\n运行后可以看到下面的输出：\n```\n100/10 =  10\nerrorMsg is:  \n\tCannot proceed, the divider is zero.\n\tdividee: 100\n\tdivider: 0\n```\n# Panic 和 recover\n定义如下：\n```\nfunc panic(interface{})\nfunc recover() interface{}\n```\npanic 和 recover 是两个内置函数，用于处理 run-time panics 以及程序中自定义的错误。\n\n当执行一个函数 F 的时候，如果显式地调用 panic 函数或者一个 run-time panics 发生时，F 会结束运行，所有 F 中 defer 的函数会按照 FILO 的规则被执行。之后，F 函数的调用者中 defer 的函数再被执行，如此一直到最外层代码。这时，程序已经被中断了而且错误也被一层层抛出来了，其中包括 panic 函数的参数。当前被中断的 goroutine 被称为处于 panicking 状态。由于 panic 函数的参数是空接口类型，所以可以接受任何类型的对象：\n```\npanic(42)\npanic(42)\npanic(\"unreachable\")\npanic(Error(\"cannot parse\"))\n```\nrecover 函数用来获取 panic 函数的参数信息，只能在延时调用 defer 语句调用的函数中直接调用才能生效，如果在 defer 语句中也调用 panic 函数，则只有最后一个被调用的 panic 函数的参数会被 recover 函数获取到。如果 goroutine 没有 panic，那调用 recover 函数会返回 nil。\n```\npackage main\n\nimport (\n\t\"fmt\"\n)\n\n// 最简单的例子\nfunc SimplePanicRecover() {\n\tdefer func() {\n\t\tif err := recover(); err != nil {\n\t\t\tfmt.Println(\"Panic info is: \", err)\n\t\t}\n\t}()\n\tpanic(\"SimplePanicRecover function panic-ed!\")\n}\n\n// 当 defer 中也调用了 panic 函数时，最后被调用的 panic 函数的参数会被后面的 recover 函数获取到\n// 一个函数中可以定义多个 defer 函数，按照 FILO 的规则执行\nfunc MultiPanicRecover() {\n\tdefer func() {\n\t\tif err := recover(); err != nil {\n\t\t\tfmt.Println(\"Panic info is: \", err)\n\t\t}\n\t}()\n\tdefer func() {\n\t\tpanic(\"MultiPanicRecover defer inner panic\")\n\t}()\n\tdefer func() {\n\t\tif err := recover(); err != nil {\n\t\t\tfmt.Println(\"Panic info is: \", err)\n\t\t}\n\t}()\n\tpanic(\"MultiPanicRecover function panic-ed!\")\n}\n\n// recover 函数只有在 defer 函数中被直接调用的时候才可以获取 panic 的参数\nfunc RecoverPlaceTest() {\n\t// 下面一行代码中 recover 函数会返回 nil，但也不影响程序运行\n\tdefer recover()\n\t// recover 函数返回 nil\n\tdefer fmt.Println(\"recover() is: \", recover())\n\tdefer func() {\n\t\tfunc() {\n\t\t\t// 由于不是在 defer 调用函数中直接调用 recover 函数，recover 函数会返回 nil\n\t\t\tif err := recover(); err != nil {\n\t\t\t\tfmt.Println(\"Panic info is: \", err)\n\t\t\t}\n\t\t}()\n\n\t}()\n\tdefer func() {\n\t\tif err := recover(); err != nil {\n\t\t\tfmt.Println(\"Panic info is: \", err)\n\t\t}\n\t}()\n\tpanic(\"RecoverPlaceTest function panic-ed!\")\n}\n\n// 如果函数没有 panic，调用 recover 函数不会获取到任何信息，也不会影响当前进程。\nfunc NoPanicButHasRecover() {\n\tif err := recover(); err != nil {\n\t\tfmt.Println(\"NoPanicButHasRecover Panic info is: \", err)\n\t} else {\n\t\tfmt.Println(\"NoPanicButHasRecover Panic info is: \", err)\n\t}\n}\n\n// 定义一个调用 recover 函数的函数\nfunc CallRecover() {\n\tif err := recover(); err != nil {\n\t\tfmt.Println(\"Panic info is: \", err)\n\t}\n}\n\n// 定义个函数，在其中 defer 另一个调用了 recover 函数的函数\nfunc RecoverInOutterFunc() {\n\tdefer CallRecover()\n\tpanic(\"RecoverInOutterFunc function panic-ed!\")\n}\n\nfunc main() {\n\tSimplePanicRecover()\n\tMultiPanicRecover()\n\tRecoverPlaceTest()\n\tNoPanicButHasRecover()\n\tRecoverInOutterFunc()\n}\n```\n运行后可以看到下面的输出：\n```\nPanic info is:  SimplePanicRecover function panic-ed!\nPanic info is:  MultiPanicRecover function panic-ed!\nPanic info is:  MultiPanicRecover defer inner panic\nPanic info is:  RecoverPlaceTest function panic-ed!\nrecover() is:  <nil>\nNoPanicButHasRecover Panic info is:  <nil>\nPanic info is:  RecoverInOutterFunc function panic-ed!\n```\n","source":"_posts/error.md","raw":"---\ntitle: Go 异常处理机制——defer, error, panic, recover\ndate: 2018-07-27 15:00:17\ntags: Go\n---\n### 1. 如果项目中的代码、使用的标准库以及第三方库在运行时内部捕获了异常并通过合适的 error 对象返回给调用者，那我们可以尽量少甚至可以不用 panic 函数。\n### 2. 如果无法保证上面的情况，那为了确保程序在运行时不会因为 未知的未知 导致崩溃，那 panic 函数的使用可能不得不加在任何需要的地方。\n### 3. 我们应该认识到，panic是我们和计算机都不希望看到的，应该在设计开发的时候充分考虑使用场景可能出现的情况，处理好 已知的未知，在确定需要的地方使用 panic 机制。\n\n# defer \n\ndefer关键字用来标记最后执行的Go语句，一般用在资源释放、关闭连接等操作，会在函数关闭前调用。\n\n多个defer的定义与执行类似于栈的操作：先进后出，最先定义的最后执行。\n\n<!-- more -->\n\n请先看下边几段代码，然后判断一下各自输出内容：\n```\n// 示例代码一：\nfunc funcA() int {\n    x := 5\n    defer func() {\n        x += 1\n    }()\n    return x\n}\n// 示例代码二：\nfunc funcB() (x int) {\n    defer func() {\n        x += 1\n    }()\n    return 5\n}\n\n// 示例代码三：\nfunc funcC() (y int) {\n    x := 5\n    defer func() {\n        x += 1\n    }()\n    return x\n}\n \n// 示例代码四：\nfunc funcD() (x int) {\n    defer func(x int) {\n        x += 1\n    }(x)\n    return 5\n}\n```\n解析这几段代码，主要需要理解清楚以下几点知识：\n### 1. return语句的处理过程\n\nreturn xxx 语句并不是一条原子指令，其在执行的时候会进行语句分解成 返回变量=xxx return，最后执行return\n\n### 2. defer语句执行时机\n\n上文说过，defer语句是在函数关闭的时候调用，确切的说是在执行return语句的时候调用，注意，是return 不是return xxx\n\n### 3. 函数参数的传递方式\n\nGo语言中普通的函数参数的传递方式是值传递，即新辟内存拷贝变量值，不包括slice和map，这两种类型是引用传递\n\n### 4. 变量赋值的传递方式\n\nGo语言变量的赋值跟函数参数类似，也是值拷贝，不包括slice和map，这两种类型是内存引用\n\n按照以上原则，解析代码：\n```\n// 解析代码一：返回temp的值，在将x赋值给temp后，temp未发生改变，最终返回值为5\nfunc funcA() int {\n    x := 5\n    temp=x      #temp变量表示未显示声明的return变量\n    func() {\n        x += 1\n    }()\n    return\n}\n\n// 解析代码二：返回x的值，先对其复制5，接着函数中改变为6，最终返回值为6\nfunc funcB() (x int) {\n    x = 5\n    func() {\n        x += 1\n    }()\n    return\n}\n\n// 解析代码三：返回y的值，在将x赋值给y后，y未发生改变，最终返回值为5\nfunc funcC() (y int) {\n    x := 5\n    y = x       #这里是值拷贝\n    func() {\n        x += 1\n    }()\n    return\n}\n\n// 解析代码四：返回x的值，传递x到匿名函数中执行时，传递的是x的拷贝，不影响外部x的值，最终返回值为5\nfunc funcD() (x int) {\n    x := 5\n    func(x int) { #这里是值拷贝\n        x += 1\n    }(x)\n    return\n}\n```\n# Error\nGo语言 通过支持多返回值，让在运行时返回详细的错误信息给调用者变得非常方便。我们可以在编码中通过实现 error 接口类型来生成错误信息，error 接口的定义如下：\n```\ntype error interface {\n    Error() string\n}\n```\n还是通过下面的例子来看看：\n```\npackage main\n\nimport (\n\t\"fmt\"\n)\n\n// 定义一个 DivideError 结构\ntype DivideError struct {\n\tdividee int\n\tdivider int\n}\n\n// 实现 \t`error` 接口\nfunc (de *DivideError) Error() string {\n\tstrFormat := `\n\tCannot proceed, the divider is zero.\n\tdividee: %d\n\tdivider: 0`\n\treturn fmt.Sprintf(strFormat, de.dividee)\n}\n\n// 定义 `int` 类型除法运算的函数\nfunc Divide(varDividee int, varDivider int) (result int, errorMsg string) {\n\tif varDivider == 0 {\n\t\tdData := DivideError{\n\t\t\tdividee: varDividee,\n\t\t\tdivider: varDivider,\n\t\t}\n\t\terrorMsg = dData.Error()\n\t\treturn\n\t} else {\n\t\treturn varDividee / varDivider, \"\"\n\t}\n\n}\n\nfunc main() {\n\n\t// 正常情况\n\tif result, errorMsg := Divide(100, 10); errorMsg == \"\" {\n\t\tfmt.Println(\"100/10 = \", result)\n\t}\n\t// 当被除数为零的时候会返回错误信息\n\tif _, errorMsg := Divide(100, 0); errorMsg != \"\" {\n\t\tfmt.Println(\"errorMsg is: \", errorMsg)\n\t}\n\n}\n```\n运行后可以看到下面的输出：\n```\n100/10 =  10\nerrorMsg is:  \n\tCannot proceed, the divider is zero.\n\tdividee: 100\n\tdivider: 0\n```\n# Panic 和 recover\n定义如下：\n```\nfunc panic(interface{})\nfunc recover() interface{}\n```\npanic 和 recover 是两个内置函数，用于处理 run-time panics 以及程序中自定义的错误。\n\n当执行一个函数 F 的时候，如果显式地调用 panic 函数或者一个 run-time panics 发生时，F 会结束运行，所有 F 中 defer 的函数会按照 FILO 的规则被执行。之后，F 函数的调用者中 defer 的函数再被执行，如此一直到最外层代码。这时，程序已经被中断了而且错误也被一层层抛出来了，其中包括 panic 函数的参数。当前被中断的 goroutine 被称为处于 panicking 状态。由于 panic 函数的参数是空接口类型，所以可以接受任何类型的对象：\n```\npanic(42)\npanic(42)\npanic(\"unreachable\")\npanic(Error(\"cannot parse\"))\n```\nrecover 函数用来获取 panic 函数的参数信息，只能在延时调用 defer 语句调用的函数中直接调用才能生效，如果在 defer 语句中也调用 panic 函数，则只有最后一个被调用的 panic 函数的参数会被 recover 函数获取到。如果 goroutine 没有 panic，那调用 recover 函数会返回 nil。\n```\npackage main\n\nimport (\n\t\"fmt\"\n)\n\n// 最简单的例子\nfunc SimplePanicRecover() {\n\tdefer func() {\n\t\tif err := recover(); err != nil {\n\t\t\tfmt.Println(\"Panic info is: \", err)\n\t\t}\n\t}()\n\tpanic(\"SimplePanicRecover function panic-ed!\")\n}\n\n// 当 defer 中也调用了 panic 函数时，最后被调用的 panic 函数的参数会被后面的 recover 函数获取到\n// 一个函数中可以定义多个 defer 函数，按照 FILO 的规则执行\nfunc MultiPanicRecover() {\n\tdefer func() {\n\t\tif err := recover(); err != nil {\n\t\t\tfmt.Println(\"Panic info is: \", err)\n\t\t}\n\t}()\n\tdefer func() {\n\t\tpanic(\"MultiPanicRecover defer inner panic\")\n\t}()\n\tdefer func() {\n\t\tif err := recover(); err != nil {\n\t\t\tfmt.Println(\"Panic info is: \", err)\n\t\t}\n\t}()\n\tpanic(\"MultiPanicRecover function panic-ed!\")\n}\n\n// recover 函数只有在 defer 函数中被直接调用的时候才可以获取 panic 的参数\nfunc RecoverPlaceTest() {\n\t// 下面一行代码中 recover 函数会返回 nil，但也不影响程序运行\n\tdefer recover()\n\t// recover 函数返回 nil\n\tdefer fmt.Println(\"recover() is: \", recover())\n\tdefer func() {\n\t\tfunc() {\n\t\t\t// 由于不是在 defer 调用函数中直接调用 recover 函数，recover 函数会返回 nil\n\t\t\tif err := recover(); err != nil {\n\t\t\t\tfmt.Println(\"Panic info is: \", err)\n\t\t\t}\n\t\t}()\n\n\t}()\n\tdefer func() {\n\t\tif err := recover(); err != nil {\n\t\t\tfmt.Println(\"Panic info is: \", err)\n\t\t}\n\t}()\n\tpanic(\"RecoverPlaceTest function panic-ed!\")\n}\n\n// 如果函数没有 panic，调用 recover 函数不会获取到任何信息，也不会影响当前进程。\nfunc NoPanicButHasRecover() {\n\tif err := recover(); err != nil {\n\t\tfmt.Println(\"NoPanicButHasRecover Panic info is: \", err)\n\t} else {\n\t\tfmt.Println(\"NoPanicButHasRecover Panic info is: \", err)\n\t}\n}\n\n// 定义一个调用 recover 函数的函数\nfunc CallRecover() {\n\tif err := recover(); err != nil {\n\t\tfmt.Println(\"Panic info is: \", err)\n\t}\n}\n\n// 定义个函数，在其中 defer 另一个调用了 recover 函数的函数\nfunc RecoverInOutterFunc() {\n\tdefer CallRecover()\n\tpanic(\"RecoverInOutterFunc function panic-ed!\")\n}\n\nfunc main() {\n\tSimplePanicRecover()\n\tMultiPanicRecover()\n\tRecoverPlaceTest()\n\tNoPanicButHasRecover()\n\tRecoverInOutterFunc()\n}\n```\n运行后可以看到下面的输出：\n```\nPanic info is:  SimplePanicRecover function panic-ed!\nPanic info is:  MultiPanicRecover function panic-ed!\nPanic info is:  MultiPanicRecover defer inner panic\nPanic info is:  RecoverPlaceTest function panic-ed!\nrecover() is:  <nil>\nNoPanicButHasRecover Panic info is:  <nil>\nPanic info is:  RecoverInOutterFunc function panic-ed!\n```\n","slug":"error","published":1,"updated":"2018-07-27T07:16:30.024Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlqdfcwl0006owv3vkp0scy5","content":"<h3 id=\"1-如果项目中的代码、使用的标准库以及第三方库在运行时内部捕获了异常并通过合适的-error-对象返回给调用者，那我们可以尽量少甚至可以不用-panic-函数。\"><a href=\"#1-如果项目中的代码、使用的标准库以及第三方库在运行时内部捕获了异常并通过合适的-error-对象返回给调用者，那我们可以尽量少甚至可以不用-panic-函数。\" class=\"headerlink\" title=\"1. 如果项目中的代码、使用的标准库以及第三方库在运行时内部捕获了异常并通过合适的 error 对象返回给调用者，那我们可以尽量少甚至可以不用 panic 函数。\"></a>1. 如果项目中的代码、使用的标准库以及第三方库在运行时内部捕获了异常并通过合适的 error 对象返回给调用者，那我们可以尽量少甚至可以不用 panic 函数。</h3><h3 id=\"2-如果无法保证上面的情况，那为了确保程序在运行时不会因为-未知的未知-导致崩溃，那-panic-函数的使用可能不得不加在任何需要的地方。\"><a href=\"#2-如果无法保证上面的情况，那为了确保程序在运行时不会因为-未知的未知-导致崩溃，那-panic-函数的使用可能不得不加在任何需要的地方。\" class=\"headerlink\" title=\"2. 如果无法保证上面的情况，那为了确保程序在运行时不会因为 未知的未知 导致崩溃，那 panic 函数的使用可能不得不加在任何需要的地方。\"></a>2. 如果无法保证上面的情况，那为了确保程序在运行时不会因为 未知的未知 导致崩溃，那 panic 函数的使用可能不得不加在任何需要的地方。</h3><h3 id=\"3-我们应该认识到，panic是我们和计算机都不希望看到的，应该在设计开发的时候充分考虑使用场景可能出现的情况，处理好-已知的未知，在确定需要的地方使用-panic-机制。\"><a href=\"#3-我们应该认识到，panic是我们和计算机都不希望看到的，应该在设计开发的时候充分考虑使用场景可能出现的情况，处理好-已知的未知，在确定需要的地方使用-panic-机制。\" class=\"headerlink\" title=\"3. 我们应该认识到，panic是我们和计算机都不希望看到的，应该在设计开发的时候充分考虑使用场景可能出现的情况，处理好 已知的未知，在确定需要的地方使用 panic 机制。\"></a>3. 我们应该认识到，panic是我们和计算机都不希望看到的，应该在设计开发的时候充分考虑使用场景可能出现的情况，处理好 已知的未知，在确定需要的地方使用 panic 机制。</h3><h1 id=\"defer\"><a href=\"#defer\" class=\"headerlink\" title=\"defer\"></a>defer</h1><p>defer关键字用来标记最后执行的Go语句，一般用在资源释放、关闭连接等操作，会在函数关闭前调用。</p>\n<p>多个defer的定义与执行类似于栈的操作：先进后出，最先定义的最后执行。</p>\n<a id=\"more\"></a>\n<p>请先看下边几段代码，然后判断一下各自输出内容：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 示例代码一：</span><br><span class=\"line\">func funcA() int &#123;</span><br><span class=\"line\">    x := 5</span><br><span class=\"line\">    defer func() &#123;</span><br><span class=\"line\">        x += 1</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    return x</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 示例代码二：</span><br><span class=\"line\">func funcB() (x int) &#123;</span><br><span class=\"line\">    defer func() &#123;</span><br><span class=\"line\">        x += 1</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    return 5</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 示例代码三：</span><br><span class=\"line\">func funcC() (y int) &#123;</span><br><span class=\"line\">    x := 5</span><br><span class=\"line\">    defer func() &#123;</span><br><span class=\"line\">        x += 1</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    return x</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">// 示例代码四：</span><br><span class=\"line\">func funcD() (x int) &#123;</span><br><span class=\"line\">    defer func(x int) &#123;</span><br><span class=\"line\">        x += 1</span><br><span class=\"line\">    &#125;(x)</span><br><span class=\"line\">    return 5</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>解析这几段代码，主要需要理解清楚以下几点知识：</p>\n<h3 id=\"1-return语句的处理过程\"><a href=\"#1-return语句的处理过程\" class=\"headerlink\" title=\"1. return语句的处理过程\"></a>1. return语句的处理过程</h3><p>return xxx 语句并不是一条原子指令，其在执行的时候会进行语句分解成 返回变量=xxx return，最后执行return</p>\n<h3 id=\"2-defer语句执行时机\"><a href=\"#2-defer语句执行时机\" class=\"headerlink\" title=\"2. defer语句执行时机\"></a>2. defer语句执行时机</h3><p>上文说过，defer语句是在函数关闭的时候调用，确切的说是在执行return语句的时候调用，注意，是return 不是return xxx</p>\n<h3 id=\"3-函数参数的传递方式\"><a href=\"#3-函数参数的传递方式\" class=\"headerlink\" title=\"3. 函数参数的传递方式\"></a>3. 函数参数的传递方式</h3><p>Go语言中普通的函数参数的传递方式是值传递，即新辟内存拷贝变量值，不包括slice和map，这两种类型是引用传递</p>\n<h3 id=\"4-变量赋值的传递方式\"><a href=\"#4-变量赋值的传递方式\" class=\"headerlink\" title=\"4. 变量赋值的传递方式\"></a>4. 变量赋值的传递方式</h3><p>Go语言变量的赋值跟函数参数类似，也是值拷贝，不包括slice和map，这两种类型是内存引用</p>\n<p>按照以上原则，解析代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 解析代码一：返回temp的值，在将x赋值给temp后，temp未发生改变，最终返回值为5</span><br><span class=\"line\">func funcA() int &#123;</span><br><span class=\"line\">    x := 5</span><br><span class=\"line\">    temp=x      #temp变量表示未显示声明的return变量</span><br><span class=\"line\">    func() &#123;</span><br><span class=\"line\">        x += 1</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    return</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 解析代码二：返回x的值，先对其复制5，接着函数中改变为6，最终返回值为6</span><br><span class=\"line\">func funcB() (x int) &#123;</span><br><span class=\"line\">    x = 5</span><br><span class=\"line\">    func() &#123;</span><br><span class=\"line\">        x += 1</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    return</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 解析代码三：返回y的值，在将x赋值给y后，y未发生改变，最终返回值为5</span><br><span class=\"line\">func funcC() (y int) &#123;</span><br><span class=\"line\">    x := 5</span><br><span class=\"line\">    y = x       #这里是值拷贝</span><br><span class=\"line\">    func() &#123;</span><br><span class=\"line\">        x += 1</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    return</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 解析代码四：返回x的值，传递x到匿名函数中执行时，传递的是x的拷贝，不影响外部x的值，最终返回值为5</span><br><span class=\"line\">func funcD() (x int) &#123;</span><br><span class=\"line\">    x := 5</span><br><span class=\"line\">    func(x int) &#123; #这里是值拷贝</span><br><span class=\"line\">        x += 1</span><br><span class=\"line\">    &#125;(x)</span><br><span class=\"line\">    return</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"Error\"><a href=\"#Error\" class=\"headerlink\" title=\"Error\"></a>Error</h1><p>Go语言 通过支持多返回值，让在运行时返回详细的错误信息给调用者变得非常方便。我们可以在编码中通过实现 error 接口类型来生成错误信息，error 接口的定义如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type error interface &#123;</span><br><span class=\"line\">    Error() string</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>还是通过下面的例子来看看：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">\t&quot;fmt&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">// 定义一个 DivideError 结构</span><br><span class=\"line\">type DivideError struct &#123;</span><br><span class=\"line\">\tdividee int</span><br><span class=\"line\">\tdivider int</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 实现 \t`error` 接口</span><br><span class=\"line\">func (de *DivideError) Error() string &#123;</span><br><span class=\"line\">\tstrFormat := `</span><br><span class=\"line\">\tCannot proceed, the divider is zero.</span><br><span class=\"line\">\tdividee: %d</span><br><span class=\"line\">\tdivider: 0`</span><br><span class=\"line\">\treturn fmt.Sprintf(strFormat, de.dividee)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 定义 `int` 类型除法运算的函数</span><br><span class=\"line\">func Divide(varDividee int, varDivider int) (result int, errorMsg string) &#123;</span><br><span class=\"line\">\tif varDivider == 0 &#123;</span><br><span class=\"line\">\t\tdData := DivideError&#123;</span><br><span class=\"line\">\t\t\tdividee: varDividee,</span><br><span class=\"line\">\t\t\tdivider: varDivider,</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\terrorMsg = dData.Error()</span><br><span class=\"line\">\t\treturn</span><br><span class=\"line\">\t&#125; else &#123;</span><br><span class=\"line\">\t\treturn varDividee / varDivider, &quot;&quot;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t// 正常情况</span><br><span class=\"line\">\tif result, errorMsg := Divide(100, 10); errorMsg == &quot;&quot; &#123;</span><br><span class=\"line\">\t\tfmt.Println(&quot;100/10 = &quot;, result)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t// 当被除数为零的时候会返回错误信息</span><br><span class=\"line\">\tif _, errorMsg := Divide(100, 0); errorMsg != &quot;&quot; &#123;</span><br><span class=\"line\">\t\tfmt.Println(&quot;errorMsg is: &quot;, errorMsg)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行后可以看到下面的输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">100/10 =  10</span><br><span class=\"line\">errorMsg is:  </span><br><span class=\"line\">\tCannot proceed, the divider is zero.</span><br><span class=\"line\">\tdividee: 100</span><br><span class=\"line\">\tdivider: 0</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"Panic-和-recover\"><a href=\"#Panic-和-recover\" class=\"headerlink\" title=\"Panic 和 recover\"></a>Panic 和 recover</h1><p>定义如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func panic(interface&#123;&#125;)</span><br><span class=\"line\">func recover() interface&#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>panic 和 recover 是两个内置函数，用于处理 run-time panics 以及程序中自定义的错误。</p>\n<p>当执行一个函数 F 的时候，如果显式地调用 panic 函数或者一个 run-time panics 发生时，F 会结束运行，所有 F 中 defer 的函数会按照 FILO 的规则被执行。之后，F 函数的调用者中 defer 的函数再被执行，如此一直到最外层代码。这时，程序已经被中断了而且错误也被一层层抛出来了，其中包括 panic 函数的参数。当前被中断的 goroutine 被称为处于 panicking 状态。由于 panic 函数的参数是空接口类型，所以可以接受任何类型的对象：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">panic(42)</span><br><span class=\"line\">panic(42)</span><br><span class=\"line\">panic(&quot;unreachable&quot;)</span><br><span class=\"line\">panic(Error(&quot;cannot parse&quot;))</span><br></pre></td></tr></table></figure></p>\n<p>recover 函数用来获取 panic 函数的参数信息，只能在延时调用 defer 语句调用的函数中直接调用才能生效，如果在 defer 语句中也调用 panic 函数，则只有最后一个被调用的 panic 函数的参数会被 recover 函数获取到。如果 goroutine 没有 panic，那调用 recover 函数会返回 nil。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">\t&quot;fmt&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">// 最简单的例子</span><br><span class=\"line\">func SimplePanicRecover() &#123;</span><br><span class=\"line\">\tdefer func() &#123;</span><br><span class=\"line\">\t\tif err := recover(); err != nil &#123;</span><br><span class=\"line\">\t\t\tfmt.Println(&quot;Panic info is: &quot;, err)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\tpanic(&quot;SimplePanicRecover function panic-ed!&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 当 defer 中也调用了 panic 函数时，最后被调用的 panic 函数的参数会被后面的 recover 函数获取到</span><br><span class=\"line\">// 一个函数中可以定义多个 defer 函数，按照 FILO 的规则执行</span><br><span class=\"line\">func MultiPanicRecover() &#123;</span><br><span class=\"line\">\tdefer func() &#123;</span><br><span class=\"line\">\t\tif err := recover(); err != nil &#123;</span><br><span class=\"line\">\t\t\tfmt.Println(&quot;Panic info is: &quot;, err)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\tdefer func() &#123;</span><br><span class=\"line\">\t\tpanic(&quot;MultiPanicRecover defer inner panic&quot;)</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\tdefer func() &#123;</span><br><span class=\"line\">\t\tif err := recover(); err != nil &#123;</span><br><span class=\"line\">\t\t\tfmt.Println(&quot;Panic info is: &quot;, err)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\tpanic(&quot;MultiPanicRecover function panic-ed!&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// recover 函数只有在 defer 函数中被直接调用的时候才可以获取 panic 的参数</span><br><span class=\"line\">func RecoverPlaceTest() &#123;</span><br><span class=\"line\">\t// 下面一行代码中 recover 函数会返回 nil，但也不影响程序运行</span><br><span class=\"line\">\tdefer recover()</span><br><span class=\"line\">\t// recover 函数返回 nil</span><br><span class=\"line\">\tdefer fmt.Println(&quot;recover() is: &quot;, recover())</span><br><span class=\"line\">\tdefer func() &#123;</span><br><span class=\"line\">\t\tfunc() &#123;</span><br><span class=\"line\">\t\t\t// 由于不是在 defer 调用函数中直接调用 recover 函数，recover 函数会返回 nil</span><br><span class=\"line\">\t\t\tif err := recover(); err != nil &#123;</span><br><span class=\"line\">\t\t\t\tfmt.Println(&quot;Panic info is: &quot;, err)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\tdefer func() &#123;</span><br><span class=\"line\">\t\tif err := recover(); err != nil &#123;</span><br><span class=\"line\">\t\t\tfmt.Println(&quot;Panic info is: &quot;, err)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\tpanic(&quot;RecoverPlaceTest function panic-ed!&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 如果函数没有 panic，调用 recover 函数不会获取到任何信息，也不会影响当前进程。</span><br><span class=\"line\">func NoPanicButHasRecover() &#123;</span><br><span class=\"line\">\tif err := recover(); err != nil &#123;</span><br><span class=\"line\">\t\tfmt.Println(&quot;NoPanicButHasRecover Panic info is: &quot;, err)</span><br><span class=\"line\">\t&#125; else &#123;</span><br><span class=\"line\">\t\tfmt.Println(&quot;NoPanicButHasRecover Panic info is: &quot;, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 定义一个调用 recover 函数的函数</span><br><span class=\"line\">func CallRecover() &#123;</span><br><span class=\"line\">\tif err := recover(); err != nil &#123;</span><br><span class=\"line\">\t\tfmt.Println(&quot;Panic info is: &quot;, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 定义个函数，在其中 defer 另一个调用了 recover 函数的函数</span><br><span class=\"line\">func RecoverInOutterFunc() &#123;</span><br><span class=\"line\">\tdefer CallRecover()</span><br><span class=\"line\">\tpanic(&quot;RecoverInOutterFunc function panic-ed!&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">\tSimplePanicRecover()</span><br><span class=\"line\">\tMultiPanicRecover()</span><br><span class=\"line\">\tRecoverPlaceTest()</span><br><span class=\"line\">\tNoPanicButHasRecover()</span><br><span class=\"line\">\tRecoverInOutterFunc()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行后可以看到下面的输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Panic info is:  SimplePanicRecover function panic-ed!</span><br><span class=\"line\">Panic info is:  MultiPanicRecover function panic-ed!</span><br><span class=\"line\">Panic info is:  MultiPanicRecover defer inner panic</span><br><span class=\"line\">Panic info is:  RecoverPlaceTest function panic-ed!</span><br><span class=\"line\">recover() is:  &lt;nil&gt;</span><br><span class=\"line\">NoPanicButHasRecover Panic info is:  &lt;nil&gt;</span><br><span class=\"line\">Panic info is:  RecoverInOutterFunc function panic-ed!</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"1-如果项目中的代码、使用的标准库以及第三方库在运行时内部捕获了异常并通过合适的-error-对象返回给调用者，那我们可以尽量少甚至可以不用-panic-函数。\"><a href=\"#1-如果项目中的代码、使用的标准库以及第三方库在运行时内部捕获了异常并通过合适的-error-对象返回给调用者，那我们可以尽量少甚至可以不用-panic-函数。\" class=\"headerlink\" title=\"1. 如果项目中的代码、使用的标准库以及第三方库在运行时内部捕获了异常并通过合适的 error 对象返回给调用者，那我们可以尽量少甚至可以不用 panic 函数。\"></a>1. 如果项目中的代码、使用的标准库以及第三方库在运行时内部捕获了异常并通过合适的 error 对象返回给调用者，那我们可以尽量少甚至可以不用 panic 函数。</h3><h3 id=\"2-如果无法保证上面的情况，那为了确保程序在运行时不会因为-未知的未知-导致崩溃，那-panic-函数的使用可能不得不加在任何需要的地方。\"><a href=\"#2-如果无法保证上面的情况，那为了确保程序在运行时不会因为-未知的未知-导致崩溃，那-panic-函数的使用可能不得不加在任何需要的地方。\" class=\"headerlink\" title=\"2. 如果无法保证上面的情况，那为了确保程序在运行时不会因为 未知的未知 导致崩溃，那 panic 函数的使用可能不得不加在任何需要的地方。\"></a>2. 如果无法保证上面的情况，那为了确保程序在运行时不会因为 未知的未知 导致崩溃，那 panic 函数的使用可能不得不加在任何需要的地方。</h3><h3 id=\"3-我们应该认识到，panic是我们和计算机都不希望看到的，应该在设计开发的时候充分考虑使用场景可能出现的情况，处理好-已知的未知，在确定需要的地方使用-panic-机制。\"><a href=\"#3-我们应该认识到，panic是我们和计算机都不希望看到的，应该在设计开发的时候充分考虑使用场景可能出现的情况，处理好-已知的未知，在确定需要的地方使用-panic-机制。\" class=\"headerlink\" title=\"3. 我们应该认识到，panic是我们和计算机都不希望看到的，应该在设计开发的时候充分考虑使用场景可能出现的情况，处理好 已知的未知，在确定需要的地方使用 panic 机制。\"></a>3. 我们应该认识到，panic是我们和计算机都不希望看到的，应该在设计开发的时候充分考虑使用场景可能出现的情况，处理好 已知的未知，在确定需要的地方使用 panic 机制。</h3><h1 id=\"defer\"><a href=\"#defer\" class=\"headerlink\" title=\"defer\"></a>defer</h1><p>defer关键字用来标记最后执行的Go语句，一般用在资源释放、关闭连接等操作，会在函数关闭前调用。</p>\n<p>多个defer的定义与执行类似于栈的操作：先进后出，最先定义的最后执行。</p>","more":"<p>请先看下边几段代码，然后判断一下各自输出内容：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 示例代码一：</span><br><span class=\"line\">func funcA() int &#123;</span><br><span class=\"line\">    x := 5</span><br><span class=\"line\">    defer func() &#123;</span><br><span class=\"line\">        x += 1</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    return x</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 示例代码二：</span><br><span class=\"line\">func funcB() (x int) &#123;</span><br><span class=\"line\">    defer func() &#123;</span><br><span class=\"line\">        x += 1</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    return 5</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 示例代码三：</span><br><span class=\"line\">func funcC() (y int) &#123;</span><br><span class=\"line\">    x := 5</span><br><span class=\"line\">    defer func() &#123;</span><br><span class=\"line\">        x += 1</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    return x</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">// 示例代码四：</span><br><span class=\"line\">func funcD() (x int) &#123;</span><br><span class=\"line\">    defer func(x int) &#123;</span><br><span class=\"line\">        x += 1</span><br><span class=\"line\">    &#125;(x)</span><br><span class=\"line\">    return 5</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>解析这几段代码，主要需要理解清楚以下几点知识：</p>\n<h3 id=\"1-return语句的处理过程\"><a href=\"#1-return语句的处理过程\" class=\"headerlink\" title=\"1. return语句的处理过程\"></a>1. return语句的处理过程</h3><p>return xxx 语句并不是一条原子指令，其在执行的时候会进行语句分解成 返回变量=xxx return，最后执行return</p>\n<h3 id=\"2-defer语句执行时机\"><a href=\"#2-defer语句执行时机\" class=\"headerlink\" title=\"2. defer语句执行时机\"></a>2. defer语句执行时机</h3><p>上文说过，defer语句是在函数关闭的时候调用，确切的说是在执行return语句的时候调用，注意，是return 不是return xxx</p>\n<h3 id=\"3-函数参数的传递方式\"><a href=\"#3-函数参数的传递方式\" class=\"headerlink\" title=\"3. 函数参数的传递方式\"></a>3. 函数参数的传递方式</h3><p>Go语言中普通的函数参数的传递方式是值传递，即新辟内存拷贝变量值，不包括slice和map，这两种类型是引用传递</p>\n<h3 id=\"4-变量赋值的传递方式\"><a href=\"#4-变量赋值的传递方式\" class=\"headerlink\" title=\"4. 变量赋值的传递方式\"></a>4. 变量赋值的传递方式</h3><p>Go语言变量的赋值跟函数参数类似，也是值拷贝，不包括slice和map，这两种类型是内存引用</p>\n<p>按照以上原则，解析代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 解析代码一：返回temp的值，在将x赋值给temp后，temp未发生改变，最终返回值为5</span><br><span class=\"line\">func funcA() int &#123;</span><br><span class=\"line\">    x := 5</span><br><span class=\"line\">    temp=x      #temp变量表示未显示声明的return变量</span><br><span class=\"line\">    func() &#123;</span><br><span class=\"line\">        x += 1</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    return</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 解析代码二：返回x的值，先对其复制5，接着函数中改变为6，最终返回值为6</span><br><span class=\"line\">func funcB() (x int) &#123;</span><br><span class=\"line\">    x = 5</span><br><span class=\"line\">    func() &#123;</span><br><span class=\"line\">        x += 1</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    return</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 解析代码三：返回y的值，在将x赋值给y后，y未发生改变，最终返回值为5</span><br><span class=\"line\">func funcC() (y int) &#123;</span><br><span class=\"line\">    x := 5</span><br><span class=\"line\">    y = x       #这里是值拷贝</span><br><span class=\"line\">    func() &#123;</span><br><span class=\"line\">        x += 1</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    return</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 解析代码四：返回x的值，传递x到匿名函数中执行时，传递的是x的拷贝，不影响外部x的值，最终返回值为5</span><br><span class=\"line\">func funcD() (x int) &#123;</span><br><span class=\"line\">    x := 5</span><br><span class=\"line\">    func(x int) &#123; #这里是值拷贝</span><br><span class=\"line\">        x += 1</span><br><span class=\"line\">    &#125;(x)</span><br><span class=\"line\">    return</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"Error\"><a href=\"#Error\" class=\"headerlink\" title=\"Error\"></a>Error</h1><p>Go语言 通过支持多返回值，让在运行时返回详细的错误信息给调用者变得非常方便。我们可以在编码中通过实现 error 接口类型来生成错误信息，error 接口的定义如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type error interface &#123;</span><br><span class=\"line\">    Error() string</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>还是通过下面的例子来看看：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">\t&quot;fmt&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">// 定义一个 DivideError 结构</span><br><span class=\"line\">type DivideError struct &#123;</span><br><span class=\"line\">\tdividee int</span><br><span class=\"line\">\tdivider int</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 实现 \t`error` 接口</span><br><span class=\"line\">func (de *DivideError) Error() string &#123;</span><br><span class=\"line\">\tstrFormat := `</span><br><span class=\"line\">\tCannot proceed, the divider is zero.</span><br><span class=\"line\">\tdividee: %d</span><br><span class=\"line\">\tdivider: 0`</span><br><span class=\"line\">\treturn fmt.Sprintf(strFormat, de.dividee)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 定义 `int` 类型除法运算的函数</span><br><span class=\"line\">func Divide(varDividee int, varDivider int) (result int, errorMsg string) &#123;</span><br><span class=\"line\">\tif varDivider == 0 &#123;</span><br><span class=\"line\">\t\tdData := DivideError&#123;</span><br><span class=\"line\">\t\t\tdividee: varDividee,</span><br><span class=\"line\">\t\t\tdivider: varDivider,</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\terrorMsg = dData.Error()</span><br><span class=\"line\">\t\treturn</span><br><span class=\"line\">\t&#125; else &#123;</span><br><span class=\"line\">\t\treturn varDividee / varDivider, &quot;&quot;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t// 正常情况</span><br><span class=\"line\">\tif result, errorMsg := Divide(100, 10); errorMsg == &quot;&quot; &#123;</span><br><span class=\"line\">\t\tfmt.Println(&quot;100/10 = &quot;, result)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t// 当被除数为零的时候会返回错误信息</span><br><span class=\"line\">\tif _, errorMsg := Divide(100, 0); errorMsg != &quot;&quot; &#123;</span><br><span class=\"line\">\t\tfmt.Println(&quot;errorMsg is: &quot;, errorMsg)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行后可以看到下面的输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">100/10 =  10</span><br><span class=\"line\">errorMsg is:  </span><br><span class=\"line\">\tCannot proceed, the divider is zero.</span><br><span class=\"line\">\tdividee: 100</span><br><span class=\"line\">\tdivider: 0</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"Panic-和-recover\"><a href=\"#Panic-和-recover\" class=\"headerlink\" title=\"Panic 和 recover\"></a>Panic 和 recover</h1><p>定义如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func panic(interface&#123;&#125;)</span><br><span class=\"line\">func recover() interface&#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>panic 和 recover 是两个内置函数，用于处理 run-time panics 以及程序中自定义的错误。</p>\n<p>当执行一个函数 F 的时候，如果显式地调用 panic 函数或者一个 run-time panics 发生时，F 会结束运行，所有 F 中 defer 的函数会按照 FILO 的规则被执行。之后，F 函数的调用者中 defer 的函数再被执行，如此一直到最外层代码。这时，程序已经被中断了而且错误也被一层层抛出来了，其中包括 panic 函数的参数。当前被中断的 goroutine 被称为处于 panicking 状态。由于 panic 函数的参数是空接口类型，所以可以接受任何类型的对象：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">panic(42)</span><br><span class=\"line\">panic(42)</span><br><span class=\"line\">panic(&quot;unreachable&quot;)</span><br><span class=\"line\">panic(Error(&quot;cannot parse&quot;))</span><br></pre></td></tr></table></figure></p>\n<p>recover 函数用来获取 panic 函数的参数信息，只能在延时调用 defer 语句调用的函数中直接调用才能生效，如果在 defer 语句中也调用 panic 函数，则只有最后一个被调用的 panic 函数的参数会被 recover 函数获取到。如果 goroutine 没有 panic，那调用 recover 函数会返回 nil。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">\t&quot;fmt&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">// 最简单的例子</span><br><span class=\"line\">func SimplePanicRecover() &#123;</span><br><span class=\"line\">\tdefer func() &#123;</span><br><span class=\"line\">\t\tif err := recover(); err != nil &#123;</span><br><span class=\"line\">\t\t\tfmt.Println(&quot;Panic info is: &quot;, err)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\tpanic(&quot;SimplePanicRecover function panic-ed!&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 当 defer 中也调用了 panic 函数时，最后被调用的 panic 函数的参数会被后面的 recover 函数获取到</span><br><span class=\"line\">// 一个函数中可以定义多个 defer 函数，按照 FILO 的规则执行</span><br><span class=\"line\">func MultiPanicRecover() &#123;</span><br><span class=\"line\">\tdefer func() &#123;</span><br><span class=\"line\">\t\tif err := recover(); err != nil &#123;</span><br><span class=\"line\">\t\t\tfmt.Println(&quot;Panic info is: &quot;, err)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\tdefer func() &#123;</span><br><span class=\"line\">\t\tpanic(&quot;MultiPanicRecover defer inner panic&quot;)</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\tdefer func() &#123;</span><br><span class=\"line\">\t\tif err := recover(); err != nil &#123;</span><br><span class=\"line\">\t\t\tfmt.Println(&quot;Panic info is: &quot;, err)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\tpanic(&quot;MultiPanicRecover function panic-ed!&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// recover 函数只有在 defer 函数中被直接调用的时候才可以获取 panic 的参数</span><br><span class=\"line\">func RecoverPlaceTest() &#123;</span><br><span class=\"line\">\t// 下面一行代码中 recover 函数会返回 nil，但也不影响程序运行</span><br><span class=\"line\">\tdefer recover()</span><br><span class=\"line\">\t// recover 函数返回 nil</span><br><span class=\"line\">\tdefer fmt.Println(&quot;recover() is: &quot;, recover())</span><br><span class=\"line\">\tdefer func() &#123;</span><br><span class=\"line\">\t\tfunc() &#123;</span><br><span class=\"line\">\t\t\t// 由于不是在 defer 调用函数中直接调用 recover 函数，recover 函数会返回 nil</span><br><span class=\"line\">\t\t\tif err := recover(); err != nil &#123;</span><br><span class=\"line\">\t\t\t\tfmt.Println(&quot;Panic info is: &quot;, err)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\tdefer func() &#123;</span><br><span class=\"line\">\t\tif err := recover(); err != nil &#123;</span><br><span class=\"line\">\t\t\tfmt.Println(&quot;Panic info is: &quot;, err)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\tpanic(&quot;RecoverPlaceTest function panic-ed!&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 如果函数没有 panic，调用 recover 函数不会获取到任何信息，也不会影响当前进程。</span><br><span class=\"line\">func NoPanicButHasRecover() &#123;</span><br><span class=\"line\">\tif err := recover(); err != nil &#123;</span><br><span class=\"line\">\t\tfmt.Println(&quot;NoPanicButHasRecover Panic info is: &quot;, err)</span><br><span class=\"line\">\t&#125; else &#123;</span><br><span class=\"line\">\t\tfmt.Println(&quot;NoPanicButHasRecover Panic info is: &quot;, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 定义一个调用 recover 函数的函数</span><br><span class=\"line\">func CallRecover() &#123;</span><br><span class=\"line\">\tif err := recover(); err != nil &#123;</span><br><span class=\"line\">\t\tfmt.Println(&quot;Panic info is: &quot;, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 定义个函数，在其中 defer 另一个调用了 recover 函数的函数</span><br><span class=\"line\">func RecoverInOutterFunc() &#123;</span><br><span class=\"line\">\tdefer CallRecover()</span><br><span class=\"line\">\tpanic(&quot;RecoverInOutterFunc function panic-ed!&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">\tSimplePanicRecover()</span><br><span class=\"line\">\tMultiPanicRecover()</span><br><span class=\"line\">\tRecoverPlaceTest()</span><br><span class=\"line\">\tNoPanicButHasRecover()</span><br><span class=\"line\">\tRecoverInOutterFunc()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行后可以看到下面的输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Panic info is:  SimplePanicRecover function panic-ed!</span><br><span class=\"line\">Panic info is:  MultiPanicRecover function panic-ed!</span><br><span class=\"line\">Panic info is:  MultiPanicRecover defer inner panic</span><br><span class=\"line\">Panic info is:  RecoverPlaceTest function panic-ed!</span><br><span class=\"line\">recover() is:  &lt;nil&gt;</span><br><span class=\"line\">NoPanicButHasRecover Panic info is:  &lt;nil&gt;</span><br><span class=\"line\">Panic info is:  RecoverInOutterFunc function panic-ed!</span><br></pre></td></tr></table></figure></p>"},{"title":"Golang的调度模型概览","date":"2018-08-03T01:38:06.000Z","_content":"\n调度的机制用一句话描述：  \nruntime准备好G,P,M，然后M绑定P，M从各种队列中获取G，切换到G的执行栈上并执行G上的任务函数，调用goexit做清理工作并回到M，如此反复。\n\n### 基本概念\n#### M（machine）\n* M代表着真正的执行计算资源，可以认为它就是os thread（系统线程）。\n* M是真正调度系统的执行者，每个M就像一个勤劳的工作者，总是从各种队列中找到可运行的G，而且这样M的可以同时存在多个。\n* M在绑定有效的P后，进入调度循环，而且M并不保留G状态，这是G可以跨M调度的基础。\n\n<!-- more -->\n\n#### P（processor）\n* P表示逻辑processor，是线程M的执行的上下文。\n* P的最大作用是其拥有的各种G对象队列、链表、cache和状态。\n\n#### G（goroutine）\n* 调度系统的最基本单位goroutine，存储了goroutine的执行stack信息、goroutine状态以及goroutine的任务函数等。\n* 在G的眼中只有P，P就是运行G的“CPU”。\n* 相当于两级线程\n\n#### 线程实现模型\n来自`Go并发编程实战`\n```\n                    +-------+       +-------+      \n                    |  KSE  |       |  KSE  |          \n                    +-------+       +-------+      \n                        |               |                       内核空间\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -        \n                        |               |                       用户空间\n                    +-------+       +-------+\n                    |   M   |       |   M   |\n                    +-------+       +-------+\n                  |          |         |          |\n              +------+   +------+   +------+   +------+            \n              |   P  |   |   P  |   |   P  |   |   P  |\n              +------+   +------+   +------+   +------+   \n           |     |     |     |     |     |     |     |     | \n         +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ \n         | G | | G | | G | | G | | G | | G | | G | | G | | G | \n         +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ \n```\n* KSE（Kernel Scheduling Entity）是内核调度实体           \n* M与P，P与G之前的关联都是动态的，可以变的\n\n### 关系示意图\n来自`golang源码剖析`\n```\n                            +-------------------- sysmon ---------------//------+ \n                            |                                                   |\n                            |                                                   |\n               +---+      +---+-------+                   +--------+          +---+---+\ngo func() ---> | G | ---> | P | local | <=== balance ===> | global | <--//--- | P | M |\n               +---+      +---+-------+                   +--------+          +---+---+\n                            |                                 |                 | \n                            |      +---+                      |                 |\n                            +----> | M | <--- findrunnable ---+--- steal <--//--+\n                                   +---+ \n                                     |\n                                   mstart\n                                     |\n              +--- execute <----- schedule \n              |                      |   \n              |                      |\n              +--> G.fn --> goexit --+ \n\n\n              1. go func() 语气创建G。\n              2. 将G放入P的本地队列（或者平衡到全局全局队列）。\n              3. 唤醒或新建M来执行任务。\n              4. 进入调度循环\n              5. 尽力获取可执行的G，并执行\n              6. 清理现场并且重新进入调度循环\n\n```\n\n\n## GPM的来由\n### 特殊的g0和m0\ng0和m0是在`proc.go`文件中的两个全局变量，m0就是进程启动后的初始线程，g0也是代表着初始线程的stack  \n`asm_amd64.go` --> runtime·rt0_go(SB)\n```go \n\t// 程序刚启动的时候必定有一个线程启动（主线程）\n\t// 将当前的栈和资源保存在g0\n\t// 将该线程保存在m0\n\t// tls: Thread Local Storage\n\t// set the per-goroutine and per-mach \"registers\"\n\tget_tls(BX)\n\tLEAQ\truntime·g0(SB), CX\n\tMOVQ\tCX, g(BX)\n\tLEAQ\truntime·m0(SB), AX\n\n\t// save m->g0 = g0\n\tMOVQ\tCX, m_g0(AX)\n\t// save m0 to g0->m\n\tMOVQ\tAX, g_m(CX)\n```\n\n\n\n### M的一生\n#### M的创建\n`proc.go`\n```go\n// Create a new m. It will start off with a call to fn, or else the scheduler.\n// fn needs to be static and not a heap allocated closure.\n// May run with m.p==nil, so write barriers are not allowed.\n//go:nowritebarrierrec\n// 创建一个新的m，它将从fn或者调度程序开始\nfunc newm(fn func(), _p_ *p) {\n\t// 根据fn和p和绑定一个m对象\n\tmp := allocm(_p_, fn)\n\t// 设置当前m的下一个p为_p_\n\tmp.nextp.set(_p_)\n\tmp.sigmask = initSigmask\n\t...\n\t// 真正的分配os thread\n\tnewm1(mp)\n}\n```\n\n```go\nfunc newm1(mp *m) {\n\t// 对cgo的处理\n\t...\n\texecLock.rlock() // Prevent process clone.\n\t// 创建一个系统线程\n\tnewosproc(mp, unsafe.Pointer(mp.g0.stack.hi))\n\texecLock.runlock()\n}\n```\n#### 状态\n``` \n       mstart\n          |\n          v        找不到可执行任务，gc STW，\n      +------+     任务执行时间过长，系统阻塞等   +------+\n      | spin | ----------------------------> |unspin| \n      +------+          mstop                +------+\n          ^                                      |\n          |                                      v\n      notewakeup <-------------------------  notesleep\n```\n\n#### M的一些问题\nhttps://github.com/golang/go/issues/14592\n\n### P的一生\n#### P的创建\n`proc.go`\n```go\n// Change number of processors. The world is stopped, sched is locked.\n// gcworkbufs are not being modified by either the GC or\n// the write barrier code.\n// Returns list of Ps with local work, they need to be scheduled by the caller.\n// 所有的P都在这个函数分配，不管是最开始的初始化分配，还是后期调整\nfunc procresize(nprocs int32) *p {\n\told := gomaxprocs\n\t// 如果 gomaxprocs <=0 抛出异常\n\tif old < 0 || nprocs <= 0 {\n\t\tthrow(\"procresize: invalid arg\")\n\t}\n  ...\n\t// Grow allp if necessary.\n\tif nprocs > int32(len(allp)) {\n\t\t// Synchronize with retake, which could be running\n\t\t// concurrently since it doesn't run on a P.\n\t\tlock(&allpLock)\n\t\tif nprocs <= int32(cap(allp)) {\n\t\t\tallp = allp[:nprocs]\n\t\t} else {\n\t\t\t// 分配nprocs个*p\n\t\t\tnallp := make([]*p, nprocs)\n\t\t\t// Copy everything up to allp's cap so we\n\t\t\t// never lose old allocated Ps.\n\t\t\tcopy(nallp, allp[:cap(allp)])\n\t\t\tallp = nallp\n\t\t}\n\t\tunlock(&allpLock)\n\t}\n\n\t// initialize new P's\n\tfor i := int32(0); i < nprocs; i++ {\n\t\tpp := allp[i]\n\t\tif pp == nil {\n\t\t\tpp = new(p)\n\t\t\tpp.id = i\n\t\t\tpp.status = _Pgcstop            // 更改状态\n\t\t\tpp.sudogcache = pp.sudogbuf[:0] //将sudogcache指向sudogbuf的起始地址\n\t\t\tfor i := range pp.deferpool {\n\t\t\t\tpp.deferpool[i] = pp.deferpoolbuf[i][:0]\n\t\t\t}\n\t\t\tpp.wbBuf.reset()\n\t\t\t// 将pp保存到allp数组里, allp[i] = pp\n\t\t\tatomicstorep(unsafe.Pointer(&allp[i]), unsafe.Pointer(pp))\n\t\t}\n\t\t...\n\t}\n  ...\n\n\t_g_ := getg()\n\t// 如果当前的M已经绑定P，继续使用，否则将当前的M绑定一个P\n\tif _g_.m.p != 0 && _g_.m.p.ptr().id < nprocs {\n\t\t// continue to use the current P\n\t\t_g_.m.p.ptr().status = _Prunning\n\t} else {\n\t\t// release the current P and acquire allp[0]\n\t\t// 获取allp[0]\n\t\tif _g_.m.p != 0 {\n\t\t\t_g_.m.p.ptr().m = 0\n\t\t}\n\t\t_g_.m.p = 0\n\t\t_g_.m.mcache = nil\n\t\tp := allp[0]\n\t\tp.m = 0\n\t\tp.status = _Pidle\n\t\t// 将当前的m和p绑定\n\t\tacquirep(p)\n\t\tif trace.enabled {\n\t\t\ttraceGoStart()\n\t\t}\n\t}\n\tvar runnablePs *p\n\tfor i := nprocs - 1; i >= 0; i-- {\n\t\tp := allp[i]\n\t\tif _g_.m.p.ptr() == p {\n\t\t\tcontinue\n\t\t}\n\t\tp.status = _Pidle\n\t\tif runqempty(p) { // 将空闲p放入空闲链表\n\t\t\tpidleput(p)\n\t\t} else {\n\t\t\tp.m.set(mget())\n\t\t\tp.link.set(runnablePs)\n\t\t\trunnablePs = p\n\t\t}\n\t}\n\tstealOrder.reset(uint32(nprocs))\n\tvar int32p *int32 = &gomaxprocs // make compiler check that gomaxprocs is an int32\n\tatomic.Store((*uint32)(unsafe.Pointer(int32p)), uint32(nprocs))\n\treturn runnablePs\n}\n```\n所有的P在程序启动的时候就设置好了，并用一个allp slice维护，可以调用runtime.GOMAXPROCS调整P的个数，虽然代价很大\n#### 状态转换\n```\n                                            acquirep(p)        \n                          不需要使用的P       P和M绑定的时候       进入系统调用       procresize()\nnew(p)  -----+        +---------------+     +-----------+     +------------+    +----------+\n            |         |               |     |           |     |            |    |          |\n            |   +------------+    +---v--------+    +---v--------+    +----v-------+    +--v---------+\n            +-->|  _Pgcstop  |    |    _Pidle  |    |  _Prunning |    |  _Psyscall |    |   _Pdead   |\n                +------^-----+    +--------^---+    +--------^---+    +------------+    +------------+\n                       |            |     |            |     |            |\n                       +------------+     +------------+     +------------+\n                           GC结束            releasep()        退出系统调用\n                                            P和M解绑                      \n``` \nP的数量默认等于cpu的个数，很多人认为runtime.GOMAXPROCS可以限制系统线程的数量，但这是错误的，M是按需创建的，和runtime.GOMAXPROCS没有关系。\n### G的一生\n\n#### G的创建\n`proc.go`\n```go\n// Create a new g running fn with siz bytes of arguments.\n// Put it on the queue of g's waiting to run.\n// The compiler turns a go statement into a call to this.\n// Cannot split the stack because it assumes that the arguments\n// are available sequentially after &fn; they would not be\n// copied if a stack split occurred.\n//go:nosplit\n// 新建一个goroutine，\n// 􏳄 用fn + PtrSize 获取第一个参数的地址，也就是argp\n// 用siz - 8 获取pc地址\nfunc newproc(siz int32, fn *funcval) {\n\targp := add(unsafe.Pointer(&fn), sys.PtrSize)\n\tpc := getcallerpc()\n\t// 用g0的栈创建G对象\n\tsystemstack(func() {\n\t\tnewproc1(fn, (*uint8)(argp), siz, pc)\n\t})\n}\n```\n\n```go\n// Create a new g running fn with narg bytes of arguments starting\n// at argp. callerpc is the address of the go statement that created\n// this. The new g is put on the queue of g's waiting to run.\n// 根据函数参数和函数地址，创建一个新的G，然后将这个G加入队列等待运行\nfunc newproc1(fn *funcval, argp *uint8, narg int32, callerpc uintptr) {\n\t_g_ := getg()\n\n\tif fn == nil {\n\t\t_g_.m.throwing = -1 // do not dump full stacks\n\t\tthrow(\"go of nil func value\")\n\t}\n\t_g_.m.locks++ // disable preemption because it can be holding p in a local var\n\tsiz := narg\n\tsiz = (siz + 7) &^ 7\n\n\t// We could allocate a larger initial stack if necessary.\n\t// Not worth it: this is almost always an error.\n\t// 4*sizeof(uintreg): extra space added below\n\t// sizeof(uintreg): caller's LR (arm) or return address (x86, in gostartcall).\n\t// 如果函数的参数大小比2048大的话，直接panic\n\tif siz >= _StackMin-4*sys.RegSize-sys.RegSize {\n\t\tthrow(\"newproc: function arguments too large for new goroutine\")\n\t}\n\n\t// 从m中获取p\n\t_p_ := _g_.m.p.ptr()\n\t// 从gfree list获取g\n\tnewg := gfget(_p_)\n\t// 如果没获取到g，则新建一个\n\tif newg == nil {\n\t\tnewg = malg(_StackMin)\n\t\tcasgstatus(newg, _Gidle, _Gdead) //将g的状态改为_Gdead\n\t\t// 添加到allg数组，防止gc扫描清除掉\n\t\tallgadd(newg) // publishes with a g->status of Gdead so GC scanner doesn't look at uninitialized stack.\n\t}\n\tif newg.stack.hi == 0 {\n\t\tthrow(\"newproc1: newg missing stack\")\n\t}\n\n\tif readgstatus(newg) != _Gdead {\n\t\tthrow(\"newproc1: new g is not Gdead\")\n\t}\n\n\ttotalSize := 4*sys.RegSize + uintptr(siz) + sys.MinFrameSize // extra space in case of reads slightly beyond frame\n\ttotalSize += -totalSize & (sys.SpAlign - 1)                  // align to spAlign\n\tsp := newg.stack.hi - totalSize\n\tspArg := sp\n\tif usesLR {\n\t\t// caller's LR\n\t\t*(*uintptr)(unsafe.Pointer(sp)) = 0\n\t\tprepGoExitFrame(sp)\n\t\tspArg += sys.MinFrameSize\n\t}\n\tif narg > 0 {\n\t\t// copy参数\n\t\tmemmove(unsafe.Pointer(spArg), unsafe.Pointer(argp), uintptr(narg))\n\t\t// This is a stack-to-stack copy. If write barriers\n\t\t// are enabled and the source stack is grey (the\n\t\t// destination is always black), then perform a\n\t\t// barrier copy. We do this *after* the memmove\n\t\t// because the destination stack may have garbage on\n\t\t// it.\n\t\tif writeBarrier.needed && !_g_.m.curg.gcscandone {\n\t\t\tf := findfunc(fn.fn)\n\t\t\tstkmap := (*stackmap)(funcdata(f, _FUNCDATA_ArgsPointerMaps))\n\t\t\t// We're in the prologue, so it's always stack map index 0.\n\t\t\tbv := stackmapdata(stkmap, 0)\n\t\t\tbulkBarrierBitmap(spArg, spArg, uintptr(narg), 0, bv.bytedata)\n\t\t}\n\t}\n\n\tmemclrNoHeapPointers(unsafe.Pointer(&newg.sched), unsafe.Sizeof(newg.sched))\n\tnewg.sched.sp = sp\n\tnewg.stktopsp = sp\n\t// 保存goexit的地址到sched.pc\n\tnewg.sched.pc = funcPC(goexit) + sys.PCQuantum // +PCQuantum so that previous instruction is in same function\n\tnewg.sched.g = guintptr(unsafe.Pointer(newg))\n\tgostartcallfn(&newg.sched, fn)\n\tnewg.gopc = callerpc\n\tnewg.startpc = fn.fn\n\tif _g_.m.curg != nil {\n\t\tnewg.labels = _g_.m.curg.labels\n\t}\n\tif isSystemGoroutine(newg) {\n\t\tatomic.Xadd(&sched.ngsys, +1)\n\t}\n\tnewg.gcscanvalid = false\n\t// 更改当前g的状态为_Grunnable\n\tcasgstatus(newg, _Gdead, _Grunnable)\n\n\tif _p_.goidcache == _p_.goidcacheend {\n\t\t// Sched.goidgen is the last allocated id,\n\t\t// this batch must be [sched.goidgen+1, sched.goidgen+GoidCacheBatch].\n\t\t// At startup sched.goidgen=0, so main goroutine receives goid=1.\n\t\t_p_.goidcache = atomic.Xadd64(&sched.goidgen, _GoidCacheBatch)\n\t\t_p_.goidcache -= _GoidCacheBatch - 1\n\t\t_p_.goidcacheend = _p_.goidcache + _GoidCacheBatch\n\t}\n\t// 生成唯一的goid\n\tnewg.goid = int64(_p_.goidcache)\n\t_p_.goidcache++\n\tif raceenabled {\n\t\tnewg.racectx = racegostart(callerpc)\n\t}\n\tif trace.enabled {\n\t\ttraceGoCreate(newg, newg.startpc)\n\t}\n\t// 将当前新生成的g，放入队列\n\trunqput(_p_, newg, true)\n\n\t// 如果有空闲的p 且 m没有处于自旋状态 且 main goroutine已经启动，那么唤醒某个m来执行任务\n\tif atomic.Load(&sched.npidle) != 0 && atomic.Load(&sched.nmspinning) == 0 && mainStarted {\n\t\twakep()\n\t}\n\t_g_.m.locks--\n\tif _g_.m.locks == 0 && _g_.preempt { // restore the preemption request in case we've cleared it in newstack\n\t\t_g_.stackguard0 = stackPreempt\n\t}\n}\n```\n\n#### G的状态图\n```\n                                                      +------------+\n                                      ready           |            |\n                                  +------------------ |  _Gwaiting |\n                                  |                   |            |\n                                  |                   +------------+\n                                  |                         ^ park_m\n                                  V                         | \n  +------------+            +------------+  execute   +------------+            +------------+    \n  |            |  newproc   |            | ---------> |            |   goexit   |            |\n  |  _Gidle    | ---------> | _Grunnable |  yield     | _Grunning  | ---------> |   _Gdead   |      \n  |            |            |            | <--------- |            |            |            |\n  +------------+            +-----^------+            +------------+            +------------+\n                                  |         entersyscall |      ^ \n                                  |                      V      | existsyscall\n                                  |                   +------------+\n                                  |   existsyscall    |            |\n                                  +------------------ |  _Gsyscall |\n                                                      |            |\n                                                      +------------+\n\n```\n新建的G都是_Grunnable的，新建G的时候优先从gfree list从获取G，这样可以复用G，所以上图的状态不是完整的，_Gdead通过newproc会变为_Grunnable，\n通过go func()的语法新建的G，并不是直接运行，而是放入可运行的队列中，什么时候运行用于并不能决定，而是搞调度系统去自发的运行。\n\n\n","source":"_posts/Golang的调度模型概览.md","raw":"---\ntitle: Golang的调度模型概览\ndate: 2018-8-3 09:38:06\ntags: Go\n---\n\n调度的机制用一句话描述：  \nruntime准备好G,P,M，然后M绑定P，M从各种队列中获取G，切换到G的执行栈上并执行G上的任务函数，调用goexit做清理工作并回到M，如此反复。\n\n### 基本概念\n#### M（machine）\n* M代表着真正的执行计算资源，可以认为它就是os thread（系统线程）。\n* M是真正调度系统的执行者，每个M就像一个勤劳的工作者，总是从各种队列中找到可运行的G，而且这样M的可以同时存在多个。\n* M在绑定有效的P后，进入调度循环，而且M并不保留G状态，这是G可以跨M调度的基础。\n\n<!-- more -->\n\n#### P（processor）\n* P表示逻辑processor，是线程M的执行的上下文。\n* P的最大作用是其拥有的各种G对象队列、链表、cache和状态。\n\n#### G（goroutine）\n* 调度系统的最基本单位goroutine，存储了goroutine的执行stack信息、goroutine状态以及goroutine的任务函数等。\n* 在G的眼中只有P，P就是运行G的“CPU”。\n* 相当于两级线程\n\n#### 线程实现模型\n来自`Go并发编程实战`\n```\n                    +-------+       +-------+      \n                    |  KSE  |       |  KSE  |          \n                    +-------+       +-------+      \n                        |               |                       内核空间\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -        \n                        |               |                       用户空间\n                    +-------+       +-------+\n                    |   M   |       |   M   |\n                    +-------+       +-------+\n                  |          |         |          |\n              +------+   +------+   +------+   +------+            \n              |   P  |   |   P  |   |   P  |   |   P  |\n              +------+   +------+   +------+   +------+   \n           |     |     |     |     |     |     |     |     | \n         +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ \n         | G | | G | | G | | G | | G | | G | | G | | G | | G | \n         +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ \n```\n* KSE（Kernel Scheduling Entity）是内核调度实体           \n* M与P，P与G之前的关联都是动态的，可以变的\n\n### 关系示意图\n来自`golang源码剖析`\n```\n                            +-------------------- sysmon ---------------//------+ \n                            |                                                   |\n                            |                                                   |\n               +---+      +---+-------+                   +--------+          +---+---+\ngo func() ---> | G | ---> | P | local | <=== balance ===> | global | <--//--- | P | M |\n               +---+      +---+-------+                   +--------+          +---+---+\n                            |                                 |                 | \n                            |      +---+                      |                 |\n                            +----> | M | <--- findrunnable ---+--- steal <--//--+\n                                   +---+ \n                                     |\n                                   mstart\n                                     |\n              +--- execute <----- schedule \n              |                      |   \n              |                      |\n              +--> G.fn --> goexit --+ \n\n\n              1. go func() 语气创建G。\n              2. 将G放入P的本地队列（或者平衡到全局全局队列）。\n              3. 唤醒或新建M来执行任务。\n              4. 进入调度循环\n              5. 尽力获取可执行的G，并执行\n              6. 清理现场并且重新进入调度循环\n\n```\n\n\n## GPM的来由\n### 特殊的g0和m0\ng0和m0是在`proc.go`文件中的两个全局变量，m0就是进程启动后的初始线程，g0也是代表着初始线程的stack  \n`asm_amd64.go` --> runtime·rt0_go(SB)\n```go \n\t// 程序刚启动的时候必定有一个线程启动（主线程）\n\t// 将当前的栈和资源保存在g0\n\t// 将该线程保存在m0\n\t// tls: Thread Local Storage\n\t// set the per-goroutine and per-mach \"registers\"\n\tget_tls(BX)\n\tLEAQ\truntime·g0(SB), CX\n\tMOVQ\tCX, g(BX)\n\tLEAQ\truntime·m0(SB), AX\n\n\t// save m->g0 = g0\n\tMOVQ\tCX, m_g0(AX)\n\t// save m0 to g0->m\n\tMOVQ\tAX, g_m(CX)\n```\n\n\n\n### M的一生\n#### M的创建\n`proc.go`\n```go\n// Create a new m. It will start off with a call to fn, or else the scheduler.\n// fn needs to be static and not a heap allocated closure.\n// May run with m.p==nil, so write barriers are not allowed.\n//go:nowritebarrierrec\n// 创建一个新的m，它将从fn或者调度程序开始\nfunc newm(fn func(), _p_ *p) {\n\t// 根据fn和p和绑定一个m对象\n\tmp := allocm(_p_, fn)\n\t// 设置当前m的下一个p为_p_\n\tmp.nextp.set(_p_)\n\tmp.sigmask = initSigmask\n\t...\n\t// 真正的分配os thread\n\tnewm1(mp)\n}\n```\n\n```go\nfunc newm1(mp *m) {\n\t// 对cgo的处理\n\t...\n\texecLock.rlock() // Prevent process clone.\n\t// 创建一个系统线程\n\tnewosproc(mp, unsafe.Pointer(mp.g0.stack.hi))\n\texecLock.runlock()\n}\n```\n#### 状态\n``` \n       mstart\n          |\n          v        找不到可执行任务，gc STW，\n      +------+     任务执行时间过长，系统阻塞等   +------+\n      | spin | ----------------------------> |unspin| \n      +------+          mstop                +------+\n          ^                                      |\n          |                                      v\n      notewakeup <-------------------------  notesleep\n```\n\n#### M的一些问题\nhttps://github.com/golang/go/issues/14592\n\n### P的一生\n#### P的创建\n`proc.go`\n```go\n// Change number of processors. The world is stopped, sched is locked.\n// gcworkbufs are not being modified by either the GC or\n// the write barrier code.\n// Returns list of Ps with local work, they need to be scheduled by the caller.\n// 所有的P都在这个函数分配，不管是最开始的初始化分配，还是后期调整\nfunc procresize(nprocs int32) *p {\n\told := gomaxprocs\n\t// 如果 gomaxprocs <=0 抛出异常\n\tif old < 0 || nprocs <= 0 {\n\t\tthrow(\"procresize: invalid arg\")\n\t}\n  ...\n\t// Grow allp if necessary.\n\tif nprocs > int32(len(allp)) {\n\t\t// Synchronize with retake, which could be running\n\t\t// concurrently since it doesn't run on a P.\n\t\tlock(&allpLock)\n\t\tif nprocs <= int32(cap(allp)) {\n\t\t\tallp = allp[:nprocs]\n\t\t} else {\n\t\t\t// 分配nprocs个*p\n\t\t\tnallp := make([]*p, nprocs)\n\t\t\t// Copy everything up to allp's cap so we\n\t\t\t// never lose old allocated Ps.\n\t\t\tcopy(nallp, allp[:cap(allp)])\n\t\t\tallp = nallp\n\t\t}\n\t\tunlock(&allpLock)\n\t}\n\n\t// initialize new P's\n\tfor i := int32(0); i < nprocs; i++ {\n\t\tpp := allp[i]\n\t\tif pp == nil {\n\t\t\tpp = new(p)\n\t\t\tpp.id = i\n\t\t\tpp.status = _Pgcstop            // 更改状态\n\t\t\tpp.sudogcache = pp.sudogbuf[:0] //将sudogcache指向sudogbuf的起始地址\n\t\t\tfor i := range pp.deferpool {\n\t\t\t\tpp.deferpool[i] = pp.deferpoolbuf[i][:0]\n\t\t\t}\n\t\t\tpp.wbBuf.reset()\n\t\t\t// 将pp保存到allp数组里, allp[i] = pp\n\t\t\tatomicstorep(unsafe.Pointer(&allp[i]), unsafe.Pointer(pp))\n\t\t}\n\t\t...\n\t}\n  ...\n\n\t_g_ := getg()\n\t// 如果当前的M已经绑定P，继续使用，否则将当前的M绑定一个P\n\tif _g_.m.p != 0 && _g_.m.p.ptr().id < nprocs {\n\t\t// continue to use the current P\n\t\t_g_.m.p.ptr().status = _Prunning\n\t} else {\n\t\t// release the current P and acquire allp[0]\n\t\t// 获取allp[0]\n\t\tif _g_.m.p != 0 {\n\t\t\t_g_.m.p.ptr().m = 0\n\t\t}\n\t\t_g_.m.p = 0\n\t\t_g_.m.mcache = nil\n\t\tp := allp[0]\n\t\tp.m = 0\n\t\tp.status = _Pidle\n\t\t// 将当前的m和p绑定\n\t\tacquirep(p)\n\t\tif trace.enabled {\n\t\t\ttraceGoStart()\n\t\t}\n\t}\n\tvar runnablePs *p\n\tfor i := nprocs - 1; i >= 0; i-- {\n\t\tp := allp[i]\n\t\tif _g_.m.p.ptr() == p {\n\t\t\tcontinue\n\t\t}\n\t\tp.status = _Pidle\n\t\tif runqempty(p) { // 将空闲p放入空闲链表\n\t\t\tpidleput(p)\n\t\t} else {\n\t\t\tp.m.set(mget())\n\t\t\tp.link.set(runnablePs)\n\t\t\trunnablePs = p\n\t\t}\n\t}\n\tstealOrder.reset(uint32(nprocs))\n\tvar int32p *int32 = &gomaxprocs // make compiler check that gomaxprocs is an int32\n\tatomic.Store((*uint32)(unsafe.Pointer(int32p)), uint32(nprocs))\n\treturn runnablePs\n}\n```\n所有的P在程序启动的时候就设置好了，并用一个allp slice维护，可以调用runtime.GOMAXPROCS调整P的个数，虽然代价很大\n#### 状态转换\n```\n                                            acquirep(p)        \n                          不需要使用的P       P和M绑定的时候       进入系统调用       procresize()\nnew(p)  -----+        +---------------+     +-----------+     +------------+    +----------+\n            |         |               |     |           |     |            |    |          |\n            |   +------------+    +---v--------+    +---v--------+    +----v-------+    +--v---------+\n            +-->|  _Pgcstop  |    |    _Pidle  |    |  _Prunning |    |  _Psyscall |    |   _Pdead   |\n                +------^-----+    +--------^---+    +--------^---+    +------------+    +------------+\n                       |            |     |            |     |            |\n                       +------------+     +------------+     +------------+\n                           GC结束            releasep()        退出系统调用\n                                            P和M解绑                      \n``` \nP的数量默认等于cpu的个数，很多人认为runtime.GOMAXPROCS可以限制系统线程的数量，但这是错误的，M是按需创建的，和runtime.GOMAXPROCS没有关系。\n### G的一生\n\n#### G的创建\n`proc.go`\n```go\n// Create a new g running fn with siz bytes of arguments.\n// Put it on the queue of g's waiting to run.\n// The compiler turns a go statement into a call to this.\n// Cannot split the stack because it assumes that the arguments\n// are available sequentially after &fn; they would not be\n// copied if a stack split occurred.\n//go:nosplit\n// 新建一个goroutine，\n// 􏳄 用fn + PtrSize 获取第一个参数的地址，也就是argp\n// 用siz - 8 获取pc地址\nfunc newproc(siz int32, fn *funcval) {\n\targp := add(unsafe.Pointer(&fn), sys.PtrSize)\n\tpc := getcallerpc()\n\t// 用g0的栈创建G对象\n\tsystemstack(func() {\n\t\tnewproc1(fn, (*uint8)(argp), siz, pc)\n\t})\n}\n```\n\n```go\n// Create a new g running fn with narg bytes of arguments starting\n// at argp. callerpc is the address of the go statement that created\n// this. The new g is put on the queue of g's waiting to run.\n// 根据函数参数和函数地址，创建一个新的G，然后将这个G加入队列等待运行\nfunc newproc1(fn *funcval, argp *uint8, narg int32, callerpc uintptr) {\n\t_g_ := getg()\n\n\tif fn == nil {\n\t\t_g_.m.throwing = -1 // do not dump full stacks\n\t\tthrow(\"go of nil func value\")\n\t}\n\t_g_.m.locks++ // disable preemption because it can be holding p in a local var\n\tsiz := narg\n\tsiz = (siz + 7) &^ 7\n\n\t// We could allocate a larger initial stack if necessary.\n\t// Not worth it: this is almost always an error.\n\t// 4*sizeof(uintreg): extra space added below\n\t// sizeof(uintreg): caller's LR (arm) or return address (x86, in gostartcall).\n\t// 如果函数的参数大小比2048大的话，直接panic\n\tif siz >= _StackMin-4*sys.RegSize-sys.RegSize {\n\t\tthrow(\"newproc: function arguments too large for new goroutine\")\n\t}\n\n\t// 从m中获取p\n\t_p_ := _g_.m.p.ptr()\n\t// 从gfree list获取g\n\tnewg := gfget(_p_)\n\t// 如果没获取到g，则新建一个\n\tif newg == nil {\n\t\tnewg = malg(_StackMin)\n\t\tcasgstatus(newg, _Gidle, _Gdead) //将g的状态改为_Gdead\n\t\t// 添加到allg数组，防止gc扫描清除掉\n\t\tallgadd(newg) // publishes with a g->status of Gdead so GC scanner doesn't look at uninitialized stack.\n\t}\n\tif newg.stack.hi == 0 {\n\t\tthrow(\"newproc1: newg missing stack\")\n\t}\n\n\tif readgstatus(newg) != _Gdead {\n\t\tthrow(\"newproc1: new g is not Gdead\")\n\t}\n\n\ttotalSize := 4*sys.RegSize + uintptr(siz) + sys.MinFrameSize // extra space in case of reads slightly beyond frame\n\ttotalSize += -totalSize & (sys.SpAlign - 1)                  // align to spAlign\n\tsp := newg.stack.hi - totalSize\n\tspArg := sp\n\tif usesLR {\n\t\t// caller's LR\n\t\t*(*uintptr)(unsafe.Pointer(sp)) = 0\n\t\tprepGoExitFrame(sp)\n\t\tspArg += sys.MinFrameSize\n\t}\n\tif narg > 0 {\n\t\t// copy参数\n\t\tmemmove(unsafe.Pointer(spArg), unsafe.Pointer(argp), uintptr(narg))\n\t\t// This is a stack-to-stack copy. If write barriers\n\t\t// are enabled and the source stack is grey (the\n\t\t// destination is always black), then perform a\n\t\t// barrier copy. We do this *after* the memmove\n\t\t// because the destination stack may have garbage on\n\t\t// it.\n\t\tif writeBarrier.needed && !_g_.m.curg.gcscandone {\n\t\t\tf := findfunc(fn.fn)\n\t\t\tstkmap := (*stackmap)(funcdata(f, _FUNCDATA_ArgsPointerMaps))\n\t\t\t// We're in the prologue, so it's always stack map index 0.\n\t\t\tbv := stackmapdata(stkmap, 0)\n\t\t\tbulkBarrierBitmap(spArg, spArg, uintptr(narg), 0, bv.bytedata)\n\t\t}\n\t}\n\n\tmemclrNoHeapPointers(unsafe.Pointer(&newg.sched), unsafe.Sizeof(newg.sched))\n\tnewg.sched.sp = sp\n\tnewg.stktopsp = sp\n\t// 保存goexit的地址到sched.pc\n\tnewg.sched.pc = funcPC(goexit) + sys.PCQuantum // +PCQuantum so that previous instruction is in same function\n\tnewg.sched.g = guintptr(unsafe.Pointer(newg))\n\tgostartcallfn(&newg.sched, fn)\n\tnewg.gopc = callerpc\n\tnewg.startpc = fn.fn\n\tif _g_.m.curg != nil {\n\t\tnewg.labels = _g_.m.curg.labels\n\t}\n\tif isSystemGoroutine(newg) {\n\t\tatomic.Xadd(&sched.ngsys, +1)\n\t}\n\tnewg.gcscanvalid = false\n\t// 更改当前g的状态为_Grunnable\n\tcasgstatus(newg, _Gdead, _Grunnable)\n\n\tif _p_.goidcache == _p_.goidcacheend {\n\t\t// Sched.goidgen is the last allocated id,\n\t\t// this batch must be [sched.goidgen+1, sched.goidgen+GoidCacheBatch].\n\t\t// At startup sched.goidgen=0, so main goroutine receives goid=1.\n\t\t_p_.goidcache = atomic.Xadd64(&sched.goidgen, _GoidCacheBatch)\n\t\t_p_.goidcache -= _GoidCacheBatch - 1\n\t\t_p_.goidcacheend = _p_.goidcache + _GoidCacheBatch\n\t}\n\t// 生成唯一的goid\n\tnewg.goid = int64(_p_.goidcache)\n\t_p_.goidcache++\n\tif raceenabled {\n\t\tnewg.racectx = racegostart(callerpc)\n\t}\n\tif trace.enabled {\n\t\ttraceGoCreate(newg, newg.startpc)\n\t}\n\t// 将当前新生成的g，放入队列\n\trunqput(_p_, newg, true)\n\n\t// 如果有空闲的p 且 m没有处于自旋状态 且 main goroutine已经启动，那么唤醒某个m来执行任务\n\tif atomic.Load(&sched.npidle) != 0 && atomic.Load(&sched.nmspinning) == 0 && mainStarted {\n\t\twakep()\n\t}\n\t_g_.m.locks--\n\tif _g_.m.locks == 0 && _g_.preempt { // restore the preemption request in case we've cleared it in newstack\n\t\t_g_.stackguard0 = stackPreempt\n\t}\n}\n```\n\n#### G的状态图\n```\n                                                      +------------+\n                                      ready           |            |\n                                  +------------------ |  _Gwaiting |\n                                  |                   |            |\n                                  |                   +------------+\n                                  |                         ^ park_m\n                                  V                         | \n  +------------+            +------------+  execute   +------------+            +------------+    \n  |            |  newproc   |            | ---------> |            |   goexit   |            |\n  |  _Gidle    | ---------> | _Grunnable |  yield     | _Grunning  | ---------> |   _Gdead   |      \n  |            |            |            | <--------- |            |            |            |\n  +------------+            +-----^------+            +------------+            +------------+\n                                  |         entersyscall |      ^ \n                                  |                      V      | existsyscall\n                                  |                   +------------+\n                                  |   existsyscall    |            |\n                                  +------------------ |  _Gsyscall |\n                                                      |            |\n                                                      +------------+\n\n```\n新建的G都是_Grunnable的，新建G的时候优先从gfree list从获取G，这样可以复用G，所以上图的状态不是完整的，_Gdead通过newproc会变为_Grunnable，\n通过go func()的语法新建的G，并不是直接运行，而是放入可运行的队列中，什么时候运行用于并不能决定，而是搞调度系统去自发的运行。\n\n\n","slug":"Golang的调度模型概览","published":1,"updated":"2018-08-03T02:04:23.526Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlqdfcwn0009owv3anmmi3d5","content":"<p>调度的机制用一句话描述：<br>runtime准备好G,P,M，然后M绑定P，M从各种队列中获取G，切换到G的执行栈上并执行G上的任务函数，调用goexit做清理工作并回到M，如此反复。</p>\n<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><h4 id=\"M（machine）\"><a href=\"#M（machine）\" class=\"headerlink\" title=\"M（machine）\"></a>M（machine）</h4><ul>\n<li>M代表着真正的执行计算资源，可以认为它就是os thread（系统线程）。</li>\n<li>M是真正调度系统的执行者，每个M就像一个勤劳的工作者，总是从各种队列中找到可运行的G，而且这样M的可以同时存在多个。</li>\n<li>M在绑定有效的P后，进入调度循环，而且M并不保留G状态，这是G可以跨M调度的基础。</li>\n</ul>\n<a id=\"more\"></a>\n<h4 id=\"P（processor）\"><a href=\"#P（processor）\" class=\"headerlink\" title=\"P（processor）\"></a>P（processor）</h4><ul>\n<li>P表示逻辑processor，是线程M的执行的上下文。</li>\n<li>P的最大作用是其拥有的各种G对象队列、链表、cache和状态。</li>\n</ul>\n<h4 id=\"G（goroutine）\"><a href=\"#G（goroutine）\" class=\"headerlink\" title=\"G（goroutine）\"></a>G（goroutine）</h4><ul>\n<li>调度系统的最基本单位goroutine，存储了goroutine的执行stack信息、goroutine状态以及goroutine的任务函数等。</li>\n<li>在G的眼中只有P，P就是运行G的“CPU”。</li>\n<li>相当于两级线程</li>\n</ul>\n<h4 id=\"线程实现模型\"><a href=\"#线程实现模型\" class=\"headerlink\" title=\"线程实现模型\"></a>线程实现模型</h4><p>来自<code>Go并发编程实战</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">                    +-------+       +-------+      </span><br><span class=\"line\">                    |  KSE  |       |  KSE  |          </span><br><span class=\"line\">                    +-------+       +-------+      </span><br><span class=\"line\">                        |               |                       内核空间</span><br><span class=\"line\">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -        </span><br><span class=\"line\">                        |               |                       用户空间</span><br><span class=\"line\">                    +-------+       +-------+</span><br><span class=\"line\">                    |   M   |       |   M   |</span><br><span class=\"line\">                    +-------+       +-------+</span><br><span class=\"line\">                  |          |         |          |</span><br><span class=\"line\">              +------+   +------+   +------+   +------+            </span><br><span class=\"line\">              |   P  |   |   P  |   |   P  |   |   P  |</span><br><span class=\"line\">              +------+   +------+   +------+   +------+   </span><br><span class=\"line\">           |     |     |     |     |     |     |     |     | </span><br><span class=\"line\">         +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ </span><br><span class=\"line\">         | G | | G | | G | | G | | G | | G | | G | | G | | G | </span><br><span class=\"line\">         +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>KSE（Kernel Scheduling Entity）是内核调度实体           </li>\n<li>M与P，P与G之前的关联都是动态的，可以变的</li>\n</ul>\n<h3 id=\"关系示意图\"><a href=\"#关系示意图\" class=\"headerlink\" title=\"关系示意图\"></a>关系示意图</h3><p>来自<code>golang源码剖析</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">                            +-------------------- sysmon ---------------//------+ </span><br><span class=\"line\">                            |                                                   |</span><br><span class=\"line\">                            |                                                   |</span><br><span class=\"line\">               +---+      +---+-------+                   +--------+          +---+---+</span><br><span class=\"line\">go func() ---&gt; | G | ---&gt; | P | local | &lt;=== balance ===&gt; | global | &lt;--//--- | P | M |</span><br><span class=\"line\">               +---+      +---+-------+                   +--------+          +---+---+</span><br><span class=\"line\">                            |                                 |                 | </span><br><span class=\"line\">                            |      +---+                      |                 |</span><br><span class=\"line\">                            +----&gt; | M | &lt;--- findrunnable ---+--- steal &lt;--//--+</span><br><span class=\"line\">                                   +---+ </span><br><span class=\"line\">                                     |</span><br><span class=\"line\">                                   mstart</span><br><span class=\"line\">                                     |</span><br><span class=\"line\">              +--- execute &lt;----- schedule </span><br><span class=\"line\">              |                      |   </span><br><span class=\"line\">              |                      |</span><br><span class=\"line\">              +--&gt; G.fn --&gt; goexit --+ </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">              1. go func() 语气创建G。</span><br><span class=\"line\">              2. 将G放入P的本地队列（或者平衡到全局全局队列）。</span><br><span class=\"line\">              3. 唤醒或新建M来执行任务。</span><br><span class=\"line\">              4. 进入调度循环</span><br><span class=\"line\">              5. 尽力获取可执行的G，并执行</span><br><span class=\"line\">              6. 清理现场并且重新进入调度循环</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"GPM的来由\"><a href=\"#GPM的来由\" class=\"headerlink\" title=\"GPM的来由\"></a>GPM的来由</h2><h3 id=\"特殊的g0和m0\"><a href=\"#特殊的g0和m0\" class=\"headerlink\" title=\"特殊的g0和m0\"></a>特殊的g0和m0</h3><p>g0和m0是在<code>proc.go</code>文件中的两个全局变量，m0就是进程启动后的初始线程，g0也是代表着初始线程的stack<br><code>asm_amd64.go</code> –&gt; runtime·rt0_go(SB)<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 程序刚启动的时候必定有一个线程启动（主线程）</span></span><br><span class=\"line\"><span class=\"comment\">// 将当前的栈和资源保存在g0</span></span><br><span class=\"line\"><span class=\"comment\">// 将该线程保存在m0</span></span><br><span class=\"line\"><span class=\"comment\">// tls: Thread Local Storage</span></span><br><span class=\"line\"><span class=\"comment\">// set the per-goroutine and per-mach \"registers\"</span></span><br><span class=\"line\">get_tls(BX)</span><br><span class=\"line\">LEAQ\truntime·g0(SB), CX</span><br><span class=\"line\">MOVQ\tCX, g(BX)</span><br><span class=\"line\">LEAQ\truntime·m0(SB), AX</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// save m-&gt;g0 = g0</span></span><br><span class=\"line\">MOVQ\tCX, m_g0(AX)</span><br><span class=\"line\"><span class=\"comment\">// save m0 to g0-&gt;m</span></span><br><span class=\"line\">MOVQ\tAX, g_m(CX)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"M的一生\"><a href=\"#M的一生\" class=\"headerlink\" title=\"M的一生\"></a>M的一生</h3><h4 id=\"M的创建\"><a href=\"#M的创建\" class=\"headerlink\" title=\"M的创建\"></a>M的创建</h4><p><code>proc.go</code><br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Create a new m. It will start off with a call to fn, or else the scheduler.</span></span><br><span class=\"line\"><span class=\"comment\">// fn needs to be static and not a heap allocated closure.</span></span><br><span class=\"line\"><span class=\"comment\">// May run with m.p==nil, so write barriers are not allowed.</span></span><br><span class=\"line\"><span class=\"comment\">//go:nowritebarrierrec</span></span><br><span class=\"line\"><span class=\"comment\">// 创建一个新的m，它将从fn或者调度程序开始</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">newm</span><span class=\"params\">(fn <span class=\"keyword\">func</span>()</span>, _<span class=\"title\">p_</span> *<span class=\"title\">p</span>)</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 根据fn和p和绑定一个m对象</span></span><br><span class=\"line\">\tmp := allocm(_p_, fn)</span><br><span class=\"line\">\t<span class=\"comment\">// 设置当前m的下一个p为_p_</span></span><br><span class=\"line\">\tmp.nextp.set(_p_)</span><br><span class=\"line\">\tmp.sigmask = initSigmask</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t<span class=\"comment\">// 真正的分配os thread</span></span><br><span class=\"line\">\tnewm1(mp)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">newm1</span><span class=\"params\">(mp *m)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 对cgo的处理</span></span><br><span class=\"line\">\t...</span><br><span class=\"line\">\texecLock.rlock() <span class=\"comment\">// Prevent process clone.</span></span><br><span class=\"line\">\t<span class=\"comment\">// 创建一个系统线程</span></span><br><span class=\"line\">\tnewosproc(mp, unsafe.Pointer(mp.g0.stack.hi))</span><br><span class=\"line\">\texecLock.runlock()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"状态\"><a href=\"#状态\" class=\"headerlink\" title=\"状态\"></a>状态</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> mstart</span><br><span class=\"line\">    |</span><br><span class=\"line\">    v        找不到可执行任务，gc STW，</span><br><span class=\"line\">+------+     任务执行时间过长，系统阻塞等   +------+</span><br><span class=\"line\">| spin | ----------------------------&gt; |unspin| </span><br><span class=\"line\">+------+          mstop                +------+</span><br><span class=\"line\">    ^                                      |</span><br><span class=\"line\">    |                                      v</span><br><span class=\"line\">notewakeup &lt;-------------------------  notesleep</span><br></pre></td></tr></table></figure>\n<h4 id=\"M的一些问题\"><a href=\"#M的一些问题\" class=\"headerlink\" title=\"M的一些问题\"></a>M的一些问题</h4><p><a href=\"https://github.com/golang/go/issues/14592\" target=\"_blank\" rel=\"noopener\">https://github.com/golang/go/issues/14592</a></p>\n<h3 id=\"P的一生\"><a href=\"#P的一生\" class=\"headerlink\" title=\"P的一生\"></a>P的一生</h3><h4 id=\"P的创建\"><a href=\"#P的创建\" class=\"headerlink\" title=\"P的创建\"></a>P的创建</h4><p><code>proc.go</code><br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Change number of processors. The world is stopped, sched is locked.</span></span><br><span class=\"line\"><span class=\"comment\">// gcworkbufs are not being modified by either the GC or</span></span><br><span class=\"line\"><span class=\"comment\">// the write barrier code.</span></span><br><span class=\"line\"><span class=\"comment\">// Returns list of Ps with local work, they need to be scheduled by the caller.</span></span><br><span class=\"line\"><span class=\"comment\">// 所有的P都在这个函数分配，不管是最开始的初始化分配，还是后期调整</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">procresize</span><span class=\"params\">(nprocs <span class=\"keyword\">int32</span>)</span> *<span class=\"title\">p</span></span> &#123;</span><br><span class=\"line\">\told := gomaxprocs</span><br><span class=\"line\">\t<span class=\"comment\">// 如果 gomaxprocs &lt;=0 抛出异常</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> old &lt; <span class=\"number\">0</span> || nprocs &lt;= <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tthrow(<span class=\"string\">\"procresize: invalid arg\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">\t<span class=\"comment\">// Grow allp if necessary.</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> nprocs &gt; <span class=\"keyword\">int32</span>(<span class=\"built_in\">len</span>(allp)) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// Synchronize with retake, which could be running</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// concurrently since it doesn't run on a P.</span></span><br><span class=\"line\">\t\tlock(&amp;allpLock)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> nprocs &lt;= <span class=\"keyword\">int32</span>(<span class=\"built_in\">cap</span>(allp)) &#123;</span><br><span class=\"line\">\t\t\tallp = allp[:nprocs]</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 分配nprocs个*p</span></span><br><span class=\"line\">\t\t\tnallp := <span class=\"built_in\">make</span>([]*p, nprocs)</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// Copy everything up to allp's cap so we</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// never lose old allocated Ps.</span></span><br><span class=\"line\">\t\t\t<span class=\"built_in\">copy</span>(nallp, allp[:<span class=\"built_in\">cap</span>(allp)])</span><br><span class=\"line\">\t\t\tallp = nallp</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tunlock(&amp;allpLock)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// initialize new P's</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"keyword\">int32</span>(<span class=\"number\">0</span>); i &lt; nprocs; i++ &#123;</span><br><span class=\"line\">\t\tpp := allp[i]</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> pp == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tpp = <span class=\"built_in\">new</span>(p)</span><br><span class=\"line\">\t\t\tpp.id = i</span><br><span class=\"line\">\t\t\tpp.status = _Pgcstop            <span class=\"comment\">// 更改状态</span></span><br><span class=\"line\">\t\t\tpp.sudogcache = pp.sudogbuf[:<span class=\"number\">0</span>] <span class=\"comment\">//将sudogcache指向sudogbuf的起始地址</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> pp.deferpool &#123;</span><br><span class=\"line\">\t\t\t\tpp.deferpool[i] = pp.deferpoolbuf[i][:<span class=\"number\">0</span>]</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tpp.wbBuf.reset()</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 将pp保存到allp数组里, allp[i] = pp</span></span><br><span class=\"line\">\t\t\tatomicstorep(unsafe.Pointer(&amp;allp[i]), unsafe.Pointer(pp))</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  ...</span><br><span class=\"line\"></span><br><span class=\"line\">\t_g_ := getg()</span><br><span class=\"line\">\t<span class=\"comment\">// 如果当前的M已经绑定P，继续使用，否则将当前的M绑定一个P</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> _g_.m.p != <span class=\"number\">0</span> &amp;&amp; _g_.m.p.ptr().id &lt; nprocs &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// continue to use the current P</span></span><br><span class=\"line\">\t\t_g_.m.p.ptr().status = _Prunning</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// release the current P and acquire allp[0]</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 获取allp[0]</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> _g_.m.p != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t_g_.m.p.ptr().m = <span class=\"number\">0</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t_g_.m.p = <span class=\"number\">0</span></span><br><span class=\"line\">\t\t_g_.m.mcache = <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\tp := allp[<span class=\"number\">0</span>]</span><br><span class=\"line\">\t\tp.m = <span class=\"number\">0</span></span><br><span class=\"line\">\t\tp.status = _Pidle</span><br><span class=\"line\">\t\t<span class=\"comment\">// 将当前的m和p绑定</span></span><br><span class=\"line\">\t\tacquirep(p)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> trace.enabled &#123;</span><br><span class=\"line\">\t\t\ttraceGoStart()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> runnablePs *p</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := nprocs - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i-- &#123;</span><br><span class=\"line\">\t\tp := allp[i]</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> _g_.m.p.ptr() == p &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tp.status = _Pidle</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> runqempty(p) &#123; <span class=\"comment\">// 将空闲p放入空闲链表</span></span><br><span class=\"line\">\t\t\tpidleput(p)</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tp.m.set(mget())</span><br><span class=\"line\">\t\t\tp.link.set(runnablePs)</span><br><span class=\"line\">\t\t\trunnablePs = p</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tstealOrder.reset(<span class=\"keyword\">uint32</span>(nprocs))</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> int32p *<span class=\"keyword\">int32</span> = &amp;gomaxprocs <span class=\"comment\">// make compiler check that gomaxprocs is an int32</span></span><br><span class=\"line\">\tatomic.Store((*<span class=\"keyword\">uint32</span>)(unsafe.Pointer(int32p)), <span class=\"keyword\">uint32</span>(nprocs))</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> runnablePs</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>所有的P在程序启动的时候就设置好了，并用一个allp slice维护，可以调用runtime.GOMAXPROCS调整P的个数，虽然代价很大</p>\n<h4 id=\"状态转换\"><a href=\"#状态转换\" class=\"headerlink\" title=\"状态转换\"></a>状态转换</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">                                            acquirep(p)        </span><br><span class=\"line\">                          不需要使用的P       P和M绑定的时候       进入系统调用       procresize()</span><br><span class=\"line\">new(p)  -----+        +---------------+     +-----------+     +------------+    +----------+</span><br><span class=\"line\">            |         |               |     |           |     |            |    |          |</span><br><span class=\"line\">            |   +------------+    +---v--------+    +---v--------+    +----v-------+    +--v---------+</span><br><span class=\"line\">            +--&gt;|  _Pgcstop  |    |    _Pidle  |    |  _Prunning |    |  _Psyscall |    |   _Pdead   |</span><br><span class=\"line\">                +------^-----+    +--------^---+    +--------^---+    +------------+    +------------+</span><br><span class=\"line\">                       |            |     |            |     |            |</span><br><span class=\"line\">                       +------------+     +------------+     +------------+</span><br><span class=\"line\">                           GC结束            releasep()        退出系统调用</span><br><span class=\"line\">                                            P和M解绑                      </span><br><span class=\"line\">``` </span><br><span class=\"line\">P的数量默认等于cpu的个数，很多人认为runtime.GOMAXPROCS可以限制系统线程的数量，但这是错误的，M是按需创建的，和runtime.GOMAXPROCS没有关系。</span><br><span class=\"line\">### G的一生</span><br><span class=\"line\"></span><br><span class=\"line\">#### G的创建</span><br><span class=\"line\">`proc.go`</span><br><span class=\"line\">```go</span><br><span class=\"line\">// Create a new g running fn with siz bytes of arguments.</span><br><span class=\"line\">// Put it on the queue of g&apos;s waiting to run.</span><br><span class=\"line\">// The compiler turns a go statement into a call to this.</span><br><span class=\"line\">// Cannot split the stack because it assumes that the arguments</span><br><span class=\"line\">// are available sequentially after &amp;fn; they would not be</span><br><span class=\"line\">// copied if a stack split occurred.</span><br><span class=\"line\">//go:nosplit</span><br><span class=\"line\">// 新建一个goroutine，</span><br><span class=\"line\">// 􏳄 用fn + PtrSize 获取第一个参数的地址，也就是argp</span><br><span class=\"line\">// 用siz - 8 获取pc地址</span><br><span class=\"line\">func newproc(siz int32, fn *funcval) &#123;</span><br><span class=\"line\">\targp := add(unsafe.Pointer(&amp;fn), sys.PtrSize)</span><br><span class=\"line\">\tpc := getcallerpc()</span><br><span class=\"line\">\t// 用g0的栈创建G对象</span><br><span class=\"line\">\tsystemstack(func() &#123;</span><br><span class=\"line\">\t\tnewproc1(fn, (*uint8)(argp), siz, pc)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Create a new g running fn with narg bytes of arguments starting</span></span><br><span class=\"line\"><span class=\"comment\">// at argp. callerpc is the address of the go statement that created</span></span><br><span class=\"line\"><span class=\"comment\">// this. The new g is put on the queue of g's waiting to run.</span></span><br><span class=\"line\"><span class=\"comment\">// 根据函数参数和函数地址，创建一个新的G，然后将这个G加入队列等待运行</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">newproc1</span><span class=\"params\">(fn *funcval, argp *<span class=\"keyword\">uint8</span>, narg <span class=\"keyword\">int32</span>, callerpc <span class=\"keyword\">uintptr</span>)</span></span> &#123;</span><br><span class=\"line\">\t_g_ := getg()</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> fn == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t_g_.m.throwing = <span class=\"number\">-1</span> <span class=\"comment\">// do not dump full stacks</span></span><br><span class=\"line\">\t\tthrow(<span class=\"string\">\"go of nil func value\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t_g_.m.locks++ <span class=\"comment\">// disable preemption because it can be holding p in a local var</span></span><br><span class=\"line\">\tsiz := narg</span><br><span class=\"line\">\tsiz = (siz + <span class=\"number\">7</span>) &amp;^ <span class=\"number\">7</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// We could allocate a larger initial stack if necessary.</span></span><br><span class=\"line\">\t<span class=\"comment\">// Not worth it: this is almost always an error.</span></span><br><span class=\"line\">\t<span class=\"comment\">// 4*sizeof(uintreg): extra space added below</span></span><br><span class=\"line\">\t<span class=\"comment\">// sizeof(uintreg): caller's LR (arm) or return address (x86, in gostartcall).</span></span><br><span class=\"line\">\t<span class=\"comment\">// 如果函数的参数大小比2048大的话，直接panic</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> siz &gt;= _StackMin<span class=\"number\">-4</span>*sys.RegSize-sys.RegSize &#123;</span><br><span class=\"line\">\t\tthrow(<span class=\"string\">\"newproc: function arguments too large for new goroutine\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 从m中获取p</span></span><br><span class=\"line\">\t_p_ := _g_.m.p.ptr()</span><br><span class=\"line\">\t<span class=\"comment\">// 从gfree list获取g</span></span><br><span class=\"line\">\tnewg := gfget(_p_)</span><br><span class=\"line\">\t<span class=\"comment\">// 如果没获取到g，则新建一个</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> newg == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tnewg = malg(_StackMin)</span><br><span class=\"line\">\t\tcasgstatus(newg, _Gidle, _Gdead) <span class=\"comment\">//将g的状态改为_Gdead</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 添加到allg数组，防止gc扫描清除掉</span></span><br><span class=\"line\">\t\tallgadd(newg) <span class=\"comment\">// publishes with a g-&gt;status of Gdead so GC scanner doesn't look at uninitialized stack.</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> newg.stack.hi == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tthrow(<span class=\"string\">\"newproc1: newg missing stack\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> readgstatus(newg) != _Gdead &#123;</span><br><span class=\"line\">\t\tthrow(<span class=\"string\">\"newproc1: new g is not Gdead\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\ttotalSize := <span class=\"number\">4</span>*sys.RegSize + <span class=\"keyword\">uintptr</span>(siz) + sys.MinFrameSize <span class=\"comment\">// extra space in case of reads slightly beyond frame</span></span><br><span class=\"line\">\ttotalSize += -totalSize &amp; (sys.SpAlign - <span class=\"number\">1</span>)                  <span class=\"comment\">// align to spAlign</span></span><br><span class=\"line\">\tsp := newg.stack.hi - totalSize</span><br><span class=\"line\">\tspArg := sp</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> usesLR &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// caller's LR</span></span><br><span class=\"line\">\t\t*(*<span class=\"keyword\">uintptr</span>)(unsafe.Pointer(sp)) = <span class=\"number\">0</span></span><br><span class=\"line\">\t\tprepGoExitFrame(sp)</span><br><span class=\"line\">\t\tspArg += sys.MinFrameSize</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> narg &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// copy参数</span></span><br><span class=\"line\">\t\tmemmove(unsafe.Pointer(spArg), unsafe.Pointer(argp), <span class=\"keyword\">uintptr</span>(narg))</span><br><span class=\"line\">\t\t<span class=\"comment\">// This is a stack-to-stack copy. If write barriers</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// are enabled and the source stack is grey (the</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// destination is always black), then perform a</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// barrier copy. We do this *after* the memmove</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// because the destination stack may have garbage on</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// it.</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> writeBarrier.needed &amp;&amp; !_g_.m.curg.gcscandone &#123;</span><br><span class=\"line\">\t\t\tf := findfunc(fn.fn)</span><br><span class=\"line\">\t\t\tstkmap := (*stackmap)(funcdata(f, _FUNCDATA_ArgsPointerMaps))</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// We're in the prologue, so it's always stack map index 0.</span></span><br><span class=\"line\">\t\t\tbv := stackmapdata(stkmap, <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\tbulkBarrierBitmap(spArg, spArg, <span class=\"keyword\">uintptr</span>(narg), <span class=\"number\">0</span>, bv.bytedata)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tmemclrNoHeapPointers(unsafe.Pointer(&amp;newg.sched), unsafe.Sizeof(newg.sched))</span><br><span class=\"line\">\tnewg.sched.sp = sp</span><br><span class=\"line\">\tnewg.stktopsp = sp</span><br><span class=\"line\">\t<span class=\"comment\">// 保存goexit的地址到sched.pc</span></span><br><span class=\"line\">\tnewg.sched.pc = funcPC(goexit) + sys.PCQuantum <span class=\"comment\">// +PCQuantum so that previous instruction is in same function</span></span><br><span class=\"line\">\tnewg.sched.g = guintptr(unsafe.Pointer(newg))</span><br><span class=\"line\">\tgostartcallfn(&amp;newg.sched, fn)</span><br><span class=\"line\">\tnewg.gopc = callerpc</span><br><span class=\"line\">\tnewg.startpc = fn.fn</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> _g_.m.curg != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tnewg.labels = _g_.m.curg.labels</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> isSystemGoroutine(newg) &#123;</span><br><span class=\"line\">\t\tatomic.Xadd(&amp;sched.ngsys, +<span class=\"number\">1</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tnewg.gcscanvalid = <span class=\"literal\">false</span></span><br><span class=\"line\">\t<span class=\"comment\">// 更改当前g的状态为_Grunnable</span></span><br><span class=\"line\">\tcasgstatus(newg, _Gdead, _Grunnable)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> _p_.goidcache == _p_.goidcacheend &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// Sched.goidgen is the last allocated id,</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// this batch must be [sched.goidgen+1, sched.goidgen+GoidCacheBatch].</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// At startup sched.goidgen=0, so main goroutine receives goid=1.</span></span><br><span class=\"line\">\t\t_p_.goidcache = atomic.Xadd64(&amp;sched.goidgen, _GoidCacheBatch)</span><br><span class=\"line\">\t\t_p_.goidcache -= _GoidCacheBatch - <span class=\"number\">1</span></span><br><span class=\"line\">\t\t_p_.goidcacheend = _p_.goidcache + _GoidCacheBatch</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 生成唯一的goid</span></span><br><span class=\"line\">\tnewg.goid = <span class=\"keyword\">int64</span>(_p_.goidcache)</span><br><span class=\"line\">\t_p_.goidcache++</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> raceenabled &#123;</span><br><span class=\"line\">\t\tnewg.racectx = racegostart(callerpc)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> trace.enabled &#123;</span><br><span class=\"line\">\t\ttraceGoCreate(newg, newg.startpc)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 将当前新生成的g，放入队列</span></span><br><span class=\"line\">\trunqput(_p_, newg, <span class=\"literal\">true</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 如果有空闲的p 且 m没有处于自旋状态 且 main goroutine已经启动，那么唤醒某个m来执行任务</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> atomic.Load(&amp;sched.npidle) != <span class=\"number\">0</span> &amp;&amp; atomic.Load(&amp;sched.nmspinning) == <span class=\"number\">0</span> &amp;&amp; mainStarted &#123;</span><br><span class=\"line\">\t\twakep()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t_g_.m.locks--</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> _g_.m.locks == <span class=\"number\">0</span> &amp;&amp; _g_.preempt &#123; <span class=\"comment\">// restore the preemption request in case we've cleared it in newstack</span></span><br><span class=\"line\">\t\t_g_.stackguard0 = stackPreempt</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"G的状态图\"><a href=\"#G的状态图\" class=\"headerlink\" title=\"G的状态图\"></a>G的状态图</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">                                                    +------------+</span><br><span class=\"line\">                                    ready           |            |</span><br><span class=\"line\">                                +------------------ |  _Gwaiting |</span><br><span class=\"line\">                                |                   |            |</span><br><span class=\"line\">                                |                   +------------+</span><br><span class=\"line\">                                |                         ^ park_m</span><br><span class=\"line\">                                V                         | </span><br><span class=\"line\">+------------+            +------------+  execute   +------------+            +------------+    </span><br><span class=\"line\">|            |  newproc   |            | ---------&gt; |            |   goexit   |            |</span><br><span class=\"line\">|  _Gidle    | ---------&gt; | _Grunnable |  yield     | _Grunning  | ---------&gt; |   _Gdead   |      </span><br><span class=\"line\">|            |            |            | &lt;--------- |            |            |            |</span><br><span class=\"line\">+------------+            +-----^------+            +------------+            +------------+</span><br><span class=\"line\">                                |         entersyscall |      ^ </span><br><span class=\"line\">                                |                      V      | existsyscall</span><br><span class=\"line\">                                |                   +------------+</span><br><span class=\"line\">                                |   existsyscall    |            |</span><br><span class=\"line\">                                +------------------ |  _Gsyscall |</span><br><span class=\"line\">                                                    |            |</span><br><span class=\"line\">                                                    +------------+</span><br></pre></td></tr></table></figure>\n<p>新建的G都是_Grunnable的，新建G的时候优先从gfree list从获取G，这样可以复用G，所以上图的状态不是完整的，_Gdead通过newproc会变为_Grunnable，<br>通过go func()的语法新建的G，并不是直接运行，而是放入可运行的队列中，什么时候运行用于并不能决定，而是搞调度系统去自发的运行。</p>\n","site":{"data":{}},"excerpt":"<p>调度的机制用一句话描述：<br>runtime准备好G,P,M，然后M绑定P，M从各种队列中获取G，切换到G的执行栈上并执行G上的任务函数，调用goexit做清理工作并回到M，如此反复。</p>\n<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><h4 id=\"M（machine）\"><a href=\"#M（machine）\" class=\"headerlink\" title=\"M（machine）\"></a>M（machine）</h4><ul>\n<li>M代表着真正的执行计算资源，可以认为它就是os thread（系统线程）。</li>\n<li>M是真正调度系统的执行者，每个M就像一个勤劳的工作者，总是从各种队列中找到可运行的G，而且这样M的可以同时存在多个。</li>\n<li>M在绑定有效的P后，进入调度循环，而且M并不保留G状态，这是G可以跨M调度的基础。</li>\n</ul>","more":"<h4 id=\"P（processor）\"><a href=\"#P（processor）\" class=\"headerlink\" title=\"P（processor）\"></a>P（processor）</h4><ul>\n<li>P表示逻辑processor，是线程M的执行的上下文。</li>\n<li>P的最大作用是其拥有的各种G对象队列、链表、cache和状态。</li>\n</ul>\n<h4 id=\"G（goroutine）\"><a href=\"#G（goroutine）\" class=\"headerlink\" title=\"G（goroutine）\"></a>G（goroutine）</h4><ul>\n<li>调度系统的最基本单位goroutine，存储了goroutine的执行stack信息、goroutine状态以及goroutine的任务函数等。</li>\n<li>在G的眼中只有P，P就是运行G的“CPU”。</li>\n<li>相当于两级线程</li>\n</ul>\n<h4 id=\"线程实现模型\"><a href=\"#线程实现模型\" class=\"headerlink\" title=\"线程实现模型\"></a>线程实现模型</h4><p>来自<code>Go并发编程实战</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">                    +-------+       +-------+      </span><br><span class=\"line\">                    |  KSE  |       |  KSE  |          </span><br><span class=\"line\">                    +-------+       +-------+      </span><br><span class=\"line\">                        |               |                       内核空间</span><br><span class=\"line\">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -        </span><br><span class=\"line\">                        |               |                       用户空间</span><br><span class=\"line\">                    +-------+       +-------+</span><br><span class=\"line\">                    |   M   |       |   M   |</span><br><span class=\"line\">                    +-------+       +-------+</span><br><span class=\"line\">                  |          |         |          |</span><br><span class=\"line\">              +------+   +------+   +------+   +------+            </span><br><span class=\"line\">              |   P  |   |   P  |   |   P  |   |   P  |</span><br><span class=\"line\">              +------+   +------+   +------+   +------+   </span><br><span class=\"line\">           |     |     |     |     |     |     |     |     | </span><br><span class=\"line\">         +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ </span><br><span class=\"line\">         | G | | G | | G | | G | | G | | G | | G | | G | | G | </span><br><span class=\"line\">         +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>KSE（Kernel Scheduling Entity）是内核调度实体           </li>\n<li>M与P，P与G之前的关联都是动态的，可以变的</li>\n</ul>\n<h3 id=\"关系示意图\"><a href=\"#关系示意图\" class=\"headerlink\" title=\"关系示意图\"></a>关系示意图</h3><p>来自<code>golang源码剖析</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">                            +-------------------- sysmon ---------------//------+ </span><br><span class=\"line\">                            |                                                   |</span><br><span class=\"line\">                            |                                                   |</span><br><span class=\"line\">               +---+      +---+-------+                   +--------+          +---+---+</span><br><span class=\"line\">go func() ---&gt; | G | ---&gt; | P | local | &lt;=== balance ===&gt; | global | &lt;--//--- | P | M |</span><br><span class=\"line\">               +---+      +---+-------+                   +--------+          +---+---+</span><br><span class=\"line\">                            |                                 |                 | </span><br><span class=\"line\">                            |      +---+                      |                 |</span><br><span class=\"line\">                            +----&gt; | M | &lt;--- findrunnable ---+--- steal &lt;--//--+</span><br><span class=\"line\">                                   +---+ </span><br><span class=\"line\">                                     |</span><br><span class=\"line\">                                   mstart</span><br><span class=\"line\">                                     |</span><br><span class=\"line\">              +--- execute &lt;----- schedule </span><br><span class=\"line\">              |                      |   </span><br><span class=\"line\">              |                      |</span><br><span class=\"line\">              +--&gt; G.fn --&gt; goexit --+ </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">              1. go func() 语气创建G。</span><br><span class=\"line\">              2. 将G放入P的本地队列（或者平衡到全局全局队列）。</span><br><span class=\"line\">              3. 唤醒或新建M来执行任务。</span><br><span class=\"line\">              4. 进入调度循环</span><br><span class=\"line\">              5. 尽力获取可执行的G，并执行</span><br><span class=\"line\">              6. 清理现场并且重新进入调度循环</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"GPM的来由\"><a href=\"#GPM的来由\" class=\"headerlink\" title=\"GPM的来由\"></a>GPM的来由</h2><h3 id=\"特殊的g0和m0\"><a href=\"#特殊的g0和m0\" class=\"headerlink\" title=\"特殊的g0和m0\"></a>特殊的g0和m0</h3><p>g0和m0是在<code>proc.go</code>文件中的两个全局变量，m0就是进程启动后的初始线程，g0也是代表着初始线程的stack<br><code>asm_amd64.go</code> –&gt; runtime·rt0_go(SB)<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 程序刚启动的时候必定有一个线程启动（主线程）</span></span><br><span class=\"line\"><span class=\"comment\">// 将当前的栈和资源保存在g0</span></span><br><span class=\"line\"><span class=\"comment\">// 将该线程保存在m0</span></span><br><span class=\"line\"><span class=\"comment\">// tls: Thread Local Storage</span></span><br><span class=\"line\"><span class=\"comment\">// set the per-goroutine and per-mach \"registers\"</span></span><br><span class=\"line\">get_tls(BX)</span><br><span class=\"line\">LEAQ\truntime·g0(SB), CX</span><br><span class=\"line\">MOVQ\tCX, g(BX)</span><br><span class=\"line\">LEAQ\truntime·m0(SB), AX</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// save m-&gt;g0 = g0</span></span><br><span class=\"line\">MOVQ\tCX, m_g0(AX)</span><br><span class=\"line\"><span class=\"comment\">// save m0 to g0-&gt;m</span></span><br><span class=\"line\">MOVQ\tAX, g_m(CX)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"M的一生\"><a href=\"#M的一生\" class=\"headerlink\" title=\"M的一生\"></a>M的一生</h3><h4 id=\"M的创建\"><a href=\"#M的创建\" class=\"headerlink\" title=\"M的创建\"></a>M的创建</h4><p><code>proc.go</code><br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Create a new m. It will start off with a call to fn, or else the scheduler.</span></span><br><span class=\"line\"><span class=\"comment\">// fn needs to be static and not a heap allocated closure.</span></span><br><span class=\"line\"><span class=\"comment\">// May run with m.p==nil, so write barriers are not allowed.</span></span><br><span class=\"line\"><span class=\"comment\">//go:nowritebarrierrec</span></span><br><span class=\"line\"><span class=\"comment\">// 创建一个新的m，它将从fn或者调度程序开始</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">newm</span><span class=\"params\">(fn <span class=\"keyword\">func</span>()</span>, _<span class=\"title\">p_</span> *<span class=\"title\">p</span>)</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 根据fn和p和绑定一个m对象</span></span><br><span class=\"line\">\tmp := allocm(_p_, fn)</span><br><span class=\"line\">\t<span class=\"comment\">// 设置当前m的下一个p为_p_</span></span><br><span class=\"line\">\tmp.nextp.set(_p_)</span><br><span class=\"line\">\tmp.sigmask = initSigmask</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t<span class=\"comment\">// 真正的分配os thread</span></span><br><span class=\"line\">\tnewm1(mp)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">newm1</span><span class=\"params\">(mp *m)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 对cgo的处理</span></span><br><span class=\"line\">\t...</span><br><span class=\"line\">\texecLock.rlock() <span class=\"comment\">// Prevent process clone.</span></span><br><span class=\"line\">\t<span class=\"comment\">// 创建一个系统线程</span></span><br><span class=\"line\">\tnewosproc(mp, unsafe.Pointer(mp.g0.stack.hi))</span><br><span class=\"line\">\texecLock.runlock()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"状态\"><a href=\"#状态\" class=\"headerlink\" title=\"状态\"></a>状态</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> mstart</span><br><span class=\"line\">    |</span><br><span class=\"line\">    v        找不到可执行任务，gc STW，</span><br><span class=\"line\">+------+     任务执行时间过长，系统阻塞等   +------+</span><br><span class=\"line\">| spin | ----------------------------&gt; |unspin| </span><br><span class=\"line\">+------+          mstop                +------+</span><br><span class=\"line\">    ^                                      |</span><br><span class=\"line\">    |                                      v</span><br><span class=\"line\">notewakeup &lt;-------------------------  notesleep</span><br></pre></td></tr></table></figure>\n<h4 id=\"M的一些问题\"><a href=\"#M的一些问题\" class=\"headerlink\" title=\"M的一些问题\"></a>M的一些问题</h4><p><a href=\"https://github.com/golang/go/issues/14592\" target=\"_blank\" rel=\"noopener\">https://github.com/golang/go/issues/14592</a></p>\n<h3 id=\"P的一生\"><a href=\"#P的一生\" class=\"headerlink\" title=\"P的一生\"></a>P的一生</h3><h4 id=\"P的创建\"><a href=\"#P的创建\" class=\"headerlink\" title=\"P的创建\"></a>P的创建</h4><p><code>proc.go</code><br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Change number of processors. The world is stopped, sched is locked.</span></span><br><span class=\"line\"><span class=\"comment\">// gcworkbufs are not being modified by either the GC or</span></span><br><span class=\"line\"><span class=\"comment\">// the write barrier code.</span></span><br><span class=\"line\"><span class=\"comment\">// Returns list of Ps with local work, they need to be scheduled by the caller.</span></span><br><span class=\"line\"><span class=\"comment\">// 所有的P都在这个函数分配，不管是最开始的初始化分配，还是后期调整</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">procresize</span><span class=\"params\">(nprocs <span class=\"keyword\">int32</span>)</span> *<span class=\"title\">p</span></span> &#123;</span><br><span class=\"line\">\told := gomaxprocs</span><br><span class=\"line\">\t<span class=\"comment\">// 如果 gomaxprocs &lt;=0 抛出异常</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> old &lt; <span class=\"number\">0</span> || nprocs &lt;= <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tthrow(<span class=\"string\">\"procresize: invalid arg\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">\t<span class=\"comment\">// Grow allp if necessary.</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> nprocs &gt; <span class=\"keyword\">int32</span>(<span class=\"built_in\">len</span>(allp)) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// Synchronize with retake, which could be running</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// concurrently since it doesn't run on a P.</span></span><br><span class=\"line\">\t\tlock(&amp;allpLock)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> nprocs &lt;= <span class=\"keyword\">int32</span>(<span class=\"built_in\">cap</span>(allp)) &#123;</span><br><span class=\"line\">\t\t\tallp = allp[:nprocs]</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 分配nprocs个*p</span></span><br><span class=\"line\">\t\t\tnallp := <span class=\"built_in\">make</span>([]*p, nprocs)</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// Copy everything up to allp's cap so we</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// never lose old allocated Ps.</span></span><br><span class=\"line\">\t\t\t<span class=\"built_in\">copy</span>(nallp, allp[:<span class=\"built_in\">cap</span>(allp)])</span><br><span class=\"line\">\t\t\tallp = nallp</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tunlock(&amp;allpLock)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// initialize new P's</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"keyword\">int32</span>(<span class=\"number\">0</span>); i &lt; nprocs; i++ &#123;</span><br><span class=\"line\">\t\tpp := allp[i]</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> pp == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tpp = <span class=\"built_in\">new</span>(p)</span><br><span class=\"line\">\t\t\tpp.id = i</span><br><span class=\"line\">\t\t\tpp.status = _Pgcstop            <span class=\"comment\">// 更改状态</span></span><br><span class=\"line\">\t\t\tpp.sudogcache = pp.sudogbuf[:<span class=\"number\">0</span>] <span class=\"comment\">//将sudogcache指向sudogbuf的起始地址</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> pp.deferpool &#123;</span><br><span class=\"line\">\t\t\t\tpp.deferpool[i] = pp.deferpoolbuf[i][:<span class=\"number\">0</span>]</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tpp.wbBuf.reset()</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 将pp保存到allp数组里, allp[i] = pp</span></span><br><span class=\"line\">\t\t\tatomicstorep(unsafe.Pointer(&amp;allp[i]), unsafe.Pointer(pp))</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  ...</span><br><span class=\"line\"></span><br><span class=\"line\">\t_g_ := getg()</span><br><span class=\"line\">\t<span class=\"comment\">// 如果当前的M已经绑定P，继续使用，否则将当前的M绑定一个P</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> _g_.m.p != <span class=\"number\">0</span> &amp;&amp; _g_.m.p.ptr().id &lt; nprocs &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// continue to use the current P</span></span><br><span class=\"line\">\t\t_g_.m.p.ptr().status = _Prunning</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// release the current P and acquire allp[0]</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 获取allp[0]</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> _g_.m.p != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t_g_.m.p.ptr().m = <span class=\"number\">0</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t_g_.m.p = <span class=\"number\">0</span></span><br><span class=\"line\">\t\t_g_.m.mcache = <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\tp := allp[<span class=\"number\">0</span>]</span><br><span class=\"line\">\t\tp.m = <span class=\"number\">0</span></span><br><span class=\"line\">\t\tp.status = _Pidle</span><br><span class=\"line\">\t\t<span class=\"comment\">// 将当前的m和p绑定</span></span><br><span class=\"line\">\t\tacquirep(p)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> trace.enabled &#123;</span><br><span class=\"line\">\t\t\ttraceGoStart()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> runnablePs *p</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := nprocs - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i-- &#123;</span><br><span class=\"line\">\t\tp := allp[i]</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> _g_.m.p.ptr() == p &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tp.status = _Pidle</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> runqempty(p) &#123; <span class=\"comment\">// 将空闲p放入空闲链表</span></span><br><span class=\"line\">\t\t\tpidleput(p)</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tp.m.set(mget())</span><br><span class=\"line\">\t\t\tp.link.set(runnablePs)</span><br><span class=\"line\">\t\t\trunnablePs = p</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tstealOrder.reset(<span class=\"keyword\">uint32</span>(nprocs))</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> int32p *<span class=\"keyword\">int32</span> = &amp;gomaxprocs <span class=\"comment\">// make compiler check that gomaxprocs is an int32</span></span><br><span class=\"line\">\tatomic.Store((*<span class=\"keyword\">uint32</span>)(unsafe.Pointer(int32p)), <span class=\"keyword\">uint32</span>(nprocs))</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> runnablePs</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>所有的P在程序启动的时候就设置好了，并用一个allp slice维护，可以调用runtime.GOMAXPROCS调整P的个数，虽然代价很大</p>\n<h4 id=\"状态转换\"><a href=\"#状态转换\" class=\"headerlink\" title=\"状态转换\"></a>状态转换</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">                                            acquirep(p)        </span><br><span class=\"line\">                          不需要使用的P       P和M绑定的时候       进入系统调用       procresize()</span><br><span class=\"line\">new(p)  -----+        +---------------+     +-----------+     +------------+    +----------+</span><br><span class=\"line\">            |         |               |     |           |     |            |    |          |</span><br><span class=\"line\">            |   +------------+    +---v--------+    +---v--------+    +----v-------+    +--v---------+</span><br><span class=\"line\">            +--&gt;|  _Pgcstop  |    |    _Pidle  |    |  _Prunning |    |  _Psyscall |    |   _Pdead   |</span><br><span class=\"line\">                +------^-----+    +--------^---+    +--------^---+    +------------+    +------------+</span><br><span class=\"line\">                       |            |     |            |     |            |</span><br><span class=\"line\">                       +------------+     +------------+     +------------+</span><br><span class=\"line\">                           GC结束            releasep()        退出系统调用</span><br><span class=\"line\">                                            P和M解绑                      </span><br><span class=\"line\">``` </span><br><span class=\"line\">P的数量默认等于cpu的个数，很多人认为runtime.GOMAXPROCS可以限制系统线程的数量，但这是错误的，M是按需创建的，和runtime.GOMAXPROCS没有关系。</span><br><span class=\"line\">### G的一生</span><br><span class=\"line\"></span><br><span class=\"line\">#### G的创建</span><br><span class=\"line\">`proc.go`</span><br><span class=\"line\">```go</span><br><span class=\"line\">// Create a new g running fn with siz bytes of arguments.</span><br><span class=\"line\">// Put it on the queue of g&apos;s waiting to run.</span><br><span class=\"line\">// The compiler turns a go statement into a call to this.</span><br><span class=\"line\">// Cannot split the stack because it assumes that the arguments</span><br><span class=\"line\">// are available sequentially after &amp;fn; they would not be</span><br><span class=\"line\">// copied if a stack split occurred.</span><br><span class=\"line\">//go:nosplit</span><br><span class=\"line\">// 新建一个goroutine，</span><br><span class=\"line\">// 􏳄 用fn + PtrSize 获取第一个参数的地址，也就是argp</span><br><span class=\"line\">// 用siz - 8 获取pc地址</span><br><span class=\"line\">func newproc(siz int32, fn *funcval) &#123;</span><br><span class=\"line\">\targp := add(unsafe.Pointer(&amp;fn), sys.PtrSize)</span><br><span class=\"line\">\tpc := getcallerpc()</span><br><span class=\"line\">\t// 用g0的栈创建G对象</span><br><span class=\"line\">\tsystemstack(func() &#123;</span><br><span class=\"line\">\t\tnewproc1(fn, (*uint8)(argp), siz, pc)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Create a new g running fn with narg bytes of arguments starting</span></span><br><span class=\"line\"><span class=\"comment\">// at argp. callerpc is the address of the go statement that created</span></span><br><span class=\"line\"><span class=\"comment\">// this. The new g is put on the queue of g's waiting to run.</span></span><br><span class=\"line\"><span class=\"comment\">// 根据函数参数和函数地址，创建一个新的G，然后将这个G加入队列等待运行</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">newproc1</span><span class=\"params\">(fn *funcval, argp *<span class=\"keyword\">uint8</span>, narg <span class=\"keyword\">int32</span>, callerpc <span class=\"keyword\">uintptr</span>)</span></span> &#123;</span><br><span class=\"line\">\t_g_ := getg()</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> fn == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t_g_.m.throwing = <span class=\"number\">-1</span> <span class=\"comment\">// do not dump full stacks</span></span><br><span class=\"line\">\t\tthrow(<span class=\"string\">\"go of nil func value\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t_g_.m.locks++ <span class=\"comment\">// disable preemption because it can be holding p in a local var</span></span><br><span class=\"line\">\tsiz := narg</span><br><span class=\"line\">\tsiz = (siz + <span class=\"number\">7</span>) &amp;^ <span class=\"number\">7</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// We could allocate a larger initial stack if necessary.</span></span><br><span class=\"line\">\t<span class=\"comment\">// Not worth it: this is almost always an error.</span></span><br><span class=\"line\">\t<span class=\"comment\">// 4*sizeof(uintreg): extra space added below</span></span><br><span class=\"line\">\t<span class=\"comment\">// sizeof(uintreg): caller's LR (arm) or return address (x86, in gostartcall).</span></span><br><span class=\"line\">\t<span class=\"comment\">// 如果函数的参数大小比2048大的话，直接panic</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> siz &gt;= _StackMin<span class=\"number\">-4</span>*sys.RegSize-sys.RegSize &#123;</span><br><span class=\"line\">\t\tthrow(<span class=\"string\">\"newproc: function arguments too large for new goroutine\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 从m中获取p</span></span><br><span class=\"line\">\t_p_ := _g_.m.p.ptr()</span><br><span class=\"line\">\t<span class=\"comment\">// 从gfree list获取g</span></span><br><span class=\"line\">\tnewg := gfget(_p_)</span><br><span class=\"line\">\t<span class=\"comment\">// 如果没获取到g，则新建一个</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> newg == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tnewg = malg(_StackMin)</span><br><span class=\"line\">\t\tcasgstatus(newg, _Gidle, _Gdead) <span class=\"comment\">//将g的状态改为_Gdead</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 添加到allg数组，防止gc扫描清除掉</span></span><br><span class=\"line\">\t\tallgadd(newg) <span class=\"comment\">// publishes with a g-&gt;status of Gdead so GC scanner doesn't look at uninitialized stack.</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> newg.stack.hi == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tthrow(<span class=\"string\">\"newproc1: newg missing stack\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> readgstatus(newg) != _Gdead &#123;</span><br><span class=\"line\">\t\tthrow(<span class=\"string\">\"newproc1: new g is not Gdead\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\ttotalSize := <span class=\"number\">4</span>*sys.RegSize + <span class=\"keyword\">uintptr</span>(siz) + sys.MinFrameSize <span class=\"comment\">// extra space in case of reads slightly beyond frame</span></span><br><span class=\"line\">\ttotalSize += -totalSize &amp; (sys.SpAlign - <span class=\"number\">1</span>)                  <span class=\"comment\">// align to spAlign</span></span><br><span class=\"line\">\tsp := newg.stack.hi - totalSize</span><br><span class=\"line\">\tspArg := sp</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> usesLR &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// caller's LR</span></span><br><span class=\"line\">\t\t*(*<span class=\"keyword\">uintptr</span>)(unsafe.Pointer(sp)) = <span class=\"number\">0</span></span><br><span class=\"line\">\t\tprepGoExitFrame(sp)</span><br><span class=\"line\">\t\tspArg += sys.MinFrameSize</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> narg &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// copy参数</span></span><br><span class=\"line\">\t\tmemmove(unsafe.Pointer(spArg), unsafe.Pointer(argp), <span class=\"keyword\">uintptr</span>(narg))</span><br><span class=\"line\">\t\t<span class=\"comment\">// This is a stack-to-stack copy. If write barriers</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// are enabled and the source stack is grey (the</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// destination is always black), then perform a</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// barrier copy. We do this *after* the memmove</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// because the destination stack may have garbage on</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// it.</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> writeBarrier.needed &amp;&amp; !_g_.m.curg.gcscandone &#123;</span><br><span class=\"line\">\t\t\tf := findfunc(fn.fn)</span><br><span class=\"line\">\t\t\tstkmap := (*stackmap)(funcdata(f, _FUNCDATA_ArgsPointerMaps))</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// We're in the prologue, so it's always stack map index 0.</span></span><br><span class=\"line\">\t\t\tbv := stackmapdata(stkmap, <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\tbulkBarrierBitmap(spArg, spArg, <span class=\"keyword\">uintptr</span>(narg), <span class=\"number\">0</span>, bv.bytedata)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tmemclrNoHeapPointers(unsafe.Pointer(&amp;newg.sched), unsafe.Sizeof(newg.sched))</span><br><span class=\"line\">\tnewg.sched.sp = sp</span><br><span class=\"line\">\tnewg.stktopsp = sp</span><br><span class=\"line\">\t<span class=\"comment\">// 保存goexit的地址到sched.pc</span></span><br><span class=\"line\">\tnewg.sched.pc = funcPC(goexit) + sys.PCQuantum <span class=\"comment\">// +PCQuantum so that previous instruction is in same function</span></span><br><span class=\"line\">\tnewg.sched.g = guintptr(unsafe.Pointer(newg))</span><br><span class=\"line\">\tgostartcallfn(&amp;newg.sched, fn)</span><br><span class=\"line\">\tnewg.gopc = callerpc</span><br><span class=\"line\">\tnewg.startpc = fn.fn</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> _g_.m.curg != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tnewg.labels = _g_.m.curg.labels</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> isSystemGoroutine(newg) &#123;</span><br><span class=\"line\">\t\tatomic.Xadd(&amp;sched.ngsys, +<span class=\"number\">1</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tnewg.gcscanvalid = <span class=\"literal\">false</span></span><br><span class=\"line\">\t<span class=\"comment\">// 更改当前g的状态为_Grunnable</span></span><br><span class=\"line\">\tcasgstatus(newg, _Gdead, _Grunnable)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> _p_.goidcache == _p_.goidcacheend &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// Sched.goidgen is the last allocated id,</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// this batch must be [sched.goidgen+1, sched.goidgen+GoidCacheBatch].</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// At startup sched.goidgen=0, so main goroutine receives goid=1.</span></span><br><span class=\"line\">\t\t_p_.goidcache = atomic.Xadd64(&amp;sched.goidgen, _GoidCacheBatch)</span><br><span class=\"line\">\t\t_p_.goidcache -= _GoidCacheBatch - <span class=\"number\">1</span></span><br><span class=\"line\">\t\t_p_.goidcacheend = _p_.goidcache + _GoidCacheBatch</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 生成唯一的goid</span></span><br><span class=\"line\">\tnewg.goid = <span class=\"keyword\">int64</span>(_p_.goidcache)</span><br><span class=\"line\">\t_p_.goidcache++</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> raceenabled &#123;</span><br><span class=\"line\">\t\tnewg.racectx = racegostart(callerpc)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> trace.enabled &#123;</span><br><span class=\"line\">\t\ttraceGoCreate(newg, newg.startpc)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 将当前新生成的g，放入队列</span></span><br><span class=\"line\">\trunqput(_p_, newg, <span class=\"literal\">true</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 如果有空闲的p 且 m没有处于自旋状态 且 main goroutine已经启动，那么唤醒某个m来执行任务</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> atomic.Load(&amp;sched.npidle) != <span class=\"number\">0</span> &amp;&amp; atomic.Load(&amp;sched.nmspinning) == <span class=\"number\">0</span> &amp;&amp; mainStarted &#123;</span><br><span class=\"line\">\t\twakep()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t_g_.m.locks--</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> _g_.m.locks == <span class=\"number\">0</span> &amp;&amp; _g_.preempt &#123; <span class=\"comment\">// restore the preemption request in case we've cleared it in newstack</span></span><br><span class=\"line\">\t\t_g_.stackguard0 = stackPreempt</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"G的状态图\"><a href=\"#G的状态图\" class=\"headerlink\" title=\"G的状态图\"></a>G的状态图</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">                                                    +------------+</span><br><span class=\"line\">                                    ready           |            |</span><br><span class=\"line\">                                +------------------ |  _Gwaiting |</span><br><span class=\"line\">                                |                   |            |</span><br><span class=\"line\">                                |                   +------------+</span><br><span class=\"line\">                                |                         ^ park_m</span><br><span class=\"line\">                                V                         | </span><br><span class=\"line\">+------------+            +------------+  execute   +------------+            +------------+    </span><br><span class=\"line\">|            |  newproc   |            | ---------&gt; |            |   goexit   |            |</span><br><span class=\"line\">|  _Gidle    | ---------&gt; | _Grunnable |  yield     | _Grunning  | ---------&gt; |   _Gdead   |      </span><br><span class=\"line\">|            |            |            | &lt;--------- |            |            |            |</span><br><span class=\"line\">+------------+            +-----^------+            +------------+            +------------+</span><br><span class=\"line\">                                |         entersyscall |      ^ </span><br><span class=\"line\">                                |                      V      | existsyscall</span><br><span class=\"line\">                                |                   +------------+</span><br><span class=\"line\">                                |   existsyscall    |            |</span><br><span class=\"line\">                                +------------------ |  _Gsyscall |</span><br><span class=\"line\">                                                    |            |</span><br><span class=\"line\">                                                    +------------+</span><br></pre></td></tr></table></figure>\n<p>新建的G都是_Grunnable的，新建G的时候优先从gfree list从获取G，这样可以复用G，所以上图的状态不是完整的，_Gdead通过newproc会变为_Grunnable，<br>通过go func()的语法新建的G，并不是直接运行，而是放入可运行的队列中，什么时候运行用于并不能决定，而是搞调度系统去自发的运行。</p>"},{"title":"对于 Netty ByteBuf 的零拷贝(Zero Copy) 的理解","date":"2018-08-20T01:04:55.000Z","_content":"\n根据 Wiki 对 Zero-copy 的定义:\n> \"Zero-copy\" describes computer operations in which the CPU does not perform the task of copying data from one memory area to another. This is frequently used to save CPU cycles and memory bandwidth when transmitting a file over a network.\n\n即所谓的 Zero-copy, 就是在操作数据时, 不需要将数据 buffer 从一个内存区域拷贝到另一个内存区域. 因为少了一次内存的拷贝, 因此 CPU 的效率就得到的提升.\n\n在 OS 层面上的 Zero-copy 通常指避免在 用户态(User-space) 与 内核态(Kernel-space) 之间来回拷贝数据. 例如 Linux 提供的 mmap 系统调用, 它可以将一段用户空间内存映射到内核空间, 当映射成功后, 用户对这段内存区域的修改可以直接反映到内核空间; 同样地, 内核空间对这段区域的修改也直接反映用户空间. 正因为有这样的映射关系, 我们就不需要在 用户态(User-space) 与 内核态(Kernel-space) 之间拷贝数据, 提高了数据传输的效率.\n\n而需要注意的是, Netty 中的 Zero-copy 与上面我们所提到到 OS 层面上的 Zero-copy 不太一样, Netty的 Zero-coyp 完全是在用户态(Java 层面)的, 它的 Zero-copy 的更多的是偏向于 优化数据操作 这样的概念.\n\nNetty 的 Zero-copy 体现在如下几个个方面:\n\n- Netty 提供了 CompositeByteBuf 类, 它可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf, 避免了各个 ByteBuf 之间的拷贝.\n- 通过 wrap 操作, 我们可以将 byte[] 数组、ByteBuf、ByteBuffer等包装成一个 Netty ByteBuf 对象, 进而避免了拷贝操作.\n- ByteBuf 支持 slice 操作, 因此可以将 ByteBuf 分解为多个共享同一个存储区域的 ByteBuf, 避免了内存的拷贝.\n- 通过 FileRegion 包装的FileChannel.tranferTo 实现文件传输, 可以直接将文件缓冲区的数据发送到目标 Channel, 避免了传统通过循环 write 方式导致的内存拷贝问题.\n\n下面我们就来简单了解一下这几种常见的零拷贝操作.\n\n<!-- more -->\n\n# 通过 CompositeByteBuf 实现零拷贝\n\n假设我们有一份协议数据, 它由头部和消息体组成, 而头部和消息体是分别存放在两个 ByteBuf 中的, 即:\n```\nByteBuf header = ...\nByteBuf body = ...\n```\n我们在代码处理中, 通常希望将 header 和 body 合并为一个 ByteBuf, 方便处理, 那么通常的做法是:\n```\nByteBuf allBuf = Unpooled.buffer(header.readableBytes() + body.readableBytes());\nallBuf.writeBytes(header);\nallBuf.writeBytes(body);\n```\n可以看到, 我们将 header 和 body 都拷贝到了新的 allBuf 中了, 这无形中增加了两次额外的数据拷贝操作了.\n\n那么有没有更加高效优雅的方式实现相同的目的呢? 我们来看一下 CompositeByteBuf 是如何实现这样的需求的吧.\n```\nByteBuf header = ...\nByteBuf body = ...\n\nCompositeByteBuf compositeByteBuf = Unpooled.compositeBuffer();\ncompositeByteBuf.addComponents(true, header, body);\n```\n上面代码中, 我们定义了一个 CompositeByteBuf 对象, 然后调用\n```\npublic CompositeByteBuf addComponents(boolean increaseWriterIndex, ByteBuf... buffers) {\n...\n}\n```\n不过需要注意的是, 虽然看起来 CompositeByteBuf 是由两个 ByteBuf 组合而成的, 不过在 CompositeByteBuf 内部, 这两个 ByteBuf 都是单独存在的, CompositeByteBuf 只是逻辑上是一个整体.\n\n上面 CompositeByteBuf 代码还以一个地方值得注意的是, 我们调用 addComponents(boolean increaseWriterIndex, ByteBuf... buffers) 来添加两个 ByteBuf, 其中第一个参数是 true, 表示当添加新的 ByteBuf 时, 自动递增 CompositeByteBuf 的 writeIndex.\n如果我们调用的是\n```\ncompositeByteBuf.addComponents(header, body);\n```\n那么其实 compositeByteBuf 的 writeIndex 仍然是0, 因此此时我们就不可能从 compositeByteBuf 中读取到数据, 这一点希望大家要特别注意.\n\n除了上面直接使用 CompositeByteBuf 类外, 我们还可以使用 Unpooled.wrappedBuffer 方法, 它底层封装了 CompositeByteBuf 操作, 因此使用起来更加方便:\n```\nByteBuf header = ...\nByteBuf body = ...\n\nByteBuf allByteBuf = Unpooled.wrappedBuffer(header, body);\n```\n# 通过 wrap 操作实现零拷贝\n例如我们有一个 byte 数组, 我们希望将它转换为一个 ByteBuf 对象, 以便于后续的操作, 那么传统的做法是将此 byte 数组拷贝到 ByteBuf 中, 即:\n```\nbyte[] bytes = ...\nByteBuf byteBuf = Unpooled.buffer();\nbyteBuf.writeBytes(bytes);\n```\n显然这样的方式也是有一个额外的拷贝操作的, 我们可以使用 Unpooled 的相关方法, 包装这个 byte 数组, 生成一个新的 ByteBuf 实例, 而不需要进行拷贝操作. 上面的代码可以改为:\n```\nbyte[] bytes = ...\nByteBuf byteBuf = Unpooled.wrappedBuffer(bytes);\n```\n可以看到, 我们通过 Unpooled.wrappedBuffer 方法来将 bytes 包装成为一个 UnpooledHeapByteBuf 对象, 而在包装的过程中, 是不会有拷贝操作的. 即最后我们生成的生成的 ByteBuf 对象是和 bytes 数组共用了同一个存储空间, 对 bytes 的修改也会反映到 ByteBuf 对象中.\n\nUnpooled 工具类还提供了很多重载的 wrappedBuffer 方法:\n```\npublic static ByteBuf wrappedBuffer(byte[] array)\npublic static ByteBuf wrappedBuffer(byte[] array, int offset, int length)\n\npublic static ByteBuf wrappedBuffer(ByteBuffer buffer)\npublic static ByteBuf wrappedBuffer(ByteBuf buffer)\n\npublic static ByteBuf wrappedBuffer(byte[]... arrays)\npublic static ByteBuf wrappedBuffer(ByteBuf... buffers)\npublic static ByteBuf wrappedBuffer(ByteBuffer... buffers)\n\npublic static ByteBuf wrappedBuffer(int maxNumComponents, byte[]... arrays)\npublic static ByteBuf wrappedBuffer(int maxNumComponents, ByteBuf... buffers)\npublic static ByteBuf wrappedBuffer(int maxNumComponents, ByteBuffer... buffers)\n```\n这些方法可以将一个或多个 buffer 包装为一个 ByteBuf 对象, 从而避免了拷贝操作.\n# 通过 slice 操作实现零拷贝\nslice 操作和 wrap 操作刚好相反, Unpooled.wrappedBuffer 可以将多个 ByteBuf 合并为一个, 而 slice 操作可以将一个 ByteBuf 切片 为多个共享一个存储区域的 ByteBuf 对象.\n\nByteBuf 提供了两个 slice 操作方法:\n```\npublic ByteBuf slice();\npublic ByteBuf slice(int index, int length);\n```\n不带参数的 slice 方法等同于 buf.slice(buf.readerIndex(), buf.readableBytes()) 调用, 即返回 buf 中可读部分的切片. 而 slice(int index, int length) 方法相对就比较灵活了, 我们可以设置不同的参数来获取到 buf 的不同区域的切片.\n\n下面的例子展示了 ByteBuf.slice 方法的简单用法:\n```\nByteBuf byteBuf = ...\nByteBuf header = byteBuf.slice(0, 5);\nByteBuf body = byteBuf.slice(5, 10);\n```\n用 slice 方法产生 header 和 body 的过程是没有拷贝操作的, header 和 body 对象在内部其实是共享了 byteBuf 存储空间的不同部分而已.\n# 通过 FileRegion 实现零拷贝\nNetty 中使用 FileRegion 实现文件传输的零拷贝, 不过在底层 FileRegion 是依赖于 Java NIO FileChannel.transfer 的零拷贝功能.\n\n首先我们从最基础的 Java IO 开始吧. 假设我们希望实现一个文件拷贝的功能, 那么使用传统的方式, 我们有如下实现:\n\n```\npublic static void copyFile(String srcFile, String destFile) throws Exception {\n    byte[] temp = new byte[1024];\n    FileInputStream in = new FileInputStream(srcFile);\n    FileOutputStream out = new FileOutputStream(destFile);\n    int length;\n    while ((length = in.read(temp)) != -1) {\n        out.write(temp, 0, length);\n    }\n\n    in.close();\n    out.close();\n}\n```\n上面是一个典型的读写二进制文件的代码实现了. 不用我说, 大家肯定都知道, 上面的代码中不断中源文件中读取定长数据到 temp 数组中, 然后再将 temp 中的内容写入目的文件, 这样的拷贝操作对于小文件倒是没有太大的影响, 但是如果我们需要拷贝大文件时, 频繁的内存拷贝操作就消耗大量的系统资源了.\n\n下面我们来看一下使用 Java NIO 的 FileChannel 是如何实现零拷贝的:\n```\npublic static void copyFileWithFileChannel(String srcFileName, String destFileName) throws Exception {\n    RandomAccessFile srcFile = new RandomAccessFile(srcFileName, \"r\");\n    FileChannel srcFileChannel = srcFile.getChannel();\n\n    RandomAccessFile destFile = new RandomAccessFile(destFileName, \"rw\");\n    FileChannel destFileChannel = destFile.getChannel();\n\n    long position = 0;\n    long count = srcFileChannel.size();\n\n    srcFileChannel.transferTo(position, count, destFileChannel);\n}\n\n```\n可以看到, 使用了 FileChannel 后, 我们就可以直接将源文件的内容直接拷贝(transferTo) 到目的文件中, 而不需要额外借助一个临时 buffer, 避免了不必要的内存操作.\n\n有了上面的一些理论知识, 我们来看一下在 Netty 中是怎么使用 FileRegion 来实现零拷贝传输一个文件的:\n```\n@Override\npublic void channelRead0(ChannelHandlerContext ctx, String msg) throws Exception {\n    RandomAccessFile raf = null;\n    long length = -1;\n    try {\n        // 1. 通过 RandomAccessFile 打开一个文件.\n        raf = new RandomAccessFile(msg, \"r\");\n        length = raf.length();\n    } catch (Exception e) {\n        ctx.writeAndFlush(\"ERR: \" + e.getClass().getSimpleName() + \": \" + e.getMessage() + '\\n');\n        return;\n    } finally {\n        if (length < 0 && raf != null) {\n            raf.close();\n        }\n    }\n\n    ctx.write(\"OK: \" + raf.length() + '\\n');\n    if (ctx.pipeline().get(SslHandler.class) == null) {\n        // SSL not enabled - can use zero-copy file transfer.\n        // 2. 调用 raf.getChannel() 获取一个 FileChannel.\n        // 3. 将 FileChannel 封装成一个 DefaultFileRegion\n        ctx.write(new DefaultFileRegion(raf.getChannel(), 0, length));\n    } else {\n        // SSL enabled - cannot use zero-copy file transfer.\n        ctx.write(new ChunkedFile(raf));\n    }\n    ctx.writeAndFlush(\"\\n\");\n}\n```\n上面的代码是 Netty 的一个例子, 其源码在 netty/example/src/main/java/io/netty/example/file/FileServerHandler.java\n可以看到, 第一步是通过 RandomAccessFile 打开一个文件, 然后 Netty 使用了 DefaultFileRegion 来封装一个 FileChannel 即:\n```\nnew DefaultFileRegion(raf.getChannel(), 0, length)\n```\n当有了 FileRegion 后, 我们就可以直接通过它将文件的内容直接写入 Channel 中, 而不需要像传统的做法: 拷贝文件内容到临时 buffer, 然后再将 buffer 写入 Channel. 通过这样的零拷贝操作, 无疑对传输大文件很有帮助.\n\n转载出处：https://www.cnblogs.com/xys1228/p/6088805.html\n","source":"_posts/zero-copy.md","raw":"---\ntitle: 对于 Netty ByteBuf 的零拷贝(Zero Copy) 的理解\ndate: 2018-08-20 09:04:55\ntags: Netty\n---\n\n根据 Wiki 对 Zero-copy 的定义:\n> \"Zero-copy\" describes computer operations in which the CPU does not perform the task of copying data from one memory area to another. This is frequently used to save CPU cycles and memory bandwidth when transmitting a file over a network.\n\n即所谓的 Zero-copy, 就是在操作数据时, 不需要将数据 buffer 从一个内存区域拷贝到另一个内存区域. 因为少了一次内存的拷贝, 因此 CPU 的效率就得到的提升.\n\n在 OS 层面上的 Zero-copy 通常指避免在 用户态(User-space) 与 内核态(Kernel-space) 之间来回拷贝数据. 例如 Linux 提供的 mmap 系统调用, 它可以将一段用户空间内存映射到内核空间, 当映射成功后, 用户对这段内存区域的修改可以直接反映到内核空间; 同样地, 内核空间对这段区域的修改也直接反映用户空间. 正因为有这样的映射关系, 我们就不需要在 用户态(User-space) 与 内核态(Kernel-space) 之间拷贝数据, 提高了数据传输的效率.\n\n而需要注意的是, Netty 中的 Zero-copy 与上面我们所提到到 OS 层面上的 Zero-copy 不太一样, Netty的 Zero-coyp 完全是在用户态(Java 层面)的, 它的 Zero-copy 的更多的是偏向于 优化数据操作 这样的概念.\n\nNetty 的 Zero-copy 体现在如下几个个方面:\n\n- Netty 提供了 CompositeByteBuf 类, 它可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf, 避免了各个 ByteBuf 之间的拷贝.\n- 通过 wrap 操作, 我们可以将 byte[] 数组、ByteBuf、ByteBuffer等包装成一个 Netty ByteBuf 对象, 进而避免了拷贝操作.\n- ByteBuf 支持 slice 操作, 因此可以将 ByteBuf 分解为多个共享同一个存储区域的 ByteBuf, 避免了内存的拷贝.\n- 通过 FileRegion 包装的FileChannel.tranferTo 实现文件传输, 可以直接将文件缓冲区的数据发送到目标 Channel, 避免了传统通过循环 write 方式导致的内存拷贝问题.\n\n下面我们就来简单了解一下这几种常见的零拷贝操作.\n\n<!-- more -->\n\n# 通过 CompositeByteBuf 实现零拷贝\n\n假设我们有一份协议数据, 它由头部和消息体组成, 而头部和消息体是分别存放在两个 ByteBuf 中的, 即:\n```\nByteBuf header = ...\nByteBuf body = ...\n```\n我们在代码处理中, 通常希望将 header 和 body 合并为一个 ByteBuf, 方便处理, 那么通常的做法是:\n```\nByteBuf allBuf = Unpooled.buffer(header.readableBytes() + body.readableBytes());\nallBuf.writeBytes(header);\nallBuf.writeBytes(body);\n```\n可以看到, 我们将 header 和 body 都拷贝到了新的 allBuf 中了, 这无形中增加了两次额外的数据拷贝操作了.\n\n那么有没有更加高效优雅的方式实现相同的目的呢? 我们来看一下 CompositeByteBuf 是如何实现这样的需求的吧.\n```\nByteBuf header = ...\nByteBuf body = ...\n\nCompositeByteBuf compositeByteBuf = Unpooled.compositeBuffer();\ncompositeByteBuf.addComponents(true, header, body);\n```\n上面代码中, 我们定义了一个 CompositeByteBuf 对象, 然后调用\n```\npublic CompositeByteBuf addComponents(boolean increaseWriterIndex, ByteBuf... buffers) {\n...\n}\n```\n不过需要注意的是, 虽然看起来 CompositeByteBuf 是由两个 ByteBuf 组合而成的, 不过在 CompositeByteBuf 内部, 这两个 ByteBuf 都是单独存在的, CompositeByteBuf 只是逻辑上是一个整体.\n\n上面 CompositeByteBuf 代码还以一个地方值得注意的是, 我们调用 addComponents(boolean increaseWriterIndex, ByteBuf... buffers) 来添加两个 ByteBuf, 其中第一个参数是 true, 表示当添加新的 ByteBuf 时, 自动递增 CompositeByteBuf 的 writeIndex.\n如果我们调用的是\n```\ncompositeByteBuf.addComponents(header, body);\n```\n那么其实 compositeByteBuf 的 writeIndex 仍然是0, 因此此时我们就不可能从 compositeByteBuf 中读取到数据, 这一点希望大家要特别注意.\n\n除了上面直接使用 CompositeByteBuf 类外, 我们还可以使用 Unpooled.wrappedBuffer 方法, 它底层封装了 CompositeByteBuf 操作, 因此使用起来更加方便:\n```\nByteBuf header = ...\nByteBuf body = ...\n\nByteBuf allByteBuf = Unpooled.wrappedBuffer(header, body);\n```\n# 通过 wrap 操作实现零拷贝\n例如我们有一个 byte 数组, 我们希望将它转换为一个 ByteBuf 对象, 以便于后续的操作, 那么传统的做法是将此 byte 数组拷贝到 ByteBuf 中, 即:\n```\nbyte[] bytes = ...\nByteBuf byteBuf = Unpooled.buffer();\nbyteBuf.writeBytes(bytes);\n```\n显然这样的方式也是有一个额外的拷贝操作的, 我们可以使用 Unpooled 的相关方法, 包装这个 byte 数组, 生成一个新的 ByteBuf 实例, 而不需要进行拷贝操作. 上面的代码可以改为:\n```\nbyte[] bytes = ...\nByteBuf byteBuf = Unpooled.wrappedBuffer(bytes);\n```\n可以看到, 我们通过 Unpooled.wrappedBuffer 方法来将 bytes 包装成为一个 UnpooledHeapByteBuf 对象, 而在包装的过程中, 是不会有拷贝操作的. 即最后我们生成的生成的 ByteBuf 对象是和 bytes 数组共用了同一个存储空间, 对 bytes 的修改也会反映到 ByteBuf 对象中.\n\nUnpooled 工具类还提供了很多重载的 wrappedBuffer 方法:\n```\npublic static ByteBuf wrappedBuffer(byte[] array)\npublic static ByteBuf wrappedBuffer(byte[] array, int offset, int length)\n\npublic static ByteBuf wrappedBuffer(ByteBuffer buffer)\npublic static ByteBuf wrappedBuffer(ByteBuf buffer)\n\npublic static ByteBuf wrappedBuffer(byte[]... arrays)\npublic static ByteBuf wrappedBuffer(ByteBuf... buffers)\npublic static ByteBuf wrappedBuffer(ByteBuffer... buffers)\n\npublic static ByteBuf wrappedBuffer(int maxNumComponents, byte[]... arrays)\npublic static ByteBuf wrappedBuffer(int maxNumComponents, ByteBuf... buffers)\npublic static ByteBuf wrappedBuffer(int maxNumComponents, ByteBuffer... buffers)\n```\n这些方法可以将一个或多个 buffer 包装为一个 ByteBuf 对象, 从而避免了拷贝操作.\n# 通过 slice 操作实现零拷贝\nslice 操作和 wrap 操作刚好相反, Unpooled.wrappedBuffer 可以将多个 ByteBuf 合并为一个, 而 slice 操作可以将一个 ByteBuf 切片 为多个共享一个存储区域的 ByteBuf 对象.\n\nByteBuf 提供了两个 slice 操作方法:\n```\npublic ByteBuf slice();\npublic ByteBuf slice(int index, int length);\n```\n不带参数的 slice 方法等同于 buf.slice(buf.readerIndex(), buf.readableBytes()) 调用, 即返回 buf 中可读部分的切片. 而 slice(int index, int length) 方法相对就比较灵活了, 我们可以设置不同的参数来获取到 buf 的不同区域的切片.\n\n下面的例子展示了 ByteBuf.slice 方法的简单用法:\n```\nByteBuf byteBuf = ...\nByteBuf header = byteBuf.slice(0, 5);\nByteBuf body = byteBuf.slice(5, 10);\n```\n用 slice 方法产生 header 和 body 的过程是没有拷贝操作的, header 和 body 对象在内部其实是共享了 byteBuf 存储空间的不同部分而已.\n# 通过 FileRegion 实现零拷贝\nNetty 中使用 FileRegion 实现文件传输的零拷贝, 不过在底层 FileRegion 是依赖于 Java NIO FileChannel.transfer 的零拷贝功能.\n\n首先我们从最基础的 Java IO 开始吧. 假设我们希望实现一个文件拷贝的功能, 那么使用传统的方式, 我们有如下实现:\n\n```\npublic static void copyFile(String srcFile, String destFile) throws Exception {\n    byte[] temp = new byte[1024];\n    FileInputStream in = new FileInputStream(srcFile);\n    FileOutputStream out = new FileOutputStream(destFile);\n    int length;\n    while ((length = in.read(temp)) != -1) {\n        out.write(temp, 0, length);\n    }\n\n    in.close();\n    out.close();\n}\n```\n上面是一个典型的读写二进制文件的代码实现了. 不用我说, 大家肯定都知道, 上面的代码中不断中源文件中读取定长数据到 temp 数组中, 然后再将 temp 中的内容写入目的文件, 这样的拷贝操作对于小文件倒是没有太大的影响, 但是如果我们需要拷贝大文件时, 频繁的内存拷贝操作就消耗大量的系统资源了.\n\n下面我们来看一下使用 Java NIO 的 FileChannel 是如何实现零拷贝的:\n```\npublic static void copyFileWithFileChannel(String srcFileName, String destFileName) throws Exception {\n    RandomAccessFile srcFile = new RandomAccessFile(srcFileName, \"r\");\n    FileChannel srcFileChannel = srcFile.getChannel();\n\n    RandomAccessFile destFile = new RandomAccessFile(destFileName, \"rw\");\n    FileChannel destFileChannel = destFile.getChannel();\n\n    long position = 0;\n    long count = srcFileChannel.size();\n\n    srcFileChannel.transferTo(position, count, destFileChannel);\n}\n\n```\n可以看到, 使用了 FileChannel 后, 我们就可以直接将源文件的内容直接拷贝(transferTo) 到目的文件中, 而不需要额外借助一个临时 buffer, 避免了不必要的内存操作.\n\n有了上面的一些理论知识, 我们来看一下在 Netty 中是怎么使用 FileRegion 来实现零拷贝传输一个文件的:\n```\n@Override\npublic void channelRead0(ChannelHandlerContext ctx, String msg) throws Exception {\n    RandomAccessFile raf = null;\n    long length = -1;\n    try {\n        // 1. 通过 RandomAccessFile 打开一个文件.\n        raf = new RandomAccessFile(msg, \"r\");\n        length = raf.length();\n    } catch (Exception e) {\n        ctx.writeAndFlush(\"ERR: \" + e.getClass().getSimpleName() + \": \" + e.getMessage() + '\\n');\n        return;\n    } finally {\n        if (length < 0 && raf != null) {\n            raf.close();\n        }\n    }\n\n    ctx.write(\"OK: \" + raf.length() + '\\n');\n    if (ctx.pipeline().get(SslHandler.class) == null) {\n        // SSL not enabled - can use zero-copy file transfer.\n        // 2. 调用 raf.getChannel() 获取一个 FileChannel.\n        // 3. 将 FileChannel 封装成一个 DefaultFileRegion\n        ctx.write(new DefaultFileRegion(raf.getChannel(), 0, length));\n    } else {\n        // SSL enabled - cannot use zero-copy file transfer.\n        ctx.write(new ChunkedFile(raf));\n    }\n    ctx.writeAndFlush(\"\\n\");\n}\n```\n上面的代码是 Netty 的一个例子, 其源码在 netty/example/src/main/java/io/netty/example/file/FileServerHandler.java\n可以看到, 第一步是通过 RandomAccessFile 打开一个文件, 然后 Netty 使用了 DefaultFileRegion 来封装一个 FileChannel 即:\n```\nnew DefaultFileRegion(raf.getChannel(), 0, length)\n```\n当有了 FileRegion 后, 我们就可以直接通过它将文件的内容直接写入 Channel 中, 而不需要像传统的做法: 拷贝文件内容到临时 buffer, 然后再将 buffer 写入 Channel. 通过这样的零拷贝操作, 无疑对传输大文件很有帮助.\n\n转载出处：https://www.cnblogs.com/xys1228/p/6088805.html\n","slug":"zero-copy","published":1,"updated":"2018-08-20T01:06:16.237Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlqdfcwp000aowv3oog27ofq","content":"<p>根据 Wiki 对 Zero-copy 的定义:</p>\n<blockquote>\n<p>“Zero-copy” describes computer operations in which the CPU does not perform the task of copying data from one memory area to another. This is frequently used to save CPU cycles and memory bandwidth when transmitting a file over a network.</p>\n</blockquote>\n<p>即所谓的 Zero-copy, 就是在操作数据时, 不需要将数据 buffer 从一个内存区域拷贝到另一个内存区域. 因为少了一次内存的拷贝, 因此 CPU 的效率就得到的提升.</p>\n<p>在 OS 层面上的 Zero-copy 通常指避免在 用户态(User-space) 与 内核态(Kernel-space) 之间来回拷贝数据. 例如 Linux 提供的 mmap 系统调用, 它可以将一段用户空间内存映射到内核空间, 当映射成功后, 用户对这段内存区域的修改可以直接反映到内核空间; 同样地, 内核空间对这段区域的修改也直接反映用户空间. 正因为有这样的映射关系, 我们就不需要在 用户态(User-space) 与 内核态(Kernel-space) 之间拷贝数据, 提高了数据传输的效率.</p>\n<p>而需要注意的是, Netty 中的 Zero-copy 与上面我们所提到到 OS 层面上的 Zero-copy 不太一样, Netty的 Zero-coyp 完全是在用户态(Java 层面)的, 它的 Zero-copy 的更多的是偏向于 优化数据操作 这样的概念.</p>\n<p>Netty 的 Zero-copy 体现在如下几个个方面:</p>\n<ul>\n<li>Netty 提供了 CompositeByteBuf 类, 它可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf, 避免了各个 ByteBuf 之间的拷贝.</li>\n<li>通过 wrap 操作, 我们可以将 byte[] 数组、ByteBuf、ByteBuffer等包装成一个 Netty ByteBuf 对象, 进而避免了拷贝操作.</li>\n<li>ByteBuf 支持 slice 操作, 因此可以将 ByteBuf 分解为多个共享同一个存储区域的 ByteBuf, 避免了内存的拷贝.</li>\n<li>通过 FileRegion 包装的FileChannel.tranferTo 实现文件传输, 可以直接将文件缓冲区的数据发送到目标 Channel, 避免了传统通过循环 write 方式导致的内存拷贝问题.</li>\n</ul>\n<p>下面我们就来简单了解一下这几种常见的零拷贝操作.</p>\n<a id=\"more\"></a>\n<h1 id=\"通过-CompositeByteBuf-实现零拷贝\"><a href=\"#通过-CompositeByteBuf-实现零拷贝\" class=\"headerlink\" title=\"通过 CompositeByteBuf 实现零拷贝\"></a>通过 CompositeByteBuf 实现零拷贝</h1><p>假设我们有一份协议数据, 它由头部和消息体组成, 而头部和消息体是分别存放在两个 ByteBuf 中的, 即:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ByteBuf header = ...</span><br><span class=\"line\">ByteBuf body = ...</span><br></pre></td></tr></table></figure></p>\n<p>我们在代码处理中, 通常希望将 header 和 body 合并为一个 ByteBuf, 方便处理, 那么通常的做法是:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ByteBuf allBuf = Unpooled.buffer(header.readableBytes() + body.readableBytes());</span><br><span class=\"line\">allBuf.writeBytes(header);</span><br><span class=\"line\">allBuf.writeBytes(body);</span><br></pre></td></tr></table></figure></p>\n<p>可以看到, 我们将 header 和 body 都拷贝到了新的 allBuf 中了, 这无形中增加了两次额外的数据拷贝操作了.</p>\n<p>那么有没有更加高效优雅的方式实现相同的目的呢? 我们来看一下 CompositeByteBuf 是如何实现这样的需求的吧.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ByteBuf header = ...</span><br><span class=\"line\">ByteBuf body = ...</span><br><span class=\"line\"></span><br><span class=\"line\">CompositeByteBuf compositeByteBuf = Unpooled.compositeBuffer();</span><br><span class=\"line\">compositeByteBuf.addComponents(true, header, body);</span><br></pre></td></tr></table></figure></p>\n<p>上面代码中, 我们定义了一个 CompositeByteBuf 对象, 然后调用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public CompositeByteBuf addComponents(boolean increaseWriterIndex, ByteBuf... buffers) &#123;</span><br><span class=\"line\">...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>不过需要注意的是, 虽然看起来 CompositeByteBuf 是由两个 ByteBuf 组合而成的, 不过在 CompositeByteBuf 内部, 这两个 ByteBuf 都是单独存在的, CompositeByteBuf 只是逻辑上是一个整体.</p>\n<p>上面 CompositeByteBuf 代码还以一个地方值得注意的是, 我们调用 addComponents(boolean increaseWriterIndex, ByteBuf… buffers) 来添加两个 ByteBuf, 其中第一个参数是 true, 表示当添加新的 ByteBuf 时, 自动递增 CompositeByteBuf 的 writeIndex.<br>如果我们调用的是<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compositeByteBuf.addComponents(header, body);</span><br></pre></td></tr></table></figure></p>\n<p>那么其实 compositeByteBuf 的 writeIndex 仍然是0, 因此此时我们就不可能从 compositeByteBuf 中读取到数据, 这一点希望大家要特别注意.</p>\n<p>除了上面直接使用 CompositeByteBuf 类外, 我们还可以使用 Unpooled.wrappedBuffer 方法, 它底层封装了 CompositeByteBuf 操作, 因此使用起来更加方便:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ByteBuf header = ...</span><br><span class=\"line\">ByteBuf body = ...</span><br><span class=\"line\"></span><br><span class=\"line\">ByteBuf allByteBuf = Unpooled.wrappedBuffer(header, body);</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"通过-wrap-操作实现零拷贝\"><a href=\"#通过-wrap-操作实现零拷贝\" class=\"headerlink\" title=\"通过 wrap 操作实现零拷贝\"></a>通过 wrap 操作实现零拷贝</h1><p>例如我们有一个 byte 数组, 我们希望将它转换为一个 ByteBuf 对象, 以便于后续的操作, 那么传统的做法是将此 byte 数组拷贝到 ByteBuf 中, 即:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">byte[] bytes = ...</span><br><span class=\"line\">ByteBuf byteBuf = Unpooled.buffer();</span><br><span class=\"line\">byteBuf.writeBytes(bytes);</span><br></pre></td></tr></table></figure></p>\n<p>显然这样的方式也是有一个额外的拷贝操作的, 我们可以使用 Unpooled 的相关方法, 包装这个 byte 数组, 生成一个新的 ByteBuf 实例, 而不需要进行拷贝操作. 上面的代码可以改为:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">byte[] bytes = ...</span><br><span class=\"line\">ByteBuf byteBuf = Unpooled.wrappedBuffer(bytes);</span><br></pre></td></tr></table></figure></p>\n<p>可以看到, 我们通过 Unpooled.wrappedBuffer 方法来将 bytes 包装成为一个 UnpooledHeapByteBuf 对象, 而在包装的过程中, 是不会有拷贝操作的. 即最后我们生成的生成的 ByteBuf 对象是和 bytes 数组共用了同一个存储空间, 对 bytes 的修改也会反映到 ByteBuf 对象中.</p>\n<p>Unpooled 工具类还提供了很多重载的 wrappedBuffer 方法:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static ByteBuf wrappedBuffer(byte[] array)</span><br><span class=\"line\">public static ByteBuf wrappedBuffer(byte[] array, int offset, int length)</span><br><span class=\"line\"></span><br><span class=\"line\">public static ByteBuf wrappedBuffer(ByteBuffer buffer)</span><br><span class=\"line\">public static ByteBuf wrappedBuffer(ByteBuf buffer)</span><br><span class=\"line\"></span><br><span class=\"line\">public static ByteBuf wrappedBuffer(byte[]... arrays)</span><br><span class=\"line\">public static ByteBuf wrappedBuffer(ByteBuf... buffers)</span><br><span class=\"line\">public static ByteBuf wrappedBuffer(ByteBuffer... buffers)</span><br><span class=\"line\"></span><br><span class=\"line\">public static ByteBuf wrappedBuffer(int maxNumComponents, byte[]... arrays)</span><br><span class=\"line\">public static ByteBuf wrappedBuffer(int maxNumComponents, ByteBuf... buffers)</span><br><span class=\"line\">public static ByteBuf wrappedBuffer(int maxNumComponents, ByteBuffer... buffers)</span><br></pre></td></tr></table></figure></p>\n<p>这些方法可以将一个或多个 buffer 包装为一个 ByteBuf 对象, 从而避免了拷贝操作.</p>\n<h1 id=\"通过-slice-操作实现零拷贝\"><a href=\"#通过-slice-操作实现零拷贝\" class=\"headerlink\" title=\"通过 slice 操作实现零拷贝\"></a>通过 slice 操作实现零拷贝</h1><p>slice 操作和 wrap 操作刚好相反, Unpooled.wrappedBuffer 可以将多个 ByteBuf 合并为一个, 而 slice 操作可以将一个 ByteBuf 切片 为多个共享一个存储区域的 ByteBuf 对象.</p>\n<p>ByteBuf 提供了两个 slice 操作方法:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public ByteBuf slice();</span><br><span class=\"line\">public ByteBuf slice(int index, int length);</span><br></pre></td></tr></table></figure></p>\n<p>不带参数的 slice 方法等同于 buf.slice(buf.readerIndex(), buf.readableBytes()) 调用, 即返回 buf 中可读部分的切片. 而 slice(int index, int length) 方法相对就比较灵活了, 我们可以设置不同的参数来获取到 buf 的不同区域的切片.</p>\n<p>下面的例子展示了 ByteBuf.slice 方法的简单用法:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ByteBuf byteBuf = ...</span><br><span class=\"line\">ByteBuf header = byteBuf.slice(0, 5);</span><br><span class=\"line\">ByteBuf body = byteBuf.slice(5, 10);</span><br></pre></td></tr></table></figure></p>\n<p>用 slice 方法产生 header 和 body 的过程是没有拷贝操作的, header 和 body 对象在内部其实是共享了 byteBuf 存储空间的不同部分而已.</p>\n<h1 id=\"通过-FileRegion-实现零拷贝\"><a href=\"#通过-FileRegion-实现零拷贝\" class=\"headerlink\" title=\"通过 FileRegion 实现零拷贝\"></a>通过 FileRegion 实现零拷贝</h1><p>Netty 中使用 FileRegion 实现文件传输的零拷贝, 不过在底层 FileRegion 是依赖于 Java NIO FileChannel.transfer 的零拷贝功能.</p>\n<p>首先我们从最基础的 Java IO 开始吧. 假设我们希望实现一个文件拷贝的功能, 那么使用传统的方式, 我们有如下实现:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void copyFile(String srcFile, String destFile) throws Exception &#123;</span><br><span class=\"line\">    byte[] temp = new byte[1024];</span><br><span class=\"line\">    FileInputStream in = new FileInputStream(srcFile);</span><br><span class=\"line\">    FileOutputStream out = new FileOutputStream(destFile);</span><br><span class=\"line\">    int length;</span><br><span class=\"line\">    while ((length = in.read(temp)) != -1) &#123;</span><br><span class=\"line\">        out.write(temp, 0, length);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    in.close();</span><br><span class=\"line\">    out.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面是一个典型的读写二进制文件的代码实现了. 不用我说, 大家肯定都知道, 上面的代码中不断中源文件中读取定长数据到 temp 数组中, 然后再将 temp 中的内容写入目的文件, 这样的拷贝操作对于小文件倒是没有太大的影响, 但是如果我们需要拷贝大文件时, 频繁的内存拷贝操作就消耗大量的系统资源了.</p>\n<p>下面我们来看一下使用 Java NIO 的 FileChannel 是如何实现零拷贝的:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void copyFileWithFileChannel(String srcFileName, String destFileName) throws Exception &#123;</span><br><span class=\"line\">    RandomAccessFile srcFile = new RandomAccessFile(srcFileName, &quot;r&quot;);</span><br><span class=\"line\">    FileChannel srcFileChannel = srcFile.getChannel();</span><br><span class=\"line\"></span><br><span class=\"line\">    RandomAccessFile destFile = new RandomAccessFile(destFileName, &quot;rw&quot;);</span><br><span class=\"line\">    FileChannel destFileChannel = destFile.getChannel();</span><br><span class=\"line\"></span><br><span class=\"line\">    long position = 0;</span><br><span class=\"line\">    long count = srcFileChannel.size();</span><br><span class=\"line\"></span><br><span class=\"line\">    srcFileChannel.transferTo(position, count, destFileChannel);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到, 使用了 FileChannel 后, 我们就可以直接将源文件的内容直接拷贝(transferTo) 到目的文件中, 而不需要额外借助一个临时 buffer, 避免了不必要的内存操作.</p>\n<p>有了上面的一些理论知识, 我们来看一下在 Netty 中是怎么使用 FileRegion 来实现零拷贝传输一个文件的:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public void channelRead0(ChannelHandlerContext ctx, String msg) throws Exception &#123;</span><br><span class=\"line\">    RandomAccessFile raf = null;</span><br><span class=\"line\">    long length = -1;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        // 1. 通过 RandomAccessFile 打开一个文件.</span><br><span class=\"line\">        raf = new RandomAccessFile(msg, &quot;r&quot;);</span><br><span class=\"line\">        length = raf.length();</span><br><span class=\"line\">    &#125; catch (Exception e) &#123;</span><br><span class=\"line\">        ctx.writeAndFlush(&quot;ERR: &quot; + e.getClass().getSimpleName() + &quot;: &quot; + e.getMessage() + &apos;\\n&apos;);</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125; finally &#123;</span><br><span class=\"line\">        if (length &lt; 0 &amp;&amp; raf != null) &#123;</span><br><span class=\"line\">            raf.close();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ctx.write(&quot;OK: &quot; + raf.length() + &apos;\\n&apos;);</span><br><span class=\"line\">    if (ctx.pipeline().get(SslHandler.class) == null) &#123;</span><br><span class=\"line\">        // SSL not enabled - can use zero-copy file transfer.</span><br><span class=\"line\">        // 2. 调用 raf.getChannel() 获取一个 FileChannel.</span><br><span class=\"line\">        // 3. 将 FileChannel 封装成一个 DefaultFileRegion</span><br><span class=\"line\">        ctx.write(new DefaultFileRegion(raf.getChannel(), 0, length));</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        // SSL enabled - cannot use zero-copy file transfer.</span><br><span class=\"line\">        ctx.write(new ChunkedFile(raf));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ctx.writeAndFlush(&quot;\\n&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面的代码是 Netty 的一个例子, 其源码在 netty/example/src/main/java/io/netty/example/file/FileServerHandler.java<br>可以看到, 第一步是通过 RandomAccessFile 打开一个文件, 然后 Netty 使用了 DefaultFileRegion 来封装一个 FileChannel 即:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new DefaultFileRegion(raf.getChannel(), 0, length)</span><br></pre></td></tr></table></figure></p>\n<p>当有了 FileRegion 后, 我们就可以直接通过它将文件的内容直接写入 Channel 中, 而不需要像传统的做法: 拷贝文件内容到临时 buffer, 然后再将 buffer 写入 Channel. 通过这样的零拷贝操作, 无疑对传输大文件很有帮助.</p>\n<p>转载出处：<a href=\"https://www.cnblogs.com/xys1228/p/6088805.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/xys1228/p/6088805.html</a></p>\n","site":{"data":{}},"excerpt":"<p>根据 Wiki 对 Zero-copy 的定义:</p>\n<blockquote>\n<p>“Zero-copy” describes computer operations in which the CPU does not perform the task of copying data from one memory area to another. This is frequently used to save CPU cycles and memory bandwidth when transmitting a file over a network.</p>\n</blockquote>\n<p>即所谓的 Zero-copy, 就是在操作数据时, 不需要将数据 buffer 从一个内存区域拷贝到另一个内存区域. 因为少了一次内存的拷贝, 因此 CPU 的效率就得到的提升.</p>\n<p>在 OS 层面上的 Zero-copy 通常指避免在 用户态(User-space) 与 内核态(Kernel-space) 之间来回拷贝数据. 例如 Linux 提供的 mmap 系统调用, 它可以将一段用户空间内存映射到内核空间, 当映射成功后, 用户对这段内存区域的修改可以直接反映到内核空间; 同样地, 内核空间对这段区域的修改也直接反映用户空间. 正因为有这样的映射关系, 我们就不需要在 用户态(User-space) 与 内核态(Kernel-space) 之间拷贝数据, 提高了数据传输的效率.</p>\n<p>而需要注意的是, Netty 中的 Zero-copy 与上面我们所提到到 OS 层面上的 Zero-copy 不太一样, Netty的 Zero-coyp 完全是在用户态(Java 层面)的, 它的 Zero-copy 的更多的是偏向于 优化数据操作 这样的概念.</p>\n<p>Netty 的 Zero-copy 体现在如下几个个方面:</p>\n<ul>\n<li>Netty 提供了 CompositeByteBuf 类, 它可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf, 避免了各个 ByteBuf 之间的拷贝.</li>\n<li>通过 wrap 操作, 我们可以将 byte[] 数组、ByteBuf、ByteBuffer等包装成一个 Netty ByteBuf 对象, 进而避免了拷贝操作.</li>\n<li>ByteBuf 支持 slice 操作, 因此可以将 ByteBuf 分解为多个共享同一个存储区域的 ByteBuf, 避免了内存的拷贝.</li>\n<li>通过 FileRegion 包装的FileChannel.tranferTo 实现文件传输, 可以直接将文件缓冲区的数据发送到目标 Channel, 避免了传统通过循环 write 方式导致的内存拷贝问题.</li>\n</ul>\n<p>下面我们就来简单了解一下这几种常见的零拷贝操作.</p>","more":"<h1 id=\"通过-CompositeByteBuf-实现零拷贝\"><a href=\"#通过-CompositeByteBuf-实现零拷贝\" class=\"headerlink\" title=\"通过 CompositeByteBuf 实现零拷贝\"></a>通过 CompositeByteBuf 实现零拷贝</h1><p>假设我们有一份协议数据, 它由头部和消息体组成, 而头部和消息体是分别存放在两个 ByteBuf 中的, 即:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ByteBuf header = ...</span><br><span class=\"line\">ByteBuf body = ...</span><br></pre></td></tr></table></figure></p>\n<p>我们在代码处理中, 通常希望将 header 和 body 合并为一个 ByteBuf, 方便处理, 那么通常的做法是:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ByteBuf allBuf = Unpooled.buffer(header.readableBytes() + body.readableBytes());</span><br><span class=\"line\">allBuf.writeBytes(header);</span><br><span class=\"line\">allBuf.writeBytes(body);</span><br></pre></td></tr></table></figure></p>\n<p>可以看到, 我们将 header 和 body 都拷贝到了新的 allBuf 中了, 这无形中增加了两次额外的数据拷贝操作了.</p>\n<p>那么有没有更加高效优雅的方式实现相同的目的呢? 我们来看一下 CompositeByteBuf 是如何实现这样的需求的吧.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ByteBuf header = ...</span><br><span class=\"line\">ByteBuf body = ...</span><br><span class=\"line\"></span><br><span class=\"line\">CompositeByteBuf compositeByteBuf = Unpooled.compositeBuffer();</span><br><span class=\"line\">compositeByteBuf.addComponents(true, header, body);</span><br></pre></td></tr></table></figure></p>\n<p>上面代码中, 我们定义了一个 CompositeByteBuf 对象, 然后调用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public CompositeByteBuf addComponents(boolean increaseWriterIndex, ByteBuf... buffers) &#123;</span><br><span class=\"line\">...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>不过需要注意的是, 虽然看起来 CompositeByteBuf 是由两个 ByteBuf 组合而成的, 不过在 CompositeByteBuf 内部, 这两个 ByteBuf 都是单独存在的, CompositeByteBuf 只是逻辑上是一个整体.</p>\n<p>上面 CompositeByteBuf 代码还以一个地方值得注意的是, 我们调用 addComponents(boolean increaseWriterIndex, ByteBuf… buffers) 来添加两个 ByteBuf, 其中第一个参数是 true, 表示当添加新的 ByteBuf 时, 自动递增 CompositeByteBuf 的 writeIndex.<br>如果我们调用的是<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compositeByteBuf.addComponents(header, body);</span><br></pre></td></tr></table></figure></p>\n<p>那么其实 compositeByteBuf 的 writeIndex 仍然是0, 因此此时我们就不可能从 compositeByteBuf 中读取到数据, 这一点希望大家要特别注意.</p>\n<p>除了上面直接使用 CompositeByteBuf 类外, 我们还可以使用 Unpooled.wrappedBuffer 方法, 它底层封装了 CompositeByteBuf 操作, 因此使用起来更加方便:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ByteBuf header = ...</span><br><span class=\"line\">ByteBuf body = ...</span><br><span class=\"line\"></span><br><span class=\"line\">ByteBuf allByteBuf = Unpooled.wrappedBuffer(header, body);</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"通过-wrap-操作实现零拷贝\"><a href=\"#通过-wrap-操作实现零拷贝\" class=\"headerlink\" title=\"通过 wrap 操作实现零拷贝\"></a>通过 wrap 操作实现零拷贝</h1><p>例如我们有一个 byte 数组, 我们希望将它转换为一个 ByteBuf 对象, 以便于后续的操作, 那么传统的做法是将此 byte 数组拷贝到 ByteBuf 中, 即:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">byte[] bytes = ...</span><br><span class=\"line\">ByteBuf byteBuf = Unpooled.buffer();</span><br><span class=\"line\">byteBuf.writeBytes(bytes);</span><br></pre></td></tr></table></figure></p>\n<p>显然这样的方式也是有一个额外的拷贝操作的, 我们可以使用 Unpooled 的相关方法, 包装这个 byte 数组, 生成一个新的 ByteBuf 实例, 而不需要进行拷贝操作. 上面的代码可以改为:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">byte[] bytes = ...</span><br><span class=\"line\">ByteBuf byteBuf = Unpooled.wrappedBuffer(bytes);</span><br></pre></td></tr></table></figure></p>\n<p>可以看到, 我们通过 Unpooled.wrappedBuffer 方法来将 bytes 包装成为一个 UnpooledHeapByteBuf 对象, 而在包装的过程中, 是不会有拷贝操作的. 即最后我们生成的生成的 ByteBuf 对象是和 bytes 数组共用了同一个存储空间, 对 bytes 的修改也会反映到 ByteBuf 对象中.</p>\n<p>Unpooled 工具类还提供了很多重载的 wrappedBuffer 方法:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static ByteBuf wrappedBuffer(byte[] array)</span><br><span class=\"line\">public static ByteBuf wrappedBuffer(byte[] array, int offset, int length)</span><br><span class=\"line\"></span><br><span class=\"line\">public static ByteBuf wrappedBuffer(ByteBuffer buffer)</span><br><span class=\"line\">public static ByteBuf wrappedBuffer(ByteBuf buffer)</span><br><span class=\"line\"></span><br><span class=\"line\">public static ByteBuf wrappedBuffer(byte[]... arrays)</span><br><span class=\"line\">public static ByteBuf wrappedBuffer(ByteBuf... buffers)</span><br><span class=\"line\">public static ByteBuf wrappedBuffer(ByteBuffer... buffers)</span><br><span class=\"line\"></span><br><span class=\"line\">public static ByteBuf wrappedBuffer(int maxNumComponents, byte[]... arrays)</span><br><span class=\"line\">public static ByteBuf wrappedBuffer(int maxNumComponents, ByteBuf... buffers)</span><br><span class=\"line\">public static ByteBuf wrappedBuffer(int maxNumComponents, ByteBuffer... buffers)</span><br></pre></td></tr></table></figure></p>\n<p>这些方法可以将一个或多个 buffer 包装为一个 ByteBuf 对象, 从而避免了拷贝操作.</p>\n<h1 id=\"通过-slice-操作实现零拷贝\"><a href=\"#通过-slice-操作实现零拷贝\" class=\"headerlink\" title=\"通过 slice 操作实现零拷贝\"></a>通过 slice 操作实现零拷贝</h1><p>slice 操作和 wrap 操作刚好相反, Unpooled.wrappedBuffer 可以将多个 ByteBuf 合并为一个, 而 slice 操作可以将一个 ByteBuf 切片 为多个共享一个存储区域的 ByteBuf 对象.</p>\n<p>ByteBuf 提供了两个 slice 操作方法:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public ByteBuf slice();</span><br><span class=\"line\">public ByteBuf slice(int index, int length);</span><br></pre></td></tr></table></figure></p>\n<p>不带参数的 slice 方法等同于 buf.slice(buf.readerIndex(), buf.readableBytes()) 调用, 即返回 buf 中可读部分的切片. 而 slice(int index, int length) 方法相对就比较灵活了, 我们可以设置不同的参数来获取到 buf 的不同区域的切片.</p>\n<p>下面的例子展示了 ByteBuf.slice 方法的简单用法:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ByteBuf byteBuf = ...</span><br><span class=\"line\">ByteBuf header = byteBuf.slice(0, 5);</span><br><span class=\"line\">ByteBuf body = byteBuf.slice(5, 10);</span><br></pre></td></tr></table></figure></p>\n<p>用 slice 方法产生 header 和 body 的过程是没有拷贝操作的, header 和 body 对象在内部其实是共享了 byteBuf 存储空间的不同部分而已.</p>\n<h1 id=\"通过-FileRegion-实现零拷贝\"><a href=\"#通过-FileRegion-实现零拷贝\" class=\"headerlink\" title=\"通过 FileRegion 实现零拷贝\"></a>通过 FileRegion 实现零拷贝</h1><p>Netty 中使用 FileRegion 实现文件传输的零拷贝, 不过在底层 FileRegion 是依赖于 Java NIO FileChannel.transfer 的零拷贝功能.</p>\n<p>首先我们从最基础的 Java IO 开始吧. 假设我们希望实现一个文件拷贝的功能, 那么使用传统的方式, 我们有如下实现:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void copyFile(String srcFile, String destFile) throws Exception &#123;</span><br><span class=\"line\">    byte[] temp = new byte[1024];</span><br><span class=\"line\">    FileInputStream in = new FileInputStream(srcFile);</span><br><span class=\"line\">    FileOutputStream out = new FileOutputStream(destFile);</span><br><span class=\"line\">    int length;</span><br><span class=\"line\">    while ((length = in.read(temp)) != -1) &#123;</span><br><span class=\"line\">        out.write(temp, 0, length);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    in.close();</span><br><span class=\"line\">    out.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面是一个典型的读写二进制文件的代码实现了. 不用我说, 大家肯定都知道, 上面的代码中不断中源文件中读取定长数据到 temp 数组中, 然后再将 temp 中的内容写入目的文件, 这样的拷贝操作对于小文件倒是没有太大的影响, 但是如果我们需要拷贝大文件时, 频繁的内存拷贝操作就消耗大量的系统资源了.</p>\n<p>下面我们来看一下使用 Java NIO 的 FileChannel 是如何实现零拷贝的:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void copyFileWithFileChannel(String srcFileName, String destFileName) throws Exception &#123;</span><br><span class=\"line\">    RandomAccessFile srcFile = new RandomAccessFile(srcFileName, &quot;r&quot;);</span><br><span class=\"line\">    FileChannel srcFileChannel = srcFile.getChannel();</span><br><span class=\"line\"></span><br><span class=\"line\">    RandomAccessFile destFile = new RandomAccessFile(destFileName, &quot;rw&quot;);</span><br><span class=\"line\">    FileChannel destFileChannel = destFile.getChannel();</span><br><span class=\"line\"></span><br><span class=\"line\">    long position = 0;</span><br><span class=\"line\">    long count = srcFileChannel.size();</span><br><span class=\"line\"></span><br><span class=\"line\">    srcFileChannel.transferTo(position, count, destFileChannel);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到, 使用了 FileChannel 后, 我们就可以直接将源文件的内容直接拷贝(transferTo) 到目的文件中, 而不需要额外借助一个临时 buffer, 避免了不必要的内存操作.</p>\n<p>有了上面的一些理论知识, 我们来看一下在 Netty 中是怎么使用 FileRegion 来实现零拷贝传输一个文件的:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public void channelRead0(ChannelHandlerContext ctx, String msg) throws Exception &#123;</span><br><span class=\"line\">    RandomAccessFile raf = null;</span><br><span class=\"line\">    long length = -1;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        // 1. 通过 RandomAccessFile 打开一个文件.</span><br><span class=\"line\">        raf = new RandomAccessFile(msg, &quot;r&quot;);</span><br><span class=\"line\">        length = raf.length();</span><br><span class=\"line\">    &#125; catch (Exception e) &#123;</span><br><span class=\"line\">        ctx.writeAndFlush(&quot;ERR: &quot; + e.getClass().getSimpleName() + &quot;: &quot; + e.getMessage() + &apos;\\n&apos;);</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125; finally &#123;</span><br><span class=\"line\">        if (length &lt; 0 &amp;&amp; raf != null) &#123;</span><br><span class=\"line\">            raf.close();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ctx.write(&quot;OK: &quot; + raf.length() + &apos;\\n&apos;);</span><br><span class=\"line\">    if (ctx.pipeline().get(SslHandler.class) == null) &#123;</span><br><span class=\"line\">        // SSL not enabled - can use zero-copy file transfer.</span><br><span class=\"line\">        // 2. 调用 raf.getChannel() 获取一个 FileChannel.</span><br><span class=\"line\">        // 3. 将 FileChannel 封装成一个 DefaultFileRegion</span><br><span class=\"line\">        ctx.write(new DefaultFileRegion(raf.getChannel(), 0, length));</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        // SSL enabled - cannot use zero-copy file transfer.</span><br><span class=\"line\">        ctx.write(new ChunkedFile(raf));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ctx.writeAndFlush(&quot;\\n&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面的代码是 Netty 的一个例子, 其源码在 netty/example/src/main/java/io/netty/example/file/FileServerHandler.java<br>可以看到, 第一步是通过 RandomAccessFile 打开一个文件, 然后 Netty 使用了 DefaultFileRegion 来封装一个 FileChannel 即:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new DefaultFileRegion(raf.getChannel(), 0, length)</span><br></pre></td></tr></table></figure></p>\n<p>当有了 FileRegion 后, 我们就可以直接通过它将文件的内容直接写入 Channel 中, 而不需要像传统的做法: 拷贝文件内容到临时 buffer, 然后再将 buffer 写入 Channel. 通过这样的零拷贝操作, 无疑对传输大文件很有帮助.</p>\n<p>转载出处：<a href=\"https://www.cnblogs.com/xys1228/p/6088805.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/xys1228/p/6088805.html</a></p>"},{"title":"Docker备忘录","date":"2018-07-16T02:08:18.000Z","_content":"\n> 删除全部image的话\n\ndocker rmi $(docker images -q)\n\n> 删除全部container\n\ndocker rm $(docker ps -aq)\n\n<!-- more -->\n\n>boot2docker用户和密码\n\n\n用户名 | 密码 | 进入方式\n---|---|---\ndocker | tcuser | ssh\nroot | 空 | command：sudo -i (docker用户下执行)\n\n> zookeeper docker运行命令\n\ndocker pull zookeeper\n\ndocker run --name zookeeper-1 --restart always -d zookeeper\n\ndocker exec -it 容器id zkCli.sh ","source":"_posts/docker.md","raw":"---\ntitle: Docker备忘录\ndate: 2018-07-16 10:08:18\ntags: Docker\n---\n\n> 删除全部image的话\n\ndocker rmi $(docker images -q)\n\n> 删除全部container\n\ndocker rm $(docker ps -aq)\n\n<!-- more -->\n\n>boot2docker用户和密码\n\n\n用户名 | 密码 | 进入方式\n---|---|---\ndocker | tcuser | ssh\nroot | 空 | command：sudo -i (docker用户下执行)\n\n> zookeeper docker运行命令\n\ndocker pull zookeeper\n\ndocker run --name zookeeper-1 --restart always -d zookeeper\n\ndocker exec -it 容器id zkCli.sh ","slug":"docker","published":1,"updated":"2018-07-20T09:30:25.763Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlqdfcws000cowv3sjhcafa6","content":"<blockquote>\n<p>删除全部image的话</p>\n</blockquote>\n<p>docker rmi $(docker images -q)</p>\n<blockquote>\n<p>删除全部container</p>\n</blockquote>\n<p>docker rm $(docker ps -aq)</p>\n<a id=\"more\"></a>\n<blockquote>\n<p>boot2docker用户和密码</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>用户名</th>\n<th>密码</th>\n<th>进入方式</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>docker</td>\n<td>tcuser</td>\n<td>ssh</td>\n</tr>\n<tr>\n<td>root</td>\n<td>空</td>\n<td>command：sudo -i (docker用户下执行)</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>zookeeper docker运行命令</p>\n</blockquote>\n<p>docker pull zookeeper</p>\n<p>docker run –name zookeeper-1 –restart always -d zookeeper</p>\n<p>docker exec -it 容器id zkCli.sh </p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>删除全部image的话</p>\n</blockquote>\n<p>docker rmi $(docker images -q)</p>\n<blockquote>\n<p>删除全部container</p>\n</blockquote>\n<p>docker rm $(docker ps -aq)</p>","more":"<blockquote>\n<p>boot2docker用户和密码</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>用户名</th>\n<th>密码</th>\n<th>进入方式</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>docker</td>\n<td>tcuser</td>\n<td>ssh</td>\n</tr>\n<tr>\n<td>root</td>\n<td>空</td>\n<td>command：sudo -i (docker用户下执行)</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>zookeeper docker运行命令</p>\n</blockquote>\n<p>docker pull zookeeper</p>\n<p>docker run –name zookeeper-1 –restart always -d zookeeper</p>\n<p>docker exec -it 容器id zkCli.sh </p>"},{"title":"RUN vs CMD vs ENTRYPOINT","date":"2018-08-17T01:14:42.000Z","_content":"\nRUN、CMD 和 ENTRYPOINT 这三个 Dockerfile 指令看上去很类似，很容易混淆。本节将通过实践详细讨论它们的区别。\n\n简单的说：\n1. RUN 执行命令并创建新的镜像层，RUN 经常用于安装软件包。\n2. CMD 设置容器启动后默认执行的命令及其参数，但 CMD 能够被 docker run 后面跟的命令行参数替换。\n3. ENTRYPOINT 配置容器启动时运行的命令。\n\n下面我们详细分析。\n\n<!-- more -->\n\n# Shell 和 Exec 格式\n我们可用两种方式指定 RUN、CMD 和 ENTRYPOINT 要运行的命令：Shell 格式和 Exec 格式，二者在使用上有细微的区别。\n\n==Shell 格式 <instruction> <command>==\n\n例如：\n- RUN apt-get install python3  \n- CMD echo \"Hello world\"  \n- ENTRYPOINT echo \"Hello world\" \n\n当指令执行时，shell 格式底层会调用 ==/bin/sh -c <command>==\n\n例如下面的 Dockerfile 片段：\n\n```\nENV name Cloud Man  \n\nENTRYPOINT echo \"Hello, $name\"\n```\n\n执行 docker run <image> 将输出：Hello, Cloud Man\n\n注意环境变量 name 已经被值 Cloud Man 替换\n\n==Exec 格式 <instruction> [\"executable\", \"param1\", \"param2\", ...]==\n\n例如：\n- RUN [\"apt-get\", \"install\", \"python3\"]\n- CMD [\"/bin/echo\", \"Hello world\"]  \n- ENTRYPOINT [\"/bin/echo\", \"Hello world\"]\n\n当指令执行时，会直接调用 <command>，不会被 shell 解析\n\n例如下面的 Dockerfile 片段：\n\n```\nENV name Cloud Man  \n\nENTRYPOINT [\"/bin/echo\", \"Hello, $name\"]\n```\n\n运行容器将输出：Hello, $name\n\n注意环境变量“name”没有被替换，如果希望使用环境变量，照如下修改\n```\nENV name Cloud Man  \n\nENTRYPOINT [\"/bin/sh\", \"-c\", \"echo Hello, $name\"]\n```\n运行容器将输出：Hello, Cloud Man\n\n==CMD 和 ENTRYPOINT 推荐使用 Exec 格式，因为指令可读性更强，更容易理解。RUN 则两种格式都可以。==\n\n# RUN\n\nRUN 指令通常用于安装应用和软件包。\n\nRUN 在当前镜像的顶部执行命令，并通过创建新的镜像层。Dockerfile 中常常包含多个 RUN 指令。\n\nRUN 有两种格式：\n1. Shell 格式：RUN\n2. Exec 格式：RUN [\"executable\", \"param1\", \"param2\"]\n\n下面是使用 RUN 安装多个包的例子：\n```\n bzr \\\n\n cvs \\\n\n git \\\n\n mercurial \\\n\n subversion\n```\n注意：apt-get update 和 apt-get install 被放在一个 RUN 指令中执行，这样能够保证每次安装的是最新的包。如果 apt-get install 在单独的 RUN 中执行，则会使用 apt-get update 创建的镜像层，而这一层可能是很久以前缓存的。\n\n# CMD\nCMD 指令允许用户指定容器的默认执行的命令\n此命令会在容器启动且 docker run 没有指定其他命令时运行。\n1. 如果 docker run 指定了其他命令，CMD 指定的默认命令将被忽略。\n2. 如果 Dockerfile 中有多个 CMD 指令，只有最后一个 CMD 有效。\n\nCMD 有三种格式：\n1. Exec 格式：==CMD [\"executable\",\"param1\",\"param2\"]== 这是 CMD 的推荐格式。\n2. ==CMD [\"param1\",\"param2\"]== 为 ENTRYPOINT 提供额外的参数，此时 ENTRYPOINT 必须使用 Exec 格式。\n3. Shell 格式：==CMD command param1 param2==\n\nExec 和 Shell 格式前面已经介绍过了。第二种格式 CMD [\"param1\",\"param2\"] 要与 Exec 格式 的 ENTRYPOINT 指令配合使用，其用途是为 ENTRYPOINT 设置默认的参数。我们将在后面讨论 ENTRYPOINT 时举例说明。\n\n下面看看 CMD 是如何工作的。Dockerfile 片段如下：\n```\nCMD echo \"Hello world\"\n```\n运行容器 docker run -it [image] 将输出：\n```\nHello world\n```\n但当后面加上一个命令，比如 docker run -it [image] /bin/bash，CMD 会被忽略掉，命令 bash 将被执行：\n```\nroot@10a32dc7d3d3:/#\n```\n# ENTRYPOINT\nENTRYPOINT 指令可让容器以应用程序或者服务的形式运行。\n\nENTRYPOINT 看上去与 CMD 很像，它们都可以指定要执行的命令及其参数。不同的地方在于 ENTRYPOINT 不会被忽略，一定会被执行，即使运行 docker run 时指定了其他命令。\n\nENTRYPOINT 有两种格式：\n1. Exec 格式：==ENTRYPOINT [\"executable\", \"param1\", \"param2\"]== 这是 ENTRYPOINT 的推荐格式。\n2. Shell 格式：==ENTRYPOINT command param1 param2==\n\n在为 ENTRYPOINT 选择格式时必须小心，因为这两种格式的效果差别很大。\n\n## Exec 格式\nENTRYPOINT 的 Exec 格式用于设置要执行的命令及其参数，同时可通过 CMD 提供额外的参数。\n\nENTRYPOINT 中的参数始终会被使用，而 CMD 的额外参数可以在容器启动时动态替换掉。\n\n比如下面的 Dockerfile 片段：\n```\nENTRYPOINT [\"/bin/echo\", \"Hello\"]  \n\nCMD [\"world\"]\n```\n当容器通过 docker run -it [image] 启动时，输出为：\n```\nHello world\n```\n而如果通过 docker run -it [image] CloudMan 启动，则输出为：\n```\nHello CloudMan\n```\n## Shell 格式\nENTRYPOINT 的 Shell 格式会忽略任何 CMD 或 docker run 提供的参数。\n\n# 最佳实践\n1. 使用 RUN 指令安装应用和软件包，构建镜像。\n2. 如果 Docker 镜像的用途是运行应用程序或服务，比如运行一个 MySQL，应该优先使用 Exec 格式的 ENTRYPOINT 指令。CMD 可为 ENTRYPOINT 提供额外的默认参数，同时可利用 docker run 命令行替换默认参数。\n3. 如果想为容器设置默认的启动命令，可使用 CMD 指令。用户可在 docker run 命令行中替换此默认命令。\n","source":"_posts/RUN vs CMD vs ENTRYPOINT.md","raw":"---\ntitle: RUN vs CMD vs ENTRYPOINT\ndate: 2018-08-17 09:14:42\ntags: Docker\n---\n\nRUN、CMD 和 ENTRYPOINT 这三个 Dockerfile 指令看上去很类似，很容易混淆。本节将通过实践详细讨论它们的区别。\n\n简单的说：\n1. RUN 执行命令并创建新的镜像层，RUN 经常用于安装软件包。\n2. CMD 设置容器启动后默认执行的命令及其参数，但 CMD 能够被 docker run 后面跟的命令行参数替换。\n3. ENTRYPOINT 配置容器启动时运行的命令。\n\n下面我们详细分析。\n\n<!-- more -->\n\n# Shell 和 Exec 格式\n我们可用两种方式指定 RUN、CMD 和 ENTRYPOINT 要运行的命令：Shell 格式和 Exec 格式，二者在使用上有细微的区别。\n\n==Shell 格式 <instruction> <command>==\n\n例如：\n- RUN apt-get install python3  \n- CMD echo \"Hello world\"  \n- ENTRYPOINT echo \"Hello world\" \n\n当指令执行时，shell 格式底层会调用 ==/bin/sh -c <command>==\n\n例如下面的 Dockerfile 片段：\n\n```\nENV name Cloud Man  \n\nENTRYPOINT echo \"Hello, $name\"\n```\n\n执行 docker run <image> 将输出：Hello, Cloud Man\n\n注意环境变量 name 已经被值 Cloud Man 替换\n\n==Exec 格式 <instruction> [\"executable\", \"param1\", \"param2\", ...]==\n\n例如：\n- RUN [\"apt-get\", \"install\", \"python3\"]\n- CMD [\"/bin/echo\", \"Hello world\"]  \n- ENTRYPOINT [\"/bin/echo\", \"Hello world\"]\n\n当指令执行时，会直接调用 <command>，不会被 shell 解析\n\n例如下面的 Dockerfile 片段：\n\n```\nENV name Cloud Man  \n\nENTRYPOINT [\"/bin/echo\", \"Hello, $name\"]\n```\n\n运行容器将输出：Hello, $name\n\n注意环境变量“name”没有被替换，如果希望使用环境变量，照如下修改\n```\nENV name Cloud Man  \n\nENTRYPOINT [\"/bin/sh\", \"-c\", \"echo Hello, $name\"]\n```\n运行容器将输出：Hello, Cloud Man\n\n==CMD 和 ENTRYPOINT 推荐使用 Exec 格式，因为指令可读性更强，更容易理解。RUN 则两种格式都可以。==\n\n# RUN\n\nRUN 指令通常用于安装应用和软件包。\n\nRUN 在当前镜像的顶部执行命令，并通过创建新的镜像层。Dockerfile 中常常包含多个 RUN 指令。\n\nRUN 有两种格式：\n1. Shell 格式：RUN\n2. Exec 格式：RUN [\"executable\", \"param1\", \"param2\"]\n\n下面是使用 RUN 安装多个包的例子：\n```\n bzr \\\n\n cvs \\\n\n git \\\n\n mercurial \\\n\n subversion\n```\n注意：apt-get update 和 apt-get install 被放在一个 RUN 指令中执行，这样能够保证每次安装的是最新的包。如果 apt-get install 在单独的 RUN 中执行，则会使用 apt-get update 创建的镜像层，而这一层可能是很久以前缓存的。\n\n# CMD\nCMD 指令允许用户指定容器的默认执行的命令\n此命令会在容器启动且 docker run 没有指定其他命令时运行。\n1. 如果 docker run 指定了其他命令，CMD 指定的默认命令将被忽略。\n2. 如果 Dockerfile 中有多个 CMD 指令，只有最后一个 CMD 有效。\n\nCMD 有三种格式：\n1. Exec 格式：==CMD [\"executable\",\"param1\",\"param2\"]== 这是 CMD 的推荐格式。\n2. ==CMD [\"param1\",\"param2\"]== 为 ENTRYPOINT 提供额外的参数，此时 ENTRYPOINT 必须使用 Exec 格式。\n3. Shell 格式：==CMD command param1 param2==\n\nExec 和 Shell 格式前面已经介绍过了。第二种格式 CMD [\"param1\",\"param2\"] 要与 Exec 格式 的 ENTRYPOINT 指令配合使用，其用途是为 ENTRYPOINT 设置默认的参数。我们将在后面讨论 ENTRYPOINT 时举例说明。\n\n下面看看 CMD 是如何工作的。Dockerfile 片段如下：\n```\nCMD echo \"Hello world\"\n```\n运行容器 docker run -it [image] 将输出：\n```\nHello world\n```\n但当后面加上一个命令，比如 docker run -it [image] /bin/bash，CMD 会被忽略掉，命令 bash 将被执行：\n```\nroot@10a32dc7d3d3:/#\n```\n# ENTRYPOINT\nENTRYPOINT 指令可让容器以应用程序或者服务的形式运行。\n\nENTRYPOINT 看上去与 CMD 很像，它们都可以指定要执行的命令及其参数。不同的地方在于 ENTRYPOINT 不会被忽略，一定会被执行，即使运行 docker run 时指定了其他命令。\n\nENTRYPOINT 有两种格式：\n1. Exec 格式：==ENTRYPOINT [\"executable\", \"param1\", \"param2\"]== 这是 ENTRYPOINT 的推荐格式。\n2. Shell 格式：==ENTRYPOINT command param1 param2==\n\n在为 ENTRYPOINT 选择格式时必须小心，因为这两种格式的效果差别很大。\n\n## Exec 格式\nENTRYPOINT 的 Exec 格式用于设置要执行的命令及其参数，同时可通过 CMD 提供额外的参数。\n\nENTRYPOINT 中的参数始终会被使用，而 CMD 的额外参数可以在容器启动时动态替换掉。\n\n比如下面的 Dockerfile 片段：\n```\nENTRYPOINT [\"/bin/echo\", \"Hello\"]  \n\nCMD [\"world\"]\n```\n当容器通过 docker run -it [image] 启动时，输出为：\n```\nHello world\n```\n而如果通过 docker run -it [image] CloudMan 启动，则输出为：\n```\nHello CloudMan\n```\n## Shell 格式\nENTRYPOINT 的 Shell 格式会忽略任何 CMD 或 docker run 提供的参数。\n\n# 最佳实践\n1. 使用 RUN 指令安装应用和软件包，构建镜像。\n2. 如果 Docker 镜像的用途是运行应用程序或服务，比如运行一个 MySQL，应该优先使用 Exec 格式的 ENTRYPOINT 指令。CMD 可为 ENTRYPOINT 提供额外的默认参数，同时可利用 docker run 命令行替换默认参数。\n3. 如果想为容器设置默认的启动命令，可使用 CMD 指令。用户可在 docker run 命令行中替换此默认命令。\n","slug":"RUN vs CMD vs ENTRYPOINT","published":1,"updated":"2018-08-17T01:15:45.554Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlqdfcwv000eowv3g9v7z5qm","content":"<p>RUN、CMD 和 ENTRYPOINT 这三个 Dockerfile 指令看上去很类似，很容易混淆。本节将通过实践详细讨论它们的区别。</p>\n<p>简单的说：</p>\n<ol>\n<li>RUN 执行命令并创建新的镜像层，RUN 经常用于安装软件包。</li>\n<li>CMD 设置容器启动后默认执行的命令及其参数，但 CMD 能够被 docker run 后面跟的命令行参数替换。</li>\n<li>ENTRYPOINT 配置容器启动时运行的命令。</li>\n</ol>\n<p>下面我们详细分析。</p>\n<a id=\"more\"></a>\n<h1 id=\"Shell-和-Exec-格式\"><a href=\"#Shell-和-Exec-格式\" class=\"headerlink\" title=\"Shell 和 Exec 格式\"></a>Shell 和 Exec 格式</h1><p>我们可用两种方式指定 RUN、CMD 和 ENTRYPOINT 要运行的命令：Shell 格式和 Exec 格式，二者在使用上有细微的区别。</p>\n<p>==Shell 格式 <instruction> <command>==</instruction></p>\n<p>例如：</p>\n<ul>\n<li>RUN apt-get install python3  </li>\n<li>CMD echo “Hello world”  </li>\n<li>ENTRYPOINT echo “Hello world” </li>\n</ul>\n<p>当指令执行时，shell 格式底层会调用 ==/bin/sh -c <command>==</p>\n<p>例如下面的 Dockerfile 片段：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ENV name Cloud Man  </span><br><span class=\"line\"></span><br><span class=\"line\">ENTRYPOINT echo &quot;Hello, $name&quot;</span><br></pre></td></tr></table></figure>\n<p>执行 docker run <image> 将输出：Hello, Cloud Man</image></p>\n<p>注意环境变量 name 已经被值 Cloud Man 替换</p>\n<p>==Exec 格式 <instruction> [“executable”, “param1”, “param2”, …]==</instruction></p>\n<p>例如：</p>\n<ul>\n<li>RUN [“apt-get”, “install”, “python3”]</li>\n<li>CMD [“/bin/echo”, “Hello world”]  </li>\n<li>ENTRYPOINT [“/bin/echo”, “Hello world”]</li>\n</ul>\n<p>当指令执行时，会直接调用 <command>，不会被 shell 解析</p>\n<p>例如下面的 Dockerfile 片段：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ENV name Cloud Man  </span><br><span class=\"line\"></span><br><span class=\"line\">ENTRYPOINT [&quot;/bin/echo&quot;, &quot;Hello, $name&quot;]</span><br></pre></td></tr></table></figure>\n<p>运行容器将输出：Hello, $name</p>\n<p>注意环境变量“name”没有被替换，如果希望使用环境变量，照如下修改<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ENV name Cloud Man  </span><br><span class=\"line\"></span><br><span class=\"line\">ENTRYPOINT [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;echo Hello, $name&quot;]</span><br></pre></td></tr></table></figure></p>\n<p>运行容器将输出：Hello, Cloud Man</p>\n<p>==CMD 和 ENTRYPOINT 推荐使用 Exec 格式，因为指令可读性更强，更容易理解。RUN 则两种格式都可以。==</p>\n<h1 id=\"RUN\"><a href=\"#RUN\" class=\"headerlink\" title=\"RUN\"></a>RUN</h1><p>RUN 指令通常用于安装应用和软件包。</p>\n<p>RUN 在当前镜像的顶部执行命令，并通过创建新的镜像层。Dockerfile 中常常包含多个 RUN 指令。</p>\n<p>RUN 有两种格式：</p>\n<ol>\n<li>Shell 格式：RUN</li>\n<li>Exec 格式：RUN [“executable”, “param1”, “param2”]</li>\n</ol>\n<p>下面是使用 RUN 安装多个包的例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bzr \\</span><br><span class=\"line\"></span><br><span class=\"line\">cvs \\</span><br><span class=\"line\"></span><br><span class=\"line\">git \\</span><br><span class=\"line\"></span><br><span class=\"line\">mercurial \\</span><br><span class=\"line\"></span><br><span class=\"line\">subversion</span><br></pre></td></tr></table></figure></p>\n<p>注意：apt-get update 和 apt-get install 被放在一个 RUN 指令中执行，这样能够保证每次安装的是最新的包。如果 apt-get install 在单独的 RUN 中执行，则会使用 apt-get update 创建的镜像层，而这一层可能是很久以前缓存的。</p>\n<h1 id=\"CMD\"><a href=\"#CMD\" class=\"headerlink\" title=\"CMD\"></a>CMD</h1><p>CMD 指令允许用户指定容器的默认执行的命令<br>此命令会在容器启动且 docker run 没有指定其他命令时运行。</p>\n<ol>\n<li>如果 docker run 指定了其他命令，CMD 指定的默认命令将被忽略。</li>\n<li>如果 Dockerfile 中有多个 CMD 指令，只有最后一个 CMD 有效。</li>\n</ol>\n<p>CMD 有三种格式：</p>\n<ol>\n<li>Exec 格式：==CMD [“executable”,”param1”,”param2”]== 这是 CMD 的推荐格式。</li>\n<li>==CMD [“param1”,”param2”]== 为 ENTRYPOINT 提供额外的参数，此时 ENTRYPOINT 必须使用 Exec 格式。</li>\n<li>Shell 格式：==CMD command param1 param2==</li>\n</ol>\n<p>Exec 和 Shell 格式前面已经介绍过了。第二种格式 CMD [“param1”,”param2”] 要与 Exec 格式 的 ENTRYPOINT 指令配合使用，其用途是为 ENTRYPOINT 设置默认的参数。我们将在后面讨论 ENTRYPOINT 时举例说明。</p>\n<p>下面看看 CMD 是如何工作的。Dockerfile 片段如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CMD echo &quot;Hello world&quot;</span><br></pre></td></tr></table></figure></p>\n<p>运行容器 docker run -it [image] 将输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hello world</span><br></pre></td></tr></table></figure></p>\n<p>但当后面加上一个命令，比如 docker run -it [image] /bin/bash，CMD 会被忽略掉，命令 bash 将被执行：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@10a32dc7d3d3:/#</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"ENTRYPOINT\"><a href=\"#ENTRYPOINT\" class=\"headerlink\" title=\"ENTRYPOINT\"></a>ENTRYPOINT</h1><p>ENTRYPOINT 指令可让容器以应用程序或者服务的形式运行。</p>\n<p>ENTRYPOINT 看上去与 CMD 很像，它们都可以指定要执行的命令及其参数。不同的地方在于 ENTRYPOINT 不会被忽略，一定会被执行，即使运行 docker run 时指定了其他命令。</p>\n<p>ENTRYPOINT 有两种格式：</p>\n<ol>\n<li>Exec 格式：==ENTRYPOINT [“executable”, “param1”, “param2”]== 这是 ENTRYPOINT 的推荐格式。</li>\n<li>Shell 格式：==ENTRYPOINT command param1 param2==</li>\n</ol>\n<p>在为 ENTRYPOINT 选择格式时必须小心，因为这两种格式的效果差别很大。</p>\n<h2 id=\"Exec-格式\"><a href=\"#Exec-格式\" class=\"headerlink\" title=\"Exec 格式\"></a>Exec 格式</h2><p>ENTRYPOINT 的 Exec 格式用于设置要执行的命令及其参数，同时可通过 CMD 提供额外的参数。</p>\n<p>ENTRYPOINT 中的参数始终会被使用，而 CMD 的额外参数可以在容器启动时动态替换掉。</p>\n<p>比如下面的 Dockerfile 片段：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ENTRYPOINT [&quot;/bin/echo&quot;, &quot;Hello&quot;]  </span><br><span class=\"line\"></span><br><span class=\"line\">CMD [&quot;world&quot;]</span><br></pre></td></tr></table></figure></p>\n<p>当容器通过 docker run -it [image] 启动时，输出为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hello world</span><br></pre></td></tr></table></figure></p>\n<p>而如果通过 docker run -it [image] CloudMan 启动，则输出为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hello CloudMan</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Shell-格式\"><a href=\"#Shell-格式\" class=\"headerlink\" title=\"Shell 格式\"></a>Shell 格式</h2><p>ENTRYPOINT 的 Shell 格式会忽略任何 CMD 或 docker run 提供的参数。</p>\n<h1 id=\"最佳实践\"><a href=\"#最佳实践\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h1><ol>\n<li>使用 RUN 指令安装应用和软件包，构建镜像。</li>\n<li>如果 Docker 镜像的用途是运行应用程序或服务，比如运行一个 MySQL，应该优先使用 Exec 格式的 ENTRYPOINT 指令。CMD 可为 ENTRYPOINT 提供额外的默认参数，同时可利用 docker run 命令行替换默认参数。</li>\n<li>如果想为容器设置默认的启动命令，可使用 CMD 指令。用户可在 docker run 命令行中替换此默认命令。</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>RUN、CMD 和 ENTRYPOINT 这三个 Dockerfile 指令看上去很类似，很容易混淆。本节将通过实践详细讨论它们的区别。</p>\n<p>简单的说：</p>\n<ol>\n<li>RUN 执行命令并创建新的镜像层，RUN 经常用于安装软件包。</li>\n<li>CMD 设置容器启动后默认执行的命令及其参数，但 CMD 能够被 docker run 后面跟的命令行参数替换。</li>\n<li>ENTRYPOINT 配置容器启动时运行的命令。</li>\n</ol>\n<p>下面我们详细分析。</p>","more":"<h1 id=\"Shell-和-Exec-格式\"><a href=\"#Shell-和-Exec-格式\" class=\"headerlink\" title=\"Shell 和 Exec 格式\"></a>Shell 和 Exec 格式</h1><p>我们可用两种方式指定 RUN、CMD 和 ENTRYPOINT 要运行的命令：Shell 格式和 Exec 格式，二者在使用上有细微的区别。</p>\n<p>==Shell 格式 <instruction> <command>==</instruction></p>\n<p>例如：</p>\n<ul>\n<li>RUN apt-get install python3  </li>\n<li>CMD echo “Hello world”  </li>\n<li>ENTRYPOINT echo “Hello world” </li>\n</ul>\n<p>当指令执行时，shell 格式底层会调用 ==/bin/sh -c <command>==</p>\n<p>例如下面的 Dockerfile 片段：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ENV name Cloud Man  </span><br><span class=\"line\"></span><br><span class=\"line\">ENTRYPOINT echo &quot;Hello, $name&quot;</span><br></pre></td></tr></table></figure>\n<p>执行 docker run <image> 将输出：Hello, Cloud Man</image></p>\n<p>注意环境变量 name 已经被值 Cloud Man 替换</p>\n<p>==Exec 格式 <instruction> [“executable”, “param1”, “param2”, …]==</instruction></p>\n<p>例如：</p>\n<ul>\n<li>RUN [“apt-get”, “install”, “python3”]</li>\n<li>CMD [“/bin/echo”, “Hello world”]  </li>\n<li>ENTRYPOINT [“/bin/echo”, “Hello world”]</li>\n</ul>\n<p>当指令执行时，会直接调用 <command>，不会被 shell 解析</p>\n<p>例如下面的 Dockerfile 片段：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ENV name Cloud Man  </span><br><span class=\"line\"></span><br><span class=\"line\">ENTRYPOINT [&quot;/bin/echo&quot;, &quot;Hello, $name&quot;]</span><br></pre></td></tr></table></figure>\n<p>运行容器将输出：Hello, $name</p>\n<p>注意环境变量“name”没有被替换，如果希望使用环境变量，照如下修改<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ENV name Cloud Man  </span><br><span class=\"line\"></span><br><span class=\"line\">ENTRYPOINT [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;echo Hello, $name&quot;]</span><br></pre></td></tr></table></figure></p>\n<p>运行容器将输出：Hello, Cloud Man</p>\n<p>==CMD 和 ENTRYPOINT 推荐使用 Exec 格式，因为指令可读性更强，更容易理解。RUN 则两种格式都可以。==</p>\n<h1 id=\"RUN\"><a href=\"#RUN\" class=\"headerlink\" title=\"RUN\"></a>RUN</h1><p>RUN 指令通常用于安装应用和软件包。</p>\n<p>RUN 在当前镜像的顶部执行命令，并通过创建新的镜像层。Dockerfile 中常常包含多个 RUN 指令。</p>\n<p>RUN 有两种格式：</p>\n<ol>\n<li>Shell 格式：RUN</li>\n<li>Exec 格式：RUN [“executable”, “param1”, “param2”]</li>\n</ol>\n<p>下面是使用 RUN 安装多个包的例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bzr \\</span><br><span class=\"line\"></span><br><span class=\"line\">cvs \\</span><br><span class=\"line\"></span><br><span class=\"line\">git \\</span><br><span class=\"line\"></span><br><span class=\"line\">mercurial \\</span><br><span class=\"line\"></span><br><span class=\"line\">subversion</span><br></pre></td></tr></table></figure></p>\n<p>注意：apt-get update 和 apt-get install 被放在一个 RUN 指令中执行，这样能够保证每次安装的是最新的包。如果 apt-get install 在单独的 RUN 中执行，则会使用 apt-get update 创建的镜像层，而这一层可能是很久以前缓存的。</p>\n<h1 id=\"CMD\"><a href=\"#CMD\" class=\"headerlink\" title=\"CMD\"></a>CMD</h1><p>CMD 指令允许用户指定容器的默认执行的命令<br>此命令会在容器启动且 docker run 没有指定其他命令时运行。</p>\n<ol>\n<li>如果 docker run 指定了其他命令，CMD 指定的默认命令将被忽略。</li>\n<li>如果 Dockerfile 中有多个 CMD 指令，只有最后一个 CMD 有效。</li>\n</ol>\n<p>CMD 有三种格式：</p>\n<ol>\n<li>Exec 格式：==CMD [“executable”,”param1”,”param2”]== 这是 CMD 的推荐格式。</li>\n<li>==CMD [“param1”,”param2”]== 为 ENTRYPOINT 提供额外的参数，此时 ENTRYPOINT 必须使用 Exec 格式。</li>\n<li>Shell 格式：==CMD command param1 param2==</li>\n</ol>\n<p>Exec 和 Shell 格式前面已经介绍过了。第二种格式 CMD [“param1”,”param2”] 要与 Exec 格式 的 ENTRYPOINT 指令配合使用，其用途是为 ENTRYPOINT 设置默认的参数。我们将在后面讨论 ENTRYPOINT 时举例说明。</p>\n<p>下面看看 CMD 是如何工作的。Dockerfile 片段如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CMD echo &quot;Hello world&quot;</span><br></pre></td></tr></table></figure></p>\n<p>运行容器 docker run -it [image] 将输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hello world</span><br></pre></td></tr></table></figure></p>\n<p>但当后面加上一个命令，比如 docker run -it [image] /bin/bash，CMD 会被忽略掉，命令 bash 将被执行：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@10a32dc7d3d3:/#</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"ENTRYPOINT\"><a href=\"#ENTRYPOINT\" class=\"headerlink\" title=\"ENTRYPOINT\"></a>ENTRYPOINT</h1><p>ENTRYPOINT 指令可让容器以应用程序或者服务的形式运行。</p>\n<p>ENTRYPOINT 看上去与 CMD 很像，它们都可以指定要执行的命令及其参数。不同的地方在于 ENTRYPOINT 不会被忽略，一定会被执行，即使运行 docker run 时指定了其他命令。</p>\n<p>ENTRYPOINT 有两种格式：</p>\n<ol>\n<li>Exec 格式：==ENTRYPOINT [“executable”, “param1”, “param2”]== 这是 ENTRYPOINT 的推荐格式。</li>\n<li>Shell 格式：==ENTRYPOINT command param1 param2==</li>\n</ol>\n<p>在为 ENTRYPOINT 选择格式时必须小心，因为这两种格式的效果差别很大。</p>\n<h2 id=\"Exec-格式\"><a href=\"#Exec-格式\" class=\"headerlink\" title=\"Exec 格式\"></a>Exec 格式</h2><p>ENTRYPOINT 的 Exec 格式用于设置要执行的命令及其参数，同时可通过 CMD 提供额外的参数。</p>\n<p>ENTRYPOINT 中的参数始终会被使用，而 CMD 的额外参数可以在容器启动时动态替换掉。</p>\n<p>比如下面的 Dockerfile 片段：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ENTRYPOINT [&quot;/bin/echo&quot;, &quot;Hello&quot;]  </span><br><span class=\"line\"></span><br><span class=\"line\">CMD [&quot;world&quot;]</span><br></pre></td></tr></table></figure></p>\n<p>当容器通过 docker run -it [image] 启动时，输出为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hello world</span><br></pre></td></tr></table></figure></p>\n<p>而如果通过 docker run -it [image] CloudMan 启动，则输出为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hello CloudMan</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Shell-格式\"><a href=\"#Shell-格式\" class=\"headerlink\" title=\"Shell 格式\"></a>Shell 格式</h2><p>ENTRYPOINT 的 Shell 格式会忽略任何 CMD 或 docker run 提供的参数。</p>\n<h1 id=\"最佳实践\"><a href=\"#最佳实践\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h1><ol>\n<li>使用 RUN 指令安装应用和软件包，构建镜像。</li>\n<li>如果 Docker 镜像的用途是运行应用程序或服务，比如运行一个 MySQL，应该优先使用 Exec 格式的 ENTRYPOINT 指令。CMD 可为 ENTRYPOINT 提供额外的默认参数，同时可利用 docker run 命令行替换默认参数。</li>\n<li>如果想为容器设置默认的启动命令，可使用 CMD 指令。用户可在 docker run 命令行中替换此默认命令。</li>\n</ol>"},{"title":"slice切片的操作——切片的追加、删除、插入等","date":"2018-07-15T18:02:30.000Z","_content":"# 一、一般操作\n\n1. 声明变量，go自动初始化为nil，长度：0，地址：0，nil\n\n```\nfunc main(){\n    var ss []string;\n    fmt.Printf(\"length:%v \\taddr:%p \\tisnil:%v\",len(ss),ss, ss==nil)    \n}\n\n---\nRunning...\n\nlength:0     addr:0x0     isnil:true\nSuccess: process exited with code 0.\n```\n\n<!-- more -->\n\n2. 切片的追加，删除，插入操作\n\n```\nfunc main(){\n    var ss []string;\n    fmt.Printf(\"[ local print ]\\t:\\t length:%v\\taddr:%p\\tisnil:%v\\n\",len(ss),ss, ss==nil)    \n    print(\"func print\",ss)\n    //切片尾部追加元素append elemnt\n    for i:=0;i<10;i++{\n        ss=append(ss,fmt.Sprintf(\"s%d\",i));\n    }\n    fmt.Printf(\"[ local print ]\\t:\\tlength:%v\\taddr:%p\\tisnil:%v\\n\",len(ss),ss, ss==nil)    \n    print(\"after append\",ss)\n    //删除切片元素remove element at index\n    index:=5;\n    ss=append(ss[:index],ss[index+1:]...)\n    print(\"after delete\",ss)\n    //在切片中间插入元素insert element at index;\n    //注意：保存后部剩余元素，必须新建一个临时切片\n    rear:=append([]string{},ss[index:]...) \n    ss=append(ss[0:index],\"inserted\")\n    ss=append(ss,rear...)\n    print(\"after insert\",ss)\n}\nfunc print(msg string,ss []string){\n    fmt.Printf(\"[ %20s ]\\t:\\tlength:%v\\taddr:%p\\tisnil:%v\\tcontent:%v\",msg,len(ss),ss, ss==nil,ss)    \n    fmt.Println()\n}\n------\nRunning...\n\n[ local print ]    :     length:0    addr:0x0    isnil:true\n[           func print ]    :    length:0    addr:0x0    isnil:true    content:[]\n[ local print ]    :    length:10    addr:0xc208056000    isnil:false\n[         after append ]    :    length:10    addr:0xc208056000    isnil:false    content:[s0 s1 s2 s3 s4 s5 s6 s7 s8 s9]\n[         after delete ]    :    length:9    addr:0xc208056000    isnil:false    content:[s0 s1 s2 s3 s4 s6 s7 s8 s9]\n[         after insert ]    :    length:10    addr:0xc208056000    isnil:false    content:[s0 s1 s2 s3 s4 inserted s6 s7 s8 s9]\n\nSuccess: process exited with code 0.\n```\n3. copy的使用\n\n在使用copy复制切片之前，要保证目标切片有足够的大小，注意是大小，而不是容量，还是看例子：\n\n```\nfunc main() {\n    var sa = make ([]string,0);\n    for i:=0;i<10;i++{\n        sa=append(sa,fmt.Sprintf(\"%v\",i))\n        \n    }\n    var da =make([]string,0,10);\n    var cc=0;\n    cc= copy(da,sa);\n    fmt.Printf(\"copy to da(len=%d)\\t%v\\n\",len(da),da)\n    da = make([]string,5)\n    cc=copy(da,sa);\n    fmt.Printf(\"copy to da(len=%d)\\tcopied=%d\\t%v\\n\",len(da),cc,da)\n     da = make([]string,10)\n    cc =copy(da,sa);\n    fmt.Printf(\"copy to da(len=%d)\\tcopied=%d\\t%v\\n\",len(da),cc,da)\n    \n}\n\n---\nRunning...\n\ncopy to da(len=0)    []\ncopy to da(len=5)    copied=5    [0 1 2 3 4]\ncopy to da(len=10)    copied=10    [0 1 2 3 4 5 6 7 8 9]\n```\n从上面运行结果，明显看出，目标切片大小0，容量10，copy不能复制。目标切片大小小于源切片大小，copy就按照目标切片大小复制，不会报错。\n# 二、初始大小和容量\n\n当我们使用make初始化切片的时候，必须给出size。go语言的书上一般都会告诉我们，当切片有足够大小的时候，append操作是非常快的。但是当给出初始大小后，我们得到的实际上是一个含有这个size数量切片类型的空元素，看例子：\n\n```\nfunc main(){\n    var ss=make([]string,10);\n    ss=append(ss,\"last\");\n    print(\"after append\",ss)\n    \n}\n---\nRunning...\n\n[         after append ]    :    length:11    addr:0xc20804c000    isnil:false    content:[          last]\n```\n实际上，此时我们应该先用下标为切片元素负值。但是如果我们既想有好的效率，有想继续使用append函数而不想区分是否有空的元素，此时就要请出make的第三个参数，容量，也就是我们通过传递给make，0的大小和足够大的容量数值就行了。\n\n```\nfunc main(){\n    var ss=make([]string,0,10);\n    ss=append(ss,\"last\");\n    print(\"after append\",ss)\n    \n}\n\n---\nRunning...\n\n[         after append ]    :    length:1    addr:0xc20804a000    isnil:false    content:[last]\n```\n# 三、切片的指针\n1. 当我们用append追加元素到切片时，如果容量不够，go就会创建一个新的切片变量，看下面程序的执行结果：\n\n```\nfunc main() {\n    var sa []string\nfmt.Printf(\"addr:%p \\t\\tlen:%v content:%v\\n\",sa,len(sa),sa);\n    for i:=0;i<10;i++{\n        sa=append(sa,fmt.Sprintf(\"%v\",i))\n        fmt.Printf(\"addr:%p \\t\\tlen:%v content:%v\\n\",sa,len(sa),sa);\n    }\n    fmt.Printf(\"addr:%p \\t\\tlen:%v content:%v\\n\",sa,len(sa),sa);\n\n}\n\n---\nRunning ...\naddr:0x0         len:0 content:[]\naddr:0x1030e0c8         len:1 content:[0]\naddr:0x10328120         len:2 content:[0 1]\naddr:0x10322180         len:3 content:[0 1 2]\naddr:0x10322180         len:4 content:[0 1 2 3]\naddr:0x10342080         len:5 content:[0 1 2 3 4]\naddr:0x10342080         len:6 content:[0 1 2 3 4 5]\naddr:0x10342080         len:7 content:[0 1 2 3 4 5 6]\naddr:0x10342080         len:8 content:[0 1 2 3 4 5 6 7]\naddr:0x10324a00         len:9 content:[0 1 2 3 4 5 6 7 8]\naddr:0x10324a00         len:10 content:[0 1 2 3 4 5 6 7 8 9]\naddr:0x10324a00         len:10 content:[0 1 2 3 4 5 6 7 8 9]\n\n//很明显，切片的地址经过了数次改变。\n```\n2.如果，在make初始化切片的时候给出了足够的容量，append操作不会创建新的切片：\n\n```\nfunc main() {\n    var sa = make ([]string,0,10);\nfmt.Printf(\"addr:%p \\t\\tlen:%v content:%v\\n\",sa,len(sa),sa);\n    for i:=0;i<10;i++{\n        sa=append(sa,fmt.Sprintf(\"%v\",i))\n        fmt.Printf(\"addr:%p \\t\\tlen:%v content:%v\\n\",sa,len(sa),sa);\n    }\n    fmt.Printf(\"addr:%p \\t\\tlen:%v content:%v\\n\",sa,len(sa),sa);\n\n}\naddr:0x10304140         len:0 content:[]\naddr:0x10304140         len:1 content:[0]\naddr:0x10304140         len:2 content:[0 1]\naddr:0x10304140         len:3 content:[0 1 2]\naddr:0x10304140         len:4 content:[0 1 2 3]\naddr:0x10304140         len:5 content:[0 1 2 3 4]\naddr:0x10304140         len:6 content:[0 1 2 3 4 5]\naddr:0x10304140         len:7 content:[0 1 2 3 4 5 6]\naddr:0x10304140         len:8 content:[0 1 2 3 4 5 6 7]\naddr:0x10304140         len:9 content:[0 1 2 3 4 5 6 7 8]\naddr:0x10304140         len:10 content:[0 1 2 3 4 5 6 7 8 9]\naddr:0x10304140         len:10 content:[0 1 2 3 4 5 6 7 8 9]\n\n//可见，切片的地址一直保持不变\n```\n3.如果不能准确预估切片的大小，又不想改变变量（如：为了共享数据的改变），这时候就要请出指针来帮忙了，下面程序中，sa就是osa这个切片的指针，我们共享切片数据和操作切片的时候都使用这个切片地址就ok了，其本质上是：append操作亦然会在需要的时候构造新的切片，不过是将地址都保存到了sa中，因此我们通过该指针始终可以访问到真正的数据。\n\n```\nfunc main() {\n    var osa = make ([]string,0);\n    sa:=&osa;\n    for i:=0;i<10;i++{\n        *sa=append(*sa,fmt.Sprintf(\"%v\",i))\n        fmt.Printf(\"addr of osa:%p,\\taddr:%p \\t content:%v\\n\",osa,sa,sa);\n    }\n    fmt.Printf(\"addr of osa:%p,\\taddr:%p \\t content:%v\\n\",osa,sa,sa);\n   \n}\n\n---\nRunning...\n\naddr of osa:0xc20800a220,    addr:0xc20801e020      content:&[0]\naddr of osa:0xc20801e0a0,    addr:0xc20801e020      content:&[0 1]\naddr of osa:0xc20803e0c0,    addr:0xc20801e020      content:&[0 1 2]\naddr of osa:0xc20803e0c0,    addr:0xc20801e020      content:&[0 1 2 3]\naddr of osa:0xc208050080,    addr:0xc20801e020      content:&[0 1 2 3 4]\naddr of osa:0xc208050080,    addr:0xc20801e020      content:&[0 1 2 3 4 5]\naddr of osa:0xc208050080,    addr:0xc20801e020      content:&[0 1 2 3 4 5 6]\naddr of osa:0xc208050080,    addr:0xc20801e020      content:&[0 1 2 3 4 5 6 7]\naddr of osa:0xc208052000,    addr:0xc20801e020      content:&[0 1 2 3 4 5 6 7 8]\naddr of osa:0xc208052000,    addr:0xc20801e020      content:&[0 1 2 3 4 5 6 7 8 9]\naddr of osa:0xc208052000,    addr:0xc20801e020      content:&[0 1 2 3 4 5 6 7 8 9]\n```\n\n","source":"_posts/slice.md","raw":"---\ntitle: slice切片的操作——切片的追加、删除、插入等\ndate: 2018-07-16 02:02:30\ntags: Go\n---\n# 一、一般操作\n\n1. 声明变量，go自动初始化为nil，长度：0，地址：0，nil\n\n```\nfunc main(){\n    var ss []string;\n    fmt.Printf(\"length:%v \\taddr:%p \\tisnil:%v\",len(ss),ss, ss==nil)    \n}\n\n---\nRunning...\n\nlength:0     addr:0x0     isnil:true\nSuccess: process exited with code 0.\n```\n\n<!-- more -->\n\n2. 切片的追加，删除，插入操作\n\n```\nfunc main(){\n    var ss []string;\n    fmt.Printf(\"[ local print ]\\t:\\t length:%v\\taddr:%p\\tisnil:%v\\n\",len(ss),ss, ss==nil)    \n    print(\"func print\",ss)\n    //切片尾部追加元素append elemnt\n    for i:=0;i<10;i++{\n        ss=append(ss,fmt.Sprintf(\"s%d\",i));\n    }\n    fmt.Printf(\"[ local print ]\\t:\\tlength:%v\\taddr:%p\\tisnil:%v\\n\",len(ss),ss, ss==nil)    \n    print(\"after append\",ss)\n    //删除切片元素remove element at index\n    index:=5;\n    ss=append(ss[:index],ss[index+1:]...)\n    print(\"after delete\",ss)\n    //在切片中间插入元素insert element at index;\n    //注意：保存后部剩余元素，必须新建一个临时切片\n    rear:=append([]string{},ss[index:]...) \n    ss=append(ss[0:index],\"inserted\")\n    ss=append(ss,rear...)\n    print(\"after insert\",ss)\n}\nfunc print(msg string,ss []string){\n    fmt.Printf(\"[ %20s ]\\t:\\tlength:%v\\taddr:%p\\tisnil:%v\\tcontent:%v\",msg,len(ss),ss, ss==nil,ss)    \n    fmt.Println()\n}\n------\nRunning...\n\n[ local print ]    :     length:0    addr:0x0    isnil:true\n[           func print ]    :    length:0    addr:0x0    isnil:true    content:[]\n[ local print ]    :    length:10    addr:0xc208056000    isnil:false\n[         after append ]    :    length:10    addr:0xc208056000    isnil:false    content:[s0 s1 s2 s3 s4 s5 s6 s7 s8 s9]\n[         after delete ]    :    length:9    addr:0xc208056000    isnil:false    content:[s0 s1 s2 s3 s4 s6 s7 s8 s9]\n[         after insert ]    :    length:10    addr:0xc208056000    isnil:false    content:[s0 s1 s2 s3 s4 inserted s6 s7 s8 s9]\n\nSuccess: process exited with code 0.\n```\n3. copy的使用\n\n在使用copy复制切片之前，要保证目标切片有足够的大小，注意是大小，而不是容量，还是看例子：\n\n```\nfunc main() {\n    var sa = make ([]string,0);\n    for i:=0;i<10;i++{\n        sa=append(sa,fmt.Sprintf(\"%v\",i))\n        \n    }\n    var da =make([]string,0,10);\n    var cc=0;\n    cc= copy(da,sa);\n    fmt.Printf(\"copy to da(len=%d)\\t%v\\n\",len(da),da)\n    da = make([]string,5)\n    cc=copy(da,sa);\n    fmt.Printf(\"copy to da(len=%d)\\tcopied=%d\\t%v\\n\",len(da),cc,da)\n     da = make([]string,10)\n    cc =copy(da,sa);\n    fmt.Printf(\"copy to da(len=%d)\\tcopied=%d\\t%v\\n\",len(da),cc,da)\n    \n}\n\n---\nRunning...\n\ncopy to da(len=0)    []\ncopy to da(len=5)    copied=5    [0 1 2 3 4]\ncopy to da(len=10)    copied=10    [0 1 2 3 4 5 6 7 8 9]\n```\n从上面运行结果，明显看出，目标切片大小0，容量10，copy不能复制。目标切片大小小于源切片大小，copy就按照目标切片大小复制，不会报错。\n# 二、初始大小和容量\n\n当我们使用make初始化切片的时候，必须给出size。go语言的书上一般都会告诉我们，当切片有足够大小的时候，append操作是非常快的。但是当给出初始大小后，我们得到的实际上是一个含有这个size数量切片类型的空元素，看例子：\n\n```\nfunc main(){\n    var ss=make([]string,10);\n    ss=append(ss,\"last\");\n    print(\"after append\",ss)\n    \n}\n---\nRunning...\n\n[         after append ]    :    length:11    addr:0xc20804c000    isnil:false    content:[          last]\n```\n实际上，此时我们应该先用下标为切片元素负值。但是如果我们既想有好的效率，有想继续使用append函数而不想区分是否有空的元素，此时就要请出make的第三个参数，容量，也就是我们通过传递给make，0的大小和足够大的容量数值就行了。\n\n```\nfunc main(){\n    var ss=make([]string,0,10);\n    ss=append(ss,\"last\");\n    print(\"after append\",ss)\n    \n}\n\n---\nRunning...\n\n[         after append ]    :    length:1    addr:0xc20804a000    isnil:false    content:[last]\n```\n# 三、切片的指针\n1. 当我们用append追加元素到切片时，如果容量不够，go就会创建一个新的切片变量，看下面程序的执行结果：\n\n```\nfunc main() {\n    var sa []string\nfmt.Printf(\"addr:%p \\t\\tlen:%v content:%v\\n\",sa,len(sa),sa);\n    for i:=0;i<10;i++{\n        sa=append(sa,fmt.Sprintf(\"%v\",i))\n        fmt.Printf(\"addr:%p \\t\\tlen:%v content:%v\\n\",sa,len(sa),sa);\n    }\n    fmt.Printf(\"addr:%p \\t\\tlen:%v content:%v\\n\",sa,len(sa),sa);\n\n}\n\n---\nRunning ...\naddr:0x0         len:0 content:[]\naddr:0x1030e0c8         len:1 content:[0]\naddr:0x10328120         len:2 content:[0 1]\naddr:0x10322180         len:3 content:[0 1 2]\naddr:0x10322180         len:4 content:[0 1 2 3]\naddr:0x10342080         len:5 content:[0 1 2 3 4]\naddr:0x10342080         len:6 content:[0 1 2 3 4 5]\naddr:0x10342080         len:7 content:[0 1 2 3 4 5 6]\naddr:0x10342080         len:8 content:[0 1 2 3 4 5 6 7]\naddr:0x10324a00         len:9 content:[0 1 2 3 4 5 6 7 8]\naddr:0x10324a00         len:10 content:[0 1 2 3 4 5 6 7 8 9]\naddr:0x10324a00         len:10 content:[0 1 2 3 4 5 6 7 8 9]\n\n//很明显，切片的地址经过了数次改变。\n```\n2.如果，在make初始化切片的时候给出了足够的容量，append操作不会创建新的切片：\n\n```\nfunc main() {\n    var sa = make ([]string,0,10);\nfmt.Printf(\"addr:%p \\t\\tlen:%v content:%v\\n\",sa,len(sa),sa);\n    for i:=0;i<10;i++{\n        sa=append(sa,fmt.Sprintf(\"%v\",i))\n        fmt.Printf(\"addr:%p \\t\\tlen:%v content:%v\\n\",sa,len(sa),sa);\n    }\n    fmt.Printf(\"addr:%p \\t\\tlen:%v content:%v\\n\",sa,len(sa),sa);\n\n}\naddr:0x10304140         len:0 content:[]\naddr:0x10304140         len:1 content:[0]\naddr:0x10304140         len:2 content:[0 1]\naddr:0x10304140         len:3 content:[0 1 2]\naddr:0x10304140         len:4 content:[0 1 2 3]\naddr:0x10304140         len:5 content:[0 1 2 3 4]\naddr:0x10304140         len:6 content:[0 1 2 3 4 5]\naddr:0x10304140         len:7 content:[0 1 2 3 4 5 6]\naddr:0x10304140         len:8 content:[0 1 2 3 4 5 6 7]\naddr:0x10304140         len:9 content:[0 1 2 3 4 5 6 7 8]\naddr:0x10304140         len:10 content:[0 1 2 3 4 5 6 7 8 9]\naddr:0x10304140         len:10 content:[0 1 2 3 4 5 6 7 8 9]\n\n//可见，切片的地址一直保持不变\n```\n3.如果不能准确预估切片的大小，又不想改变变量（如：为了共享数据的改变），这时候就要请出指针来帮忙了，下面程序中，sa就是osa这个切片的指针，我们共享切片数据和操作切片的时候都使用这个切片地址就ok了，其本质上是：append操作亦然会在需要的时候构造新的切片，不过是将地址都保存到了sa中，因此我们通过该指针始终可以访问到真正的数据。\n\n```\nfunc main() {\n    var osa = make ([]string,0);\n    sa:=&osa;\n    for i:=0;i<10;i++{\n        *sa=append(*sa,fmt.Sprintf(\"%v\",i))\n        fmt.Printf(\"addr of osa:%p,\\taddr:%p \\t content:%v\\n\",osa,sa,sa);\n    }\n    fmt.Printf(\"addr of osa:%p,\\taddr:%p \\t content:%v\\n\",osa,sa,sa);\n   \n}\n\n---\nRunning...\n\naddr of osa:0xc20800a220,    addr:0xc20801e020      content:&[0]\naddr of osa:0xc20801e0a0,    addr:0xc20801e020      content:&[0 1]\naddr of osa:0xc20803e0c0,    addr:0xc20801e020      content:&[0 1 2]\naddr of osa:0xc20803e0c0,    addr:0xc20801e020      content:&[0 1 2 3]\naddr of osa:0xc208050080,    addr:0xc20801e020      content:&[0 1 2 3 4]\naddr of osa:0xc208050080,    addr:0xc20801e020      content:&[0 1 2 3 4 5]\naddr of osa:0xc208050080,    addr:0xc20801e020      content:&[0 1 2 3 4 5 6]\naddr of osa:0xc208050080,    addr:0xc20801e020      content:&[0 1 2 3 4 5 6 7]\naddr of osa:0xc208052000,    addr:0xc20801e020      content:&[0 1 2 3 4 5 6 7 8]\naddr of osa:0xc208052000,    addr:0xc20801e020      content:&[0 1 2 3 4 5 6 7 8 9]\naddr of osa:0xc208052000,    addr:0xc20801e020      content:&[0 1 2 3 4 5 6 7 8 9]\n```\n\n","slug":"slice","published":1,"updated":"2018-07-27T07:03:55.446Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlqdfcwy000gowv33b3ndg0a","content":"<h1 id=\"一、一般操作\"><a href=\"#一、一般操作\" class=\"headerlink\" title=\"一、一般操作\"></a>一、一般操作</h1><ol>\n<li>声明变量，go自动初始化为nil，长度：0，地址：0，nil</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func main()&#123;</span><br><span class=\"line\">    var ss []string;</span><br><span class=\"line\">    fmt.Printf(&quot;length:%v \\taddr:%p \\tisnil:%v&quot;,len(ss),ss, ss==nil)    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">---</span><br><span class=\"line\">Running...</span><br><span class=\"line\"></span><br><span class=\"line\">length:0     addr:0x0     isnil:true</span><br><span class=\"line\">Success: process exited with code 0.</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<ol start=\"2\">\n<li>切片的追加，删除，插入操作</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func main()&#123;</span><br><span class=\"line\">    var ss []string;</span><br><span class=\"line\">    fmt.Printf(&quot;[ local print ]\\t:\\t length:%v\\taddr:%p\\tisnil:%v\\n&quot;,len(ss),ss, ss==nil)    </span><br><span class=\"line\">    print(&quot;func print&quot;,ss)</span><br><span class=\"line\">    //切片尾部追加元素append elemnt</span><br><span class=\"line\">    for i:=0;i&lt;10;i++&#123;</span><br><span class=\"line\">        ss=append(ss,fmt.Sprintf(&quot;s%d&quot;,i));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fmt.Printf(&quot;[ local print ]\\t:\\tlength:%v\\taddr:%p\\tisnil:%v\\n&quot;,len(ss),ss, ss==nil)    </span><br><span class=\"line\">    print(&quot;after append&quot;,ss)</span><br><span class=\"line\">    //删除切片元素remove element at index</span><br><span class=\"line\">    index:=5;</span><br><span class=\"line\">    ss=append(ss[:index],ss[index+1:]...)</span><br><span class=\"line\">    print(&quot;after delete&quot;,ss)</span><br><span class=\"line\">    //在切片中间插入元素insert element at index;</span><br><span class=\"line\">    //注意：保存后部剩余元素，必须新建一个临时切片</span><br><span class=\"line\">    rear:=append([]string&#123;&#125;,ss[index:]...) </span><br><span class=\"line\">    ss=append(ss[0:index],&quot;inserted&quot;)</span><br><span class=\"line\">    ss=append(ss,rear...)</span><br><span class=\"line\">    print(&quot;after insert&quot;,ss)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">func print(msg string,ss []string)&#123;</span><br><span class=\"line\">    fmt.Printf(&quot;[ %20s ]\\t:\\tlength:%v\\taddr:%p\\tisnil:%v\\tcontent:%v&quot;,msg,len(ss),ss, ss==nil,ss)    </span><br><span class=\"line\">    fmt.Println()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">------</span><br><span class=\"line\">Running...</span><br><span class=\"line\"></span><br><span class=\"line\">[ local print ]    :     length:0    addr:0x0    isnil:true</span><br><span class=\"line\">[           func print ]    :    length:0    addr:0x0    isnil:true    content:[]</span><br><span class=\"line\">[ local print ]    :    length:10    addr:0xc208056000    isnil:false</span><br><span class=\"line\">[         after append ]    :    length:10    addr:0xc208056000    isnil:false    content:[s0 s1 s2 s3 s4 s5 s6 s7 s8 s9]</span><br><span class=\"line\">[         after delete ]    :    length:9    addr:0xc208056000    isnil:false    content:[s0 s1 s2 s3 s4 s6 s7 s8 s9]</span><br><span class=\"line\">[         after insert ]    :    length:10    addr:0xc208056000    isnil:false    content:[s0 s1 s2 s3 s4 inserted s6 s7 s8 s9]</span><br><span class=\"line\"></span><br><span class=\"line\">Success: process exited with code 0.</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>copy的使用</li>\n</ol>\n<p>在使用copy复制切片之前，要保证目标切片有足够的大小，注意是大小，而不是容量，还是看例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    var sa = make ([]string,0);</span><br><span class=\"line\">    for i:=0;i&lt;10;i++&#123;</span><br><span class=\"line\">        sa=append(sa,fmt.Sprintf(&quot;%v&quot;,i))</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var da =make([]string,0,10);</span><br><span class=\"line\">    var cc=0;</span><br><span class=\"line\">    cc= copy(da,sa);</span><br><span class=\"line\">    fmt.Printf(&quot;copy to da(len=%d)\\t%v\\n&quot;,len(da),da)</span><br><span class=\"line\">    da = make([]string,5)</span><br><span class=\"line\">    cc=copy(da,sa);</span><br><span class=\"line\">    fmt.Printf(&quot;copy to da(len=%d)\\tcopied=%d\\t%v\\n&quot;,len(da),cc,da)</span><br><span class=\"line\">     da = make([]string,10)</span><br><span class=\"line\">    cc =copy(da,sa);</span><br><span class=\"line\">    fmt.Printf(&quot;copy to da(len=%d)\\tcopied=%d\\t%v\\n&quot;,len(da),cc,da)</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">---</span><br><span class=\"line\">Running...</span><br><span class=\"line\"></span><br><span class=\"line\">copy to da(len=0)    []</span><br><span class=\"line\">copy to da(len=5)    copied=5    [0 1 2 3 4]</span><br><span class=\"line\">copy to da(len=10)    copied=10    [0 1 2 3 4 5 6 7 8 9]</span><br></pre></td></tr></table></figure>\n<p>从上面运行结果，明显看出，目标切片大小0，容量10，copy不能复制。目标切片大小小于源切片大小，copy就按照目标切片大小复制，不会报错。</p>\n<h1 id=\"二、初始大小和容量\"><a href=\"#二、初始大小和容量\" class=\"headerlink\" title=\"二、初始大小和容量\"></a>二、初始大小和容量</h1><p>当我们使用make初始化切片的时候，必须给出size。go语言的书上一般都会告诉我们，当切片有足够大小的时候，append操作是非常快的。但是当给出初始大小后，我们得到的实际上是一个含有这个size数量切片类型的空元素，看例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func main()&#123;</span><br><span class=\"line\">    var ss=make([]string,10);</span><br><span class=\"line\">    ss=append(ss,&quot;last&quot;);</span><br><span class=\"line\">    print(&quot;after append&quot;,ss)</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">---</span><br><span class=\"line\">Running...</span><br><span class=\"line\"></span><br><span class=\"line\">[         after append ]    :    length:11    addr:0xc20804c000    isnil:false    content:[          last]</span><br></pre></td></tr></table></figure>\n<p>实际上，此时我们应该先用下标为切片元素负值。但是如果我们既想有好的效率，有想继续使用append函数而不想区分是否有空的元素，此时就要请出make的第三个参数，容量，也就是我们通过传递给make，0的大小和足够大的容量数值就行了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func main()&#123;</span><br><span class=\"line\">    var ss=make([]string,0,10);</span><br><span class=\"line\">    ss=append(ss,&quot;last&quot;);</span><br><span class=\"line\">    print(&quot;after append&quot;,ss)</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">---</span><br><span class=\"line\">Running...</span><br><span class=\"line\"></span><br><span class=\"line\">[         after append ]    :    length:1    addr:0xc20804a000    isnil:false    content:[last]</span><br></pre></td></tr></table></figure>\n<h1 id=\"三、切片的指针\"><a href=\"#三、切片的指针\" class=\"headerlink\" title=\"三、切片的指针\"></a>三、切片的指针</h1><ol>\n<li>当我们用append追加元素到切片时，如果容量不够，go就会创建一个新的切片变量，看下面程序的执行结果：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    var sa []string</span><br><span class=\"line\">fmt.Printf(&quot;addr:%p \\t\\tlen:%v content:%v\\n&quot;,sa,len(sa),sa);</span><br><span class=\"line\">    for i:=0;i&lt;10;i++&#123;</span><br><span class=\"line\">        sa=append(sa,fmt.Sprintf(&quot;%v&quot;,i))</span><br><span class=\"line\">        fmt.Printf(&quot;addr:%p \\t\\tlen:%v content:%v\\n&quot;,sa,len(sa),sa);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fmt.Printf(&quot;addr:%p \\t\\tlen:%v content:%v\\n&quot;,sa,len(sa),sa);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">---</span><br><span class=\"line\">Running ...</span><br><span class=\"line\">addr:0x0         len:0 content:[]</span><br><span class=\"line\">addr:0x1030e0c8         len:1 content:[0]</span><br><span class=\"line\">addr:0x10328120         len:2 content:[0 1]</span><br><span class=\"line\">addr:0x10322180         len:3 content:[0 1 2]</span><br><span class=\"line\">addr:0x10322180         len:4 content:[0 1 2 3]</span><br><span class=\"line\">addr:0x10342080         len:5 content:[0 1 2 3 4]</span><br><span class=\"line\">addr:0x10342080         len:6 content:[0 1 2 3 4 5]</span><br><span class=\"line\">addr:0x10342080         len:7 content:[0 1 2 3 4 5 6]</span><br><span class=\"line\">addr:0x10342080         len:8 content:[0 1 2 3 4 5 6 7]</span><br><span class=\"line\">addr:0x10324a00         len:9 content:[0 1 2 3 4 5 6 7 8]</span><br><span class=\"line\">addr:0x10324a00         len:10 content:[0 1 2 3 4 5 6 7 8 9]</span><br><span class=\"line\">addr:0x10324a00         len:10 content:[0 1 2 3 4 5 6 7 8 9]</span><br><span class=\"line\"></span><br><span class=\"line\">//很明显，切片的地址经过了数次改变。</span><br></pre></td></tr></table></figure>\n<p>2.如果，在make初始化切片的时候给出了足够的容量，append操作不会创建新的切片：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    var sa = make ([]string,0,10);</span><br><span class=\"line\">fmt.Printf(&quot;addr:%p \\t\\tlen:%v content:%v\\n&quot;,sa,len(sa),sa);</span><br><span class=\"line\">    for i:=0;i&lt;10;i++&#123;</span><br><span class=\"line\">        sa=append(sa,fmt.Sprintf(&quot;%v&quot;,i))</span><br><span class=\"line\">        fmt.Printf(&quot;addr:%p \\t\\tlen:%v content:%v\\n&quot;,sa,len(sa),sa);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fmt.Printf(&quot;addr:%p \\t\\tlen:%v content:%v\\n&quot;,sa,len(sa),sa);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">addr:0x10304140         len:0 content:[]</span><br><span class=\"line\">addr:0x10304140         len:1 content:[0]</span><br><span class=\"line\">addr:0x10304140         len:2 content:[0 1]</span><br><span class=\"line\">addr:0x10304140         len:3 content:[0 1 2]</span><br><span class=\"line\">addr:0x10304140         len:4 content:[0 1 2 3]</span><br><span class=\"line\">addr:0x10304140         len:5 content:[0 1 2 3 4]</span><br><span class=\"line\">addr:0x10304140         len:6 content:[0 1 2 3 4 5]</span><br><span class=\"line\">addr:0x10304140         len:7 content:[0 1 2 3 4 5 6]</span><br><span class=\"line\">addr:0x10304140         len:8 content:[0 1 2 3 4 5 6 7]</span><br><span class=\"line\">addr:0x10304140         len:9 content:[0 1 2 3 4 5 6 7 8]</span><br><span class=\"line\">addr:0x10304140         len:10 content:[0 1 2 3 4 5 6 7 8 9]</span><br><span class=\"line\">addr:0x10304140         len:10 content:[0 1 2 3 4 5 6 7 8 9]</span><br><span class=\"line\"></span><br><span class=\"line\">//可见，切片的地址一直保持不变</span><br></pre></td></tr></table></figure>\n<p>3.如果不能准确预估切片的大小，又不想改变变量（如：为了共享数据的改变），这时候就要请出指针来帮忙了，下面程序中，sa就是osa这个切片的指针，我们共享切片数据和操作切片的时候都使用这个切片地址就ok了，其本质上是：append操作亦然会在需要的时候构造新的切片，不过是将地址都保存到了sa中，因此我们通过该指针始终可以访问到真正的数据。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    var osa = make ([]string,0);</span><br><span class=\"line\">    sa:=&amp;osa;</span><br><span class=\"line\">    for i:=0;i&lt;10;i++&#123;</span><br><span class=\"line\">        *sa=append(*sa,fmt.Sprintf(&quot;%v&quot;,i))</span><br><span class=\"line\">        fmt.Printf(&quot;addr of osa:%p,\\taddr:%p \\t content:%v\\n&quot;,osa,sa,sa);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fmt.Printf(&quot;addr of osa:%p,\\taddr:%p \\t content:%v\\n&quot;,osa,sa,sa);</span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">---</span><br><span class=\"line\">Running...</span><br><span class=\"line\"></span><br><span class=\"line\">addr of osa:0xc20800a220,    addr:0xc20801e020      content:&amp;[0]</span><br><span class=\"line\">addr of osa:0xc20801e0a0,    addr:0xc20801e020      content:&amp;[0 1]</span><br><span class=\"line\">addr of osa:0xc20803e0c0,    addr:0xc20801e020      content:&amp;[0 1 2]</span><br><span class=\"line\">addr of osa:0xc20803e0c0,    addr:0xc20801e020      content:&amp;[0 1 2 3]</span><br><span class=\"line\">addr of osa:0xc208050080,    addr:0xc20801e020      content:&amp;[0 1 2 3 4]</span><br><span class=\"line\">addr of osa:0xc208050080,    addr:0xc20801e020      content:&amp;[0 1 2 3 4 5]</span><br><span class=\"line\">addr of osa:0xc208050080,    addr:0xc20801e020      content:&amp;[0 1 2 3 4 5 6]</span><br><span class=\"line\">addr of osa:0xc208050080,    addr:0xc20801e020      content:&amp;[0 1 2 3 4 5 6 7]</span><br><span class=\"line\">addr of osa:0xc208052000,    addr:0xc20801e020      content:&amp;[0 1 2 3 4 5 6 7 8]</span><br><span class=\"line\">addr of osa:0xc208052000,    addr:0xc20801e020      content:&amp;[0 1 2 3 4 5 6 7 8 9]</span><br><span class=\"line\">addr of osa:0xc208052000,    addr:0xc20801e020      content:&amp;[0 1 2 3 4 5 6 7 8 9]</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h1 id=\"一、一般操作\"><a href=\"#一、一般操作\" class=\"headerlink\" title=\"一、一般操作\"></a>一、一般操作</h1><ol>\n<li>声明变量，go自动初始化为nil，长度：0，地址：0，nil</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func main()&#123;</span><br><span class=\"line\">    var ss []string;</span><br><span class=\"line\">    fmt.Printf(&quot;length:%v \\taddr:%p \\tisnil:%v&quot;,len(ss),ss, ss==nil)    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">---</span><br><span class=\"line\">Running...</span><br><span class=\"line\"></span><br><span class=\"line\">length:0     addr:0x0     isnil:true</span><br><span class=\"line\">Success: process exited with code 0.</span><br></pre></td></tr></table></figure>","more":"<ol start=\"2\">\n<li>切片的追加，删除，插入操作</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func main()&#123;</span><br><span class=\"line\">    var ss []string;</span><br><span class=\"line\">    fmt.Printf(&quot;[ local print ]\\t:\\t length:%v\\taddr:%p\\tisnil:%v\\n&quot;,len(ss),ss, ss==nil)    </span><br><span class=\"line\">    print(&quot;func print&quot;,ss)</span><br><span class=\"line\">    //切片尾部追加元素append elemnt</span><br><span class=\"line\">    for i:=0;i&lt;10;i++&#123;</span><br><span class=\"line\">        ss=append(ss,fmt.Sprintf(&quot;s%d&quot;,i));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fmt.Printf(&quot;[ local print ]\\t:\\tlength:%v\\taddr:%p\\tisnil:%v\\n&quot;,len(ss),ss, ss==nil)    </span><br><span class=\"line\">    print(&quot;after append&quot;,ss)</span><br><span class=\"line\">    //删除切片元素remove element at index</span><br><span class=\"line\">    index:=5;</span><br><span class=\"line\">    ss=append(ss[:index],ss[index+1:]...)</span><br><span class=\"line\">    print(&quot;after delete&quot;,ss)</span><br><span class=\"line\">    //在切片中间插入元素insert element at index;</span><br><span class=\"line\">    //注意：保存后部剩余元素，必须新建一个临时切片</span><br><span class=\"line\">    rear:=append([]string&#123;&#125;,ss[index:]...) </span><br><span class=\"line\">    ss=append(ss[0:index],&quot;inserted&quot;)</span><br><span class=\"line\">    ss=append(ss,rear...)</span><br><span class=\"line\">    print(&quot;after insert&quot;,ss)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">func print(msg string,ss []string)&#123;</span><br><span class=\"line\">    fmt.Printf(&quot;[ %20s ]\\t:\\tlength:%v\\taddr:%p\\tisnil:%v\\tcontent:%v&quot;,msg,len(ss),ss, ss==nil,ss)    </span><br><span class=\"line\">    fmt.Println()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">------</span><br><span class=\"line\">Running...</span><br><span class=\"line\"></span><br><span class=\"line\">[ local print ]    :     length:0    addr:0x0    isnil:true</span><br><span class=\"line\">[           func print ]    :    length:0    addr:0x0    isnil:true    content:[]</span><br><span class=\"line\">[ local print ]    :    length:10    addr:0xc208056000    isnil:false</span><br><span class=\"line\">[         after append ]    :    length:10    addr:0xc208056000    isnil:false    content:[s0 s1 s2 s3 s4 s5 s6 s7 s8 s9]</span><br><span class=\"line\">[         after delete ]    :    length:9    addr:0xc208056000    isnil:false    content:[s0 s1 s2 s3 s4 s6 s7 s8 s9]</span><br><span class=\"line\">[         after insert ]    :    length:10    addr:0xc208056000    isnil:false    content:[s0 s1 s2 s3 s4 inserted s6 s7 s8 s9]</span><br><span class=\"line\"></span><br><span class=\"line\">Success: process exited with code 0.</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>copy的使用</li>\n</ol>\n<p>在使用copy复制切片之前，要保证目标切片有足够的大小，注意是大小，而不是容量，还是看例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    var sa = make ([]string,0);</span><br><span class=\"line\">    for i:=0;i&lt;10;i++&#123;</span><br><span class=\"line\">        sa=append(sa,fmt.Sprintf(&quot;%v&quot;,i))</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var da =make([]string,0,10);</span><br><span class=\"line\">    var cc=0;</span><br><span class=\"line\">    cc= copy(da,sa);</span><br><span class=\"line\">    fmt.Printf(&quot;copy to da(len=%d)\\t%v\\n&quot;,len(da),da)</span><br><span class=\"line\">    da = make([]string,5)</span><br><span class=\"line\">    cc=copy(da,sa);</span><br><span class=\"line\">    fmt.Printf(&quot;copy to da(len=%d)\\tcopied=%d\\t%v\\n&quot;,len(da),cc,da)</span><br><span class=\"line\">     da = make([]string,10)</span><br><span class=\"line\">    cc =copy(da,sa);</span><br><span class=\"line\">    fmt.Printf(&quot;copy to da(len=%d)\\tcopied=%d\\t%v\\n&quot;,len(da),cc,da)</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">---</span><br><span class=\"line\">Running...</span><br><span class=\"line\"></span><br><span class=\"line\">copy to da(len=0)    []</span><br><span class=\"line\">copy to da(len=5)    copied=5    [0 1 2 3 4]</span><br><span class=\"line\">copy to da(len=10)    copied=10    [0 1 2 3 4 5 6 7 8 9]</span><br></pre></td></tr></table></figure>\n<p>从上面运行结果，明显看出，目标切片大小0，容量10，copy不能复制。目标切片大小小于源切片大小，copy就按照目标切片大小复制，不会报错。</p>\n<h1 id=\"二、初始大小和容量\"><a href=\"#二、初始大小和容量\" class=\"headerlink\" title=\"二、初始大小和容量\"></a>二、初始大小和容量</h1><p>当我们使用make初始化切片的时候，必须给出size。go语言的书上一般都会告诉我们，当切片有足够大小的时候，append操作是非常快的。但是当给出初始大小后，我们得到的实际上是一个含有这个size数量切片类型的空元素，看例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func main()&#123;</span><br><span class=\"line\">    var ss=make([]string,10);</span><br><span class=\"line\">    ss=append(ss,&quot;last&quot;);</span><br><span class=\"line\">    print(&quot;after append&quot;,ss)</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">---</span><br><span class=\"line\">Running...</span><br><span class=\"line\"></span><br><span class=\"line\">[         after append ]    :    length:11    addr:0xc20804c000    isnil:false    content:[          last]</span><br></pre></td></tr></table></figure>\n<p>实际上，此时我们应该先用下标为切片元素负值。但是如果我们既想有好的效率，有想继续使用append函数而不想区分是否有空的元素，此时就要请出make的第三个参数，容量，也就是我们通过传递给make，0的大小和足够大的容量数值就行了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func main()&#123;</span><br><span class=\"line\">    var ss=make([]string,0,10);</span><br><span class=\"line\">    ss=append(ss,&quot;last&quot;);</span><br><span class=\"line\">    print(&quot;after append&quot;,ss)</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">---</span><br><span class=\"line\">Running...</span><br><span class=\"line\"></span><br><span class=\"line\">[         after append ]    :    length:1    addr:0xc20804a000    isnil:false    content:[last]</span><br></pre></td></tr></table></figure>\n<h1 id=\"三、切片的指针\"><a href=\"#三、切片的指针\" class=\"headerlink\" title=\"三、切片的指针\"></a>三、切片的指针</h1><ol>\n<li>当我们用append追加元素到切片时，如果容量不够，go就会创建一个新的切片变量，看下面程序的执行结果：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    var sa []string</span><br><span class=\"line\">fmt.Printf(&quot;addr:%p \\t\\tlen:%v content:%v\\n&quot;,sa,len(sa),sa);</span><br><span class=\"line\">    for i:=0;i&lt;10;i++&#123;</span><br><span class=\"line\">        sa=append(sa,fmt.Sprintf(&quot;%v&quot;,i))</span><br><span class=\"line\">        fmt.Printf(&quot;addr:%p \\t\\tlen:%v content:%v\\n&quot;,sa,len(sa),sa);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fmt.Printf(&quot;addr:%p \\t\\tlen:%v content:%v\\n&quot;,sa,len(sa),sa);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">---</span><br><span class=\"line\">Running ...</span><br><span class=\"line\">addr:0x0         len:0 content:[]</span><br><span class=\"line\">addr:0x1030e0c8         len:1 content:[0]</span><br><span class=\"line\">addr:0x10328120         len:2 content:[0 1]</span><br><span class=\"line\">addr:0x10322180         len:3 content:[0 1 2]</span><br><span class=\"line\">addr:0x10322180         len:4 content:[0 1 2 3]</span><br><span class=\"line\">addr:0x10342080         len:5 content:[0 1 2 3 4]</span><br><span class=\"line\">addr:0x10342080         len:6 content:[0 1 2 3 4 5]</span><br><span class=\"line\">addr:0x10342080         len:7 content:[0 1 2 3 4 5 6]</span><br><span class=\"line\">addr:0x10342080         len:8 content:[0 1 2 3 4 5 6 7]</span><br><span class=\"line\">addr:0x10324a00         len:9 content:[0 1 2 3 4 5 6 7 8]</span><br><span class=\"line\">addr:0x10324a00         len:10 content:[0 1 2 3 4 5 6 7 8 9]</span><br><span class=\"line\">addr:0x10324a00         len:10 content:[0 1 2 3 4 5 6 7 8 9]</span><br><span class=\"line\"></span><br><span class=\"line\">//很明显，切片的地址经过了数次改变。</span><br></pre></td></tr></table></figure>\n<p>2.如果，在make初始化切片的时候给出了足够的容量，append操作不会创建新的切片：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    var sa = make ([]string,0,10);</span><br><span class=\"line\">fmt.Printf(&quot;addr:%p \\t\\tlen:%v content:%v\\n&quot;,sa,len(sa),sa);</span><br><span class=\"line\">    for i:=0;i&lt;10;i++&#123;</span><br><span class=\"line\">        sa=append(sa,fmt.Sprintf(&quot;%v&quot;,i))</span><br><span class=\"line\">        fmt.Printf(&quot;addr:%p \\t\\tlen:%v content:%v\\n&quot;,sa,len(sa),sa);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fmt.Printf(&quot;addr:%p \\t\\tlen:%v content:%v\\n&quot;,sa,len(sa),sa);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">addr:0x10304140         len:0 content:[]</span><br><span class=\"line\">addr:0x10304140         len:1 content:[0]</span><br><span class=\"line\">addr:0x10304140         len:2 content:[0 1]</span><br><span class=\"line\">addr:0x10304140         len:3 content:[0 1 2]</span><br><span class=\"line\">addr:0x10304140         len:4 content:[0 1 2 3]</span><br><span class=\"line\">addr:0x10304140         len:5 content:[0 1 2 3 4]</span><br><span class=\"line\">addr:0x10304140         len:6 content:[0 1 2 3 4 5]</span><br><span class=\"line\">addr:0x10304140         len:7 content:[0 1 2 3 4 5 6]</span><br><span class=\"line\">addr:0x10304140         len:8 content:[0 1 2 3 4 5 6 7]</span><br><span class=\"line\">addr:0x10304140         len:9 content:[0 1 2 3 4 5 6 7 8]</span><br><span class=\"line\">addr:0x10304140         len:10 content:[0 1 2 3 4 5 6 7 8 9]</span><br><span class=\"line\">addr:0x10304140         len:10 content:[0 1 2 3 4 5 6 7 8 9]</span><br><span class=\"line\"></span><br><span class=\"line\">//可见，切片的地址一直保持不变</span><br></pre></td></tr></table></figure>\n<p>3.如果不能准确预估切片的大小，又不想改变变量（如：为了共享数据的改变），这时候就要请出指针来帮忙了，下面程序中，sa就是osa这个切片的指针，我们共享切片数据和操作切片的时候都使用这个切片地址就ok了，其本质上是：append操作亦然会在需要的时候构造新的切片，不过是将地址都保存到了sa中，因此我们通过该指针始终可以访问到真正的数据。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    var osa = make ([]string,0);</span><br><span class=\"line\">    sa:=&amp;osa;</span><br><span class=\"line\">    for i:=0;i&lt;10;i++&#123;</span><br><span class=\"line\">        *sa=append(*sa,fmt.Sprintf(&quot;%v&quot;,i))</span><br><span class=\"line\">        fmt.Printf(&quot;addr of osa:%p,\\taddr:%p \\t content:%v\\n&quot;,osa,sa,sa);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fmt.Printf(&quot;addr of osa:%p,\\taddr:%p \\t content:%v\\n&quot;,osa,sa,sa);</span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">---</span><br><span class=\"line\">Running...</span><br><span class=\"line\"></span><br><span class=\"line\">addr of osa:0xc20800a220,    addr:0xc20801e020      content:&amp;[0]</span><br><span class=\"line\">addr of osa:0xc20801e0a0,    addr:0xc20801e020      content:&amp;[0 1]</span><br><span class=\"line\">addr of osa:0xc20803e0c0,    addr:0xc20801e020      content:&amp;[0 1 2]</span><br><span class=\"line\">addr of osa:0xc20803e0c0,    addr:0xc20801e020      content:&amp;[0 1 2 3]</span><br><span class=\"line\">addr of osa:0xc208050080,    addr:0xc20801e020      content:&amp;[0 1 2 3 4]</span><br><span class=\"line\">addr of osa:0xc208050080,    addr:0xc20801e020      content:&amp;[0 1 2 3 4 5]</span><br><span class=\"line\">addr of osa:0xc208050080,    addr:0xc20801e020      content:&amp;[0 1 2 3 4 5 6]</span><br><span class=\"line\">addr of osa:0xc208050080,    addr:0xc20801e020      content:&amp;[0 1 2 3 4 5 6 7]</span><br><span class=\"line\">addr of osa:0xc208052000,    addr:0xc20801e020      content:&amp;[0 1 2 3 4 5 6 7 8]</span><br><span class=\"line\">addr of osa:0xc208052000,    addr:0xc20801e020      content:&amp;[0 1 2 3 4 5 6 7 8 9]</span><br><span class=\"line\">addr of osa:0xc208052000,    addr:0xc20801e020      content:&amp;[0 1 2 3 4 5 6 7 8 9]</span><br></pre></td></tr></table></figure>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjlqdfcw20000owv3q8mb2ixf","tag_id":"cjlqdfcwd0003owv30g694ore","_id":"cjlqdfcwn0008owv307h2qy77"},{"post_id":"cjlqdfcwa0002owv3o6incsb0","tag_id":"cjlqdfcwm0007owv3gkgvhat8","_id":"cjlqdfcwv000dowv3fxdv61ry"},{"post_id":"cjlqdfcwg0004owv3l8oavpdj","tag_id":"cjlqdfcwm0007owv3gkgvhat8","_id":"cjlqdfcwz000howv3fsnopaes"},{"post_id":"cjlqdfcwh0005owv3q4l72zy8","tag_id":"cjlqdfcwm0007owv3gkgvhat8","_id":"cjlqdfcx1000jowv35vupxh8t"},{"post_id":"cjlqdfcwl0006owv3vkp0scy5","tag_id":"cjlqdfcx0000iowv3swjf4gwk","_id":"cjlqdfcx2000lowv3zcub01lx"},{"post_id":"cjlqdfcwn0009owv3anmmi3d5","tag_id":"cjlqdfcx0000iowv3swjf4gwk","_id":"cjlqdfcx3000nowv30rnvcgbt"},{"post_id":"cjlqdfcwp000aowv3oog27ofq","tag_id":"cjlqdfcx3000mowv3cyt0irhh","_id":"cjlqdfcx4000powv3mc3oktql"},{"post_id":"cjlqdfcws000cowv3sjhcafa6","tag_id":"cjlqdfcx4000oowv3pbb9rvn6","_id":"cjlqdfcx5000rowv3lblhz5b4"},{"post_id":"cjlqdfcwv000eowv3g9v7z5qm","tag_id":"cjlqdfcx4000oowv3pbb9rvn6","_id":"cjlqdfcx6000towv3ym4a0r44"},{"post_id":"cjlqdfcwy000gowv33b3ndg0a","tag_id":"cjlqdfcx0000iowv3swjf4gwk","_id":"cjlqdfcx7000uowv3bfcqs5lr"}],"Tag":[{"name":"Java","_id":"cjlqdfcwd0003owv30g694ore"},{"name":"p2p","_id":"cjlqdfcwm0007owv3gkgvhat8"},{"name":"Go","_id":"cjlqdfcx0000iowv3swjf4gwk"},{"name":"Netty","_id":"cjlqdfcx3000mowv3cyt0irhh"},{"name":"Docker","_id":"cjlqdfcx4000oowv3pbb9rvn6"}]}}