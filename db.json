{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/next-reloaded/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/avatar1.jpg","path":"images/avatar1.jpg","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1}],"Cache":[{"_id":"themes/next-reloaded/.eslintrc.json","hash":"d3c11de434171d55d70daadd3914bc33544b74b8","modified":1551148141587},{"_id":"themes/next-reloaded/.editorconfig","hash":"211d2c92bfdddb3e81ea946f4ca7a539f150f4da","modified":1551148141586},{"_id":"themes/next-reloaded/.bowerrc","hash":"334da94ca6f024d60d012cc26ea655681e724ad8","modified":1551148141586},{"_id":"themes/next-reloaded/.gitattributes","hash":"8454b9313cb1a97b63fb87e2d29daee497ce6249","modified":1551148141587},{"_id":"themes/next-reloaded/.gitignore","hash":"0378adb9c2dc4855b3198184df4863cb30e4059c","modified":1551148141588},{"_id":"themes/next-reloaded/LICENSE.md","hash":"f0190c7d83a98464549a6b3a51bb206148d88e1b","modified":1551148141589},{"_id":"themes/next-reloaded/README.md","hash":"2d142fa1bdfab00abf8e99f972346e15572c9b12","modified":1551148141589},{"_id":"themes/next-reloaded/bower.json","hash":"72d7f5ef565cca1da30ba64fc04075b9ac99e319","modified":1551148141591},{"_id":"themes/next-reloaded/.travis.yml","hash":"fb9ac54e875f6ea16d5c83db497f6bd70ae83198","modified":1551148141589},{"_id":"themes/next-reloaded/crowdin.yml","hash":"4a53f5985e545c635cb56b2a57ed290cb8cf8942","modified":1551148141591},{"_id":"themes/next-reloaded/.stylintrc","hash":"3b7f9785e9ad0dab764e1c535b40df02f4ff5fd6","modified":1551148141588},{"_id":"themes/next-reloaded/package.json","hash":"735ace0b7fe3b1171c220c5424fcd4fe3aadd7f8","modified":1551148141643},{"_id":"source/_posts/EXPLAIN命令详解.md","hash":"091457ca3fd2a8800ffd93e3b020197fc642d23e","modified":1551148782332},{"_id":"source/_posts/Golang的调度模型概览.md","hash":"0e574e4eebe4c66b02f6c9c84d1e46785c79103c","modified":1551148141538},{"_id":"source/_posts/clone.md","hash":"a835566c7d801425d237a825afc57379bb73f34c","modified":1551148141539},{"_id":"source/_posts/docker.md","hash":"3af994f7789e8bfe479b5775aeaf0c64076f2ce4","modified":1551148141539},{"_id":"source/_posts/error.md","hash":"e091158dd3b169533e1124d370a89ea898f66c24","modified":1551148141540},{"_id":"source/_posts/RUN vs CMD vs ENTRYPOINT.md","hash":"45dbaf5d6b2b25df7bf9c41bdc8c4dd5c0f62751","modified":1551148141539},{"_id":"source/_posts/slice.md","hash":"7550e2d6608b0812c1bd01846f22c566921c84c6","modified":1551148141542},{"_id":"source/_posts/zero-copy.md","hash":"91b39601f661e79c57ba7b72001fb5bbb83b294f","modified":1551148141543},{"_id":"source/tags/index.md","hash":"854520f7a38d51ae4369b966738114f71e61e7e0","modified":1551148141543},{"_id":"themes/next-reloaded/_config.yml","hash":"bfa42f00053466222d1967fed215a6fa7c1b1eae","modified":1551148141590},{"_id":"themes/next-reloaded/docs/ALGOLIA-SEARCH.md","hash":"1dada3c3404445a00367882b8f97cdf092b7943d","modified":1551148141592},{"_id":"themes/next-reloaded/docs/AGPL3.md","hash":"f463f95b169d64983f59fa6f3e4b6760290a0e6b","modified":1551148141592},{"_id":"themes/next-reloaded/docs/AUTHORS.md","hash":"51a0a13da55ff3d596970b2f9ab4531c6b2211f2","modified":1551148141593},{"_id":"themes/next-reloaded/docs/DATA-FILES.md","hash":"9a1895c0a0db705c4c48f512e86917f9af1ec3fb","modified":1551148141593},{"_id":"themes/next-reloaded/docs/INSTALLATION.md","hash":"b74ef6fedf76cdb156e2265759ee0a789ddd49cc","modified":1551148141594},{"_id":"themes/next-reloaded/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"f2fd611a84dd6f9ed5395b63e187e29e9effbcd3","modified":1551148141594},{"_id":"themes/next-reloaded/gulpfile.coffee","hash":"67eaf2515100971f6195b60eeebbfe5e8de895ab","modified":1551148141601},{"_id":"themes/next-reloaded/docs/MATH.md","hash":"34a46ca9a05b4570903beaadd4807e6759afb52e","modified":1551148141595},{"_id":"themes/next-reloaded/docs/UPDATE-FROM-5.1.X.md","hash":"c9f2ed8e15c137b1885d9ca8b7197d9f457971e9","modified":1551148141595},{"_id":"themes/next-reloaded/languages/de.yml","hash":"641e49587d41bb87e4d5932dc3d975754ded7953","modified":1551148141602},{"_id":"themes/next-reloaded/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1551148141602},{"_id":"themes/next-reloaded/languages/en.yml","hash":"d66b8b48840443a4f9c72c7696a21e292f685a47","modified":1551148141603},{"_id":"themes/next-reloaded/docs/LICENSE","hash":"5b702310012d480b40529fd10cf1872f687277a0","modified":1551148141594},{"_id":"themes/next-reloaded/languages/fr.yml","hash":"ebcd1f188af8c3f5ef1f0923e794c839fbfae2d4","modified":1551148141603},{"_id":"themes/next-reloaded/languages/it.yml","hash":"4e3adeb10c0fa627935d69ae1783ce0894f5dee5","modified":1551148141604},{"_id":"themes/next-reloaded/languages/id.yml","hash":"9709a4dbacc56a1571a96b139b872128d6959e90","modified":1551148141603},{"_id":"themes/next-reloaded/languages/pt-BR.yml","hash":"dc09e290e908744ca28e093dbdd859ca2a20290e","modified":1551148141605},{"_id":"themes/next-reloaded/languages/nl.yml","hash":"060efc260c1c529469d739d97dcee79683e8f411","modified":1551148141605},{"_id":"themes/next-reloaded/languages/ja.yml","hash":"7836f1de1f383d3a53770a03498cc39a37674f0c","modified":1551148141604},{"_id":"themes/next-reloaded/languages/pt.yml","hash":"53e2a52b9d5dc20c04080acd4f5b954e8699780f","modified":1551148141606},{"_id":"themes/next-reloaded/languages/tr.yml","hash":"6d2f53d3687a7a46c67c78ab47908accd8812add","modified":1551148141606},{"_id":"themes/next-reloaded/languages/ru.yml","hash":"720b92a9ec075b68737d296b1f29ad8e01151c85","modified":1551148141606},{"_id":"themes/next-reloaded/languages/ko.yml","hash":"33e065ceb21590b8eb32430a69e76c2f057eb758","modified":1551148141605},{"_id":"themes/next-reloaded/languages/vi.yml","hash":"e2b3b18359ab41d58c64b2002acfedd60a7505a4","modified":1551148141607},{"_id":"themes/next-reloaded/languages/zh-HK.yml","hash":"c22113c4a6c748c18093dae56da5a9e8c5b963cd","modified":1551148141607},{"_id":"themes/next-reloaded/languages/zh-TW.yml","hash":"dbf4dd87716babb2db4f5332fae9ec190a6f636a","modified":1551148141608},{"_id":"themes/next-reloaded/languages/zh-CN.yml","hash":"069f15da910d6f9756be448167c07ea5aa5dc346","modified":1551148141607},{"_id":"themes/next-reloaded/layout/archive.swig","hash":"4b53070008775ecfd03953bd1b4adfcb0fabcaac","modified":1551148141640},{"_id":"themes/next-reloaded/layout/category.swig","hash":"f0e3338bfa5efb205d2c28e635e9611f1fff3b55","modified":1551148141641},{"_id":"themes/next-reloaded/layout/index.swig","hash":"bdcc9f57adef49706b16b107791cacecbc23c1dc","modified":1551148141641},{"_id":"themes/next-reloaded/layout/_layout.swig","hash":"2db9b03efc68be842b8f79fe2f0fd7fb09e8885a","modified":1551148141609},{"_id":"themes/next-reloaded/layout/post.swig","hash":"0554f42f90f4a524666c2b520be30b689c1d6a87","modified":1551148141642},{"_id":"themes/next-reloaded/layout/page.swig","hash":"9ddf40303f82e3db76d59dc82b6d4eadfed203c6","modified":1551148141641},{"_id":"themes/next-reloaded/layout/schedule.swig","hash":"d99b9eff0cff38caf095445f27c08aaf11a5b862","modified":1551148141642},{"_id":"themes/next-reloaded/scripts/helpers.js","hash":"7849f9b9a86fc82d6e186e32a5e26e1f27c49b47","modified":1551148141643},{"_id":"themes/next-reloaded/scripts/merge-configs.js","hash":"5f96f63e86825fd7028c2522e4111103e261a758","modified":1551148141643},{"_id":"themes/next-reloaded/scripts/merge.js","hash":"39b84b937b2a9608b94e5872349a47200e1800ff","modified":1551148141644},{"_id":"themes/next-reloaded/test/.jshintrc","hash":"c9fca43ae0d99718e45a6f5ce736a18ba5fc8fb6","modified":1551148141719},{"_id":"themes/next-reloaded/test/intern.js","hash":"db90b1063356727d72be0d77054fdc32fa882a66","modified":1551148141720},{"_id":"themes/next-reloaded/test/helpers.js","hash":"f25e7f3265eb5a6e1ccbb5e5012fa9bebf134105","modified":1551148141719},{"_id":"themes/next-reloaded/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1551148141692},{"_id":"themes/next-reloaded/layout/tag.swig","hash":"7cda2822e50b9fee9848a6b81e6c2d1aca830aeb","modified":1551148141642},{"_id":"themes/next-reloaded/docs/ru/DATA-FILES.md","hash":"a51de08657f5946f4028b11373280ddc04639525","modified":1551148141596},{"_id":"themes/next-reloaded/docs/ru/INSTALLATION.md","hash":"7b2963daac19b0c14f98ebef375d5fbce8fc3f44","modified":1551148141596},{"_id":"themes/next-reloaded/docs/ru/README.md","hash":"bbe7ac3ef6352b7fedbba2ab800915e33251adf8","modified":1551148141597},{"_id":"themes/next-reloaded/docs/ru/UPDATE-FROM-5.1.X.md","hash":"1a4e41adcf5831057f3f7b3025ed4a5ef7c442b4","modified":1551148141597},{"_id":"themes/next-reloaded/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"e771c5b745608c6fb5ae2fa1c06c61b3699627ec","modified":1551148141597},{"_id":"themes/next-reloaded/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"9b512cb820627fcc45c9f77c7a122aa99e021bd5","modified":1551148141598},{"_id":"themes/next-reloaded/docs/zh-CN/CONTRIBUTING.md","hash":"f2a2d6e68c5f65e27303b40f5285a8a4a5adae4c","modified":1551148141598},{"_id":"themes/next-reloaded/docs/zh-CN/DATA-FILES.md","hash":"67f4a987e7db0ab1ce1ea4c311f2961df07b6681","modified":1551148141599},{"_id":"themes/next-reloaded/docs/zh-CN/INSTALLATION.md","hash":"baca12cc24be082f1db28c7f283493569666321c","modified":1551148141599},{"_id":"themes/next-reloaded/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"7214fcd1b5830e62b3ac0836ad2d1b0fa391ae12","modified":1551148141600},{"_id":"themes/next-reloaded/docs/zh-CN/MATH.md","hash":"4d68054b062b3c8404b146a155d9624d2d25dd9b","modified":1551148141600},{"_id":"themes/next-reloaded/docs/zh-CN/README.md","hash":"74547943ee6cba2e2bbbd67d306ee4de9db1a2bd","modified":1551148141600},{"_id":"themes/next-reloaded/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"2095d1214a4e519a1d31b67b41c89080fa3285d3","modified":1551148141601},{"_id":"themes/next-reloaded/layout/_custom/header.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1551148141609},{"_id":"themes/next-reloaded/layout/_custom/sidebar.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1551148141609},{"_id":"themes/next-reloaded/layout/_custom/head.swig","hash":"a223919d2e1bf17ca4d6abb2c86f2efca9883dc1","modified":1551148141608},{"_id":"themes/next-reloaded/layout/_macro/post-copyright.swig","hash":"8ff97c3f4eb888207bdc50066053c97d890e0202","modified":1551148141611},{"_id":"themes/next-reloaded/layout/_macro/post-related.swig","hash":"e8dfb86eb62b9c2bc1435d6d1afa95d3b4c7b931","modified":1551148141612},{"_id":"themes/next-reloaded/layout/_macro/reward.swig","hash":"56733f92352b891b0bb1baca293f68f6c8928b0b","modified":1551148141612},{"_id":"themes/next-reloaded/layout/_macro/post-collapse.swig","hash":"8c56dd26157cbc580ae41d97ac34b90ab48ced3f","modified":1551148141611},{"_id":"themes/next-reloaded/layout/_macro/sidebar.swig","hash":"a9519b4f82aa516e516317d0447bf5c5c7ffb544","modified":1551148141613},{"_id":"themes/next-reloaded/layout/_macro/wechat-subscriber.swig","hash":"7a9b687087793bf5e218cbc345214f927fa5601a","modified":1551148141613},{"_id":"themes/next-reloaded/layout/_macro/post.swig","hash":"00cd242c032341ab0fb5d7f66d4a9aa652eab183","modified":1551148141612},{"_id":"themes/next-reloaded/layout/_partials/page-header.swig","hash":"206cbd6ac9ca6a219a8516f59beae25b3c770199","modified":1551148141618},{"_id":"themes/next-reloaded/layout/_partials/footer.swig","hash":"0d815fc14e58f9ec00b310f7b1d32cc460254610","modified":1551148141614},{"_id":"themes/next-reloaded/layout/_partials/breadcrumb.swig","hash":"4b48fdbfe3bf41ddeda4ff74c1ff17ab9f15c14e","modified":1551148141614},{"_id":"themes/next-reloaded/layout/_partials/comments.swig","hash":"412d2a0e18a237e490e1b8bce5547558768b9da3","modified":1551148141614},{"_id":"themes/next-reloaded/layout/_scripts/boostrap.swig","hash":"27fb1d81151b9b79683e488579df19eee7e654d6","modified":1551148141622},{"_id":"themes/next-reloaded/layout/_scripts/noscript.swig","hash":"f8c7e729ad6e72b4c705a2c5d5041589c2b4cc52","modified":1551148141622},{"_id":"themes/next-reloaded/layout/_scripts/commons.swig","hash":"f544e21883d249d5a341c684c97bd25831008f07","modified":1551148141622},{"_id":"themes/next-reloaded/layout/_partials/pagination.swig","hash":"914155d5d758306cff405beefd4a07973fd8fc77","modified":1551148141618},{"_id":"themes/next-reloaded/layout/_third-party/exturl.swig","hash":"53861f78a1fb52e96a43cf6909e1530dcf6cbff8","modified":1551148141634},{"_id":"themes/next-reloaded/layout/_third-party/bookmark.swig","hash":"ed62ea83d3f2c9db2ea57bf23a7d765ed82504c2","modified":1551148141630},{"_id":"themes/next-reloaded/layout/_scripts/vendors.swig","hash":"f134aeb8d5bee351e5277edb92ac694af314b75f","modified":1551148141625},{"_id":"themes/next-reloaded/layout/_third-party/copy-code.swig","hash":"c62c37474c8de78cf34e54c6219b503ec28d9815","modified":1551148141633},{"_id":"themes/next-reloaded/layout/_third-party/github-banner.swig","hash":"736cb278fa09d3b4ed6f305b56353941ea918793","modified":1551148141634},{"_id":"themes/next-reloaded/layout/_third-party/pangu.swig","hash":"ccf0035086e14dcefa24c2907301edf4c37d5448","modified":1551148141636},{"_id":"themes/next-reloaded/layout/_third-party/needsharebutton.swig","hash":"debba9b7110f635204a15df148194d4c2fd2668b","modified":1551148141636},{"_id":"themes/next-reloaded/scripts/tags/button.js","hash":"510f3711a9c9d3e2a844250647d90e8359e7d130","modified":1551148141645},{"_id":"themes/next-reloaded/layout/_third-party/scroll-cookie.swig","hash":"a174d4a0c9188f9c4a2652f49bfa7a60ad0a83e3","modified":1551148141637},{"_id":"themes/next-reloaded/scripts/tags/exturl.js","hash":"83e48148d2f4f8543f6833effa8a26eb0b60f2f0","modified":1551148141645},{"_id":"themes/next-reloaded/scripts/tags/full-image.js","hash":"ef2c2985a3edb9f69740740c5bc42d4b692c86fd","modified":1551148141646},{"_id":"themes/next-reloaded/scripts/tags/group-pictures.js","hash":"2b969ca830862b2bc119b69ede4bd971e27a6ff8","modified":1551148141646},{"_id":"themes/next-reloaded/scripts/tags/include-raw.js","hash":"c68b1e6d4a8236d6731e4175ef3ddc284255d63b","modified":1551148141646},{"_id":"themes/next-reloaded/scripts/tags/label.js","hash":"bb502616bfabe85de5de903074ec6afe627f8413","modified":1551148141647},{"_id":"themes/next-reloaded/scripts/tags/note.js","hash":"bd3310a5890bded1bda9ba3ad6f98ee44ecb101a","modified":1551148141647},{"_id":"themes/next-reloaded/scripts/tags/tabs.js","hash":"2d257e26718d4011509fd6f530d2ea37e50e3e66","modified":1551148141647},{"_id":"themes/next-reloaded/scripts/tags/center-quote.js","hash":"4519ab8e6898f2ee90d05cde060375462b937a7d","modified":1551148141645},{"_id":"themes/next-reloaded/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1551148141694},{"_id":"themes/next-reloaded/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1551148141694},{"_id":"themes/next-reloaded/layout/_third-party/rating.swig","hash":"554ec568e9d2c71e4a624a8de3cb5929050811d6","modified":1551148141637},{"_id":"themes/next-reloaded/source/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1551148141693},{"_id":"themes/next-reloaded/source/images/avatar.jpg","hash":"abeef73a074adf043ede2795088e057b243771e5","modified":1551148141695},{"_id":"themes/next-reloaded/source/images/avatar1.jpg","hash":"d808844328d91f9e6dd781110de936cd5bb66017","modified":1551148141695},{"_id":"themes/next-reloaded/layout/_third-party/schedule.swig","hash":"db15d7e1552aa2d2386a6b8a33b3b3a40bf9e43d","modified":1551148141637},{"_id":"themes/next-reloaded/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1551148141695},{"_id":"themes/next-reloaded/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1551148141696},{"_id":"themes/next-reloaded/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1551148141697},{"_id":"themes/next-reloaded/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1551148141698},{"_id":"themes/next-reloaded/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1551148141696},{"_id":"themes/next-reloaded/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1551148141698},{"_id":"themes/next-reloaded/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1551148141699},{"_id":"themes/next-reloaded/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1551148141698},{"_id":"themes/next-reloaded/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1551148141697},{"_id":"themes/next-reloaded/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1551148141697},{"_id":"themes/next-reloaded/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1551148141699},{"_id":"themes/next-reloaded/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1551148141700},{"_id":"themes/next-reloaded/source/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1551148141699},{"_id":"themes/next-reloaded/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1551148141624},{"_id":"themes/next-reloaded/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1551148141624},{"_id":"themes/next-reloaded/source/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1551148141700},{"_id":"themes/next-reloaded/source/images/_avatar.jpg","hash":"427a2fbf06958e47005a559f9a4d0dfef320bdf3","modified":1551148141693},{"_id":"themes/next-reloaded/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1551148141678},{"_id":"themes/next-reloaded/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1551148141679},{"_id":"themes/next-reloaded/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1551148141680},{"_id":"themes/next-reloaded/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1551148141690},{"_id":"themes/next-reloaded/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1551148141691},{"_id":"themes/next-reloaded/source/css/main.styl","hash":"2a62e2a11e9cdcc69e538d856d6f9ce228a07c93","modified":1551148141692},{"_id":"themes/next-reloaded/source/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1551148141700},{"_id":"themes/next-reloaded/layout/_macro/menu/menu-item.swig","hash":"aab518204d3125e948796a9ba6b56b09cade2d92","modified":1551148141611},{"_id":"themes/next-reloaded/layout/_partials/head/external-fonts.swig","hash":"f5e487b0d213ca0bd94aa30bc23b240d65081627","modified":1551148141615},{"_id":"themes/next-reloaded/layout/_partials/header/brand.swig","hash":"19050627bc23b0b2c2e65e7248c0f88468eb8ea5","modified":1551148141616},{"_id":"themes/next-reloaded/layout/_partials/head/head-unique.swig","hash":"0b8349710caf9691741a457aa746add35245048e","modified":1551148141615},{"_id":"themes/next-reloaded/layout/_partials/header/index.swig","hash":"c909f6e96373c151dea325bcddfdd8c9522421b6","modified":1551148141617},{"_id":"themes/next-reloaded/layout/_macro/menu/menu-badge.swig","hash":"4eb8e222dc337211efb0d3bbdb5e29af3e6ecdb8","modified":1551148141610},{"_id":"themes/next-reloaded/layout/_partials/header/menu.swig","hash":"f3ae3168801304af3d80ec3b84264e1d4201cb89","modified":1551148141617},{"_id":"themes/next-reloaded/layout/_partials/header/sub-menu.swig","hash":"3f11ae8e9084f39628cd2006931d39a2069b9dd6","modified":1551148141618},{"_id":"themes/next-reloaded/layout/_partials/head/head.swig","hash":"09109a5c5a301e7cc5e3c7aec32b0164739fc7d4","modified":1551148141616},{"_id":"themes/next-reloaded/layout/_partials/search/localsearch.swig","hash":"b2f0d247b213e4cf8de47af6a304d98070cc7256","modified":1551148141619},{"_id":"themes/next-reloaded/layout/_partials/search/index.swig","hash":"f6454c452b2e90a8c760321bce7e3dc6119b71fa","modified":1551148141619},{"_id":"themes/next-reloaded/layout/_partials/search/tinysou.swig","hash":"b25002a83cbd2ca0c4a5df87ad5bff26477c0457","modified":1551148141620},{"_id":"themes/next-reloaded/layout/_partials/share/add-this.swig","hash":"9e3d133ac5bcc6cb51702c83b2611a49811abad1","modified":1551148141620},{"_id":"themes/next-reloaded/layout/_partials/share/duoshuo_share.swig","hash":"d4fbffd7fa8f2090eb32a871872665d90a885fac","modified":1551148141621},{"_id":"themes/next-reloaded/layout/_partials/search/swiftype.swig","hash":"a8c7f9ca7c605d039a1f3bf4e4d3183700a3dd62","modified":1551148141619},{"_id":"themes/next-reloaded/layout/_scripts/schemes/gemini.swig","hash":"c381f638315a007b1baf5fea879161001fe50cd0","modified":1551148141624},{"_id":"themes/next-reloaded/layout/_third-party/analytics/analytics-with-widget.swig","hash":"ff947f3561b229bc528cb1837d4ca19612219411","modified":1551148141625},{"_id":"themes/next-reloaded/layout/_scripts/schemes/pisces.swig","hash":"c381f638315a007b1baf5fea879161001fe50cd0","modified":1551148141624},{"_id":"themes/next-reloaded/layout/_third-party/analytics/busuanzi-counter.swig","hash":"c43f41b7f3c0743d1e673af2e787ea34a67fc9cb","modified":1551148141626},{"_id":"themes/next-reloaded/layout/_third-party/analytics/cnzz-analytics.swig","hash":"a10b7f19d7b5725527514622899df413a34a89db","modified":1551148141627},{"_id":"themes/next-reloaded/layout/_third-party/analytics/application-insights.swig","hash":"71397a5823e8ec8aad3b68aace13150623b3e19d","modified":1551148141626},{"_id":"themes/next-reloaded/layout/_partials/share/baidushare.swig","hash":"d9e2d9282f9be6e04eae105964abb81e512bffed","modified":1551148141621},{"_id":"themes/next-reloaded/layout/_third-party/analytics/baidu-analytics.swig","hash":"753d262911c27baf663fcaf199267133528656af","modified":1551148141626},{"_id":"themes/next-reloaded/layout/_third-party/analytics/facebook-sdk.swig","hash":"7d94845f96197d9d84a405fa5d4ede75fb81b225","modified":1551148141627},{"_id":"themes/next-reloaded/layout/_third-party/analytics/index.swig","hash":"45f3f629c2aacc381095750e1c8649041a71a84b","modified":1551148141629},{"_id":"themes/next-reloaded/layout/_third-party/analytics/google-analytics.swig","hash":"cfc932c5db04fef64cc56d3ba0b8ddf3a15a63bd","modified":1551148141628},{"_id":"themes/next-reloaded/layout/_third-party/analytics/firestore.swig","hash":"d67d9a176a276cdab6f2bcb7eb3650fbca5459c4","modified":1551148141627},{"_id":"themes/next-reloaded/layout/_third-party/analytics/tencent-analytics.swig","hash":"8a399df90dadba5ad4e781445b58f4765aeb701e","modified":1551148141630},{"_id":"themes/next-reloaded/layout/_third-party/analytics/tencent-mta.swig","hash":"5a8027328f060f965b3014060bebec1d7cf149c1","modified":1551148141630},{"_id":"themes/next-reloaded/layout/_scripts/pages/post-details.swig","hash":"580e9d9c4d8783ee6200d845ae16c98979bf1ea3","modified":1551148141623},{"_id":"themes/next-reloaded/layout/_third-party/analytics/vkontakte-api.swig","hash":"f9a1647a8f1866deeb94052d1f87a5df99cb1e70","modified":1551148141630},{"_id":"themes/next-reloaded/layout/_third-party/analytics/lean-analytics.swig","hash":"809f6d31c24ee0012e12631f5893a79f69e7bc84","modified":1551148141629},{"_id":"themes/next-reloaded/layout/_third-party/comments/index.swig","hash":"34cc66d4dbada2d561ba6f70fd9a75207c5adbd4","modified":1551148141632},{"_id":"themes/next-reloaded/layout/_third-party/comments/disqus.swig","hash":"4a2d2269f23e90c1311bd867d22def0b4a092bf1","modified":1551148141631},{"_id":"themes/next-reloaded/layout/_third-party/comments/gitment.swig","hash":"292cdd1059b76d3d10486b71c99d9afb3e59ea44","modified":1551148141632},{"_id":"themes/next-reloaded/layout/_third-party/comments/livere.swig","hash":"694483f2d853c65b87a6a70e38dbc40e40eb1332","modified":1551148141632},{"_id":"themes/next-reloaded/layout/_third-party/math/index.swig","hash":"30e9e55d9af2ced6e6b156a042026a8b480f0ab0","modified":1551148141635},{"_id":"themes/next-reloaded/layout/_third-party/math/katex.swig","hash":"860de4ce6fccc516d2f779a4b600a4214d8c18e2","modified":1551148141635},{"_id":"themes/next-reloaded/layout/_third-party/comments/valine.swig","hash":"d05e70a416963023ee1978e4168d58bcfd956ed3","modified":1551148141633},{"_id":"themes/next-reloaded/layout/_third-party/comments/changyan.swig","hash":"4c501ea0b9c494181eb3c607c5526a5754e7fbd8","modified":1551148141631},{"_id":"themes/next-reloaded/layout/_third-party/search/index.swig","hash":"34599633658f3b0ffb487728b7766e1c7b551f5a","modified":1551148141638},{"_id":"themes/next-reloaded/layout/_third-party/math/mathjax.swig","hash":"c0c2fd87e71f0beb542aa50c0bc875da5aa5c44b","modified":1551148141636},{"_id":"themes/next-reloaded/source/js/src/affix.js","hash":"ad343aa406fd8181b5f310434817ce98fc2219e3","modified":1551148141701},{"_id":"themes/next-reloaded/source/js/src/algolia-search.js","hash":"84906eeae57bd06744dd20160b93eacf658f97e2","modified":1551148141701},{"_id":"themes/next-reloaded/source/js/src/bootstrap.js","hash":"c7e2a588b679d46379124141bb2f30bc2f3210e2","modified":1551148141702},{"_id":"themes/next-reloaded/source/js/src/exturl.js","hash":"c48aa4b3c0e578a807fd3661e6cd4f3890777437","modified":1551148141702},{"_id":"themes/next-reloaded/source/js/src/js.cookie.js","hash":"1512c751d219577d338ac0780fb2bbd9075d5298","modified":1551148141703},{"_id":"themes/next-reloaded/source/js/src/motion.js","hash":"6b5a2646b775609630b9ff6221fa58b6823a25fa","modified":1551148141703},{"_id":"themes/next-reloaded/source/js/src/post-details.js","hash":"7d309b771e86c7e22ce11cc25625481ef7d5985c","modified":1551148141703},{"_id":"themes/next-reloaded/source/js/src/scrollspy.js","hash":"68d3690152c89e7adb08bb35ec28dbda2bd93686","modified":1551148141705},{"_id":"themes/next-reloaded/source/js/src/scroll-cookie.js","hash":"c4867626afab749404daf321367f9b6b8e223f69","modified":1551148141704},{"_id":"themes/next-reloaded/source/js/src/utils.js","hash":"9cddff04f9ff64b1e3202e1726eff512a2ef8497","modified":1551148141705},{"_id":"themes/next-reloaded/source/css/_mixins/Gemini.styl","hash":"07f7da320689f828f6e36a6123807964a45157a0","modified":1551148141678},{"_id":"themes/next-reloaded/layout/_third-party/seo/baidu-push.swig","hash":"d8c98938719284fa06492c114d99a1904652a555","modified":1551148141640},{"_id":"themes/next-reloaded/source/css/_custom/custom.styl","hash":"3403fdd8efde1a0afd11ae8a5a97673f5903087f","modified":1551148141678},{"_id":"themes/next-reloaded/layout/_third-party/search/tinysou.swig","hash":"fe95dd3d166634c466e19aa756e65ad6e8254d3e","modified":1551148141639},{"_id":"themes/next-reloaded/source/css/_mixins/Pisces.styl","hash":"8aa98ae349908736ba43196c42498fd5bdeb780a","modified":1551148141679},{"_id":"themes/next-reloaded/source/css/_variables/Mist.styl","hash":"a25408534f8fe6e321db4bbf9dd03335d648fe17","modified":1551148141690},{"_id":"themes/next-reloaded/source/css/_mixins/base.styl","hash":"0882d76333ab409e8d3362c284b91a0f0ae761ae","modified":1551148141679},{"_id":"themes/next-reloaded/layout/_third-party/search/localsearch.swig","hash":"71c897f9b107dd0de1b7f649633cf583c206a9db","modified":1551148141639},{"_id":"themes/next-reloaded/source/css/_variables/Gemini.styl","hash":"8d6cf29f63c90364f4d3c336f7c9bb794b4c46cc","modified":1551148141690},{"_id":"themes/next-reloaded/source/lib/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1551148141713},{"_id":"themes/next-reloaded/source/lib/velocity/velocity.ui.js","hash":"dbbfb50f6502f6b81dcc9fee7b31f1e812da3464","modified":1551148141714},{"_id":"themes/next-reloaded/source/lib/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1551148141716},{"_id":"themes/next-reloaded/source/lib/jquery/index.js","hash":"17a740d68a1c330876c198b6a4d9319f379f3af2","modified":1551148141707},{"_id":"themes/next-reloaded/source/css/_variables/Pisces.styl","hash":"72927abd51d3a607a6ba32cf882390792b34e834","modified":1551148141691},{"_id":"themes/next-reloaded/source/css/_variables/base.styl","hash":"1625e3e1da6c453108526e027dae25e311b18adf","modified":1551148141691},{"_id":"themes/next-reloaded/source/js/src/schemes/pisces.js","hash":"6ed3f2389457daa382de96a08633d9faaaaf53fb","modified":1551148141704},{"_id":"themes/next-reloaded/source/css/_common/components/back-to-top-sidebar.styl","hash":"8f86f694c0749a18ab3ad6f6df75466ca137a4bc","modified":1551148141648},{"_id":"themes/next-reloaded/layout/_third-party/search/algolia-search/dom.swig","hash":"2530de0f3125a912756f6c0e9090cd012134a4c5","modified":1551148141638},{"_id":"themes/next-reloaded/source/css/_common/components/back-to-top.styl","hash":"237d185ac62ec9877e300947fa0109c44fb8db19","modified":1551148141649},{"_id":"themes/next-reloaded/layout/_third-party/search/algolia-search/assets.swig","hash":"6e076b5e183eedf425a445e99851f938789c3194","modified":1551148141638},{"_id":"themes/next-reloaded/source/css/_common/components/buttons.styl","hash":"8b32928686c327151e13d3ab100157f9a03cd59f","modified":1551148141650},{"_id":"themes/next-reloaded/source/css/_common/components/components.styl","hash":"7ad4081466b397e2a6204141bb7768b7c01bd93c","modified":1551148141650},{"_id":"themes/next-reloaded/source/css/_common/components/comments.styl","hash":"ff4489cd582f518bba6909a301ac1292a38b4e96","modified":1551148141650},{"_id":"themes/next-reloaded/source/css/_common/components/tag-cloud.styl","hash":"6eb4bcc3056bd279d000607e8b4dad50d368ca69","modified":1551148141668},{"_id":"themes/next-reloaded/source/css/_common/components/pagination.styl","hash":"4f2801fc4cf3f31bf2069f41db8c6ce0e3da9e39","modified":1551148141658},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/base.styl","hash":"97bb39756e85f5b27bba7f43270105ad01d736c9","modified":1551148141675},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/mobile.styl","hash":"91ca75492cd51f2553f4d294ed2f48239fcd55eb","modified":1551148141676},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/helpers.styl","hash":"1da5c800d025345f212a3bf1be035060f4e5e6ed","modified":1551148141676},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/normalize.styl","hash":"3f40e8a9fe8e7bd5cfc4cf4cbbbcb9539462e973","modified":1551148141677},{"_id":"themes/next-reloaded/source/css/_common/outline/outline.styl","hash":"fbb6be577529c750ef7c872fe7abdc7ab0faf0f8","modified":1551148141675},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/scaffolding.styl","hash":"a17e2b871a335f290afb392a08f94fd35f59c715","modified":1551148141677},{"_id":"themes/next-reloaded/source/css/_schemes/Mist/_base.styl","hash":"d0e9065b0dbbc01811259f0597d1790268b4881b","modified":1551148141681},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/tables.styl","hash":"52bc8ba71b91d954530b35dfc63b402a02b1321d","modified":1551148141677},{"_id":"themes/next-reloaded/source/css/_schemes/Mist/_logo.styl","hash":"b1025c421406d2c24cc92a02ae28c1915b01e240","modified":1551148141681},{"_id":"themes/next-reloaded/source/css/_schemes/Mist/_header.styl","hash":"d0bfd1bef988c76f7d7dd72d88af6f0908a8b0db","modified":1551148141681},{"_id":"themes/next-reloaded/source/css/_schemes/Mist/_posts-expanded.styl","hash":"fa6c00fdaf8f0ca3b690a5a556671745fb67e2c9","modified":1551148141682},{"_id":"themes/next-reloaded/source/css/_schemes/Mist/_menu.styl","hash":"f3aa863adf972569b72f2df6bc6a914e7daace99","modified":1551148141682},{"_id":"themes/next-reloaded/source/css/_schemes/Mist/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1551148141682},{"_id":"themes/next-reloaded/source/css/_schemes/Mist/index.styl","hash":"2ccb9bdc309b7c1ef183a3dbb0a4621bec54a328","modified":1551148141683},{"_id":"themes/next-reloaded/source/css/_schemes/Muse/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1551148141686},{"_id":"themes/next-reloaded/source/css/_schemes/Muse/_layout.styl","hash":"31127dcbf4c7b4ada53ffbf1638b5fe325b7cbc0","modified":1551148141684},{"_id":"themes/next-reloaded/source/css/_schemes/Muse/_menu.styl","hash":"3cc7646583218d16925ced7b70865e63a901d4a7","modified":1551148141685},{"_id":"themes/next-reloaded/source/css/_schemes/Muse/_logo.styl","hash":"748dbfbf9c08e719ddc775958003c64b00d39dab","modified":1551148141685},{"_id":"themes/next-reloaded/source/css/_schemes/Muse/index.styl","hash":"b26f8a3394d8357a5bfd24d9f8bf62d7b4063ebb","modified":1551148141686},{"_id":"themes/next-reloaded/source/css/_schemes/Pisces/_posts.styl","hash":"1f6e2ce674735269599acc6d77b3ea18d31967fc","modified":1551148141688},{"_id":"themes/next-reloaded/source/css/_schemes/Pisces/_layout.styl","hash":"ccf5a4761cb0ce451b5e994cfabf8769248a45c1","modified":1551148141687},{"_id":"themes/next-reloaded/source/css/_schemes/Pisces/_brand.styl","hash":"bce344d3a665b4c55230d2a91eac2ad16d6f32fd","modified":1551148141687},{"_id":"themes/next-reloaded/source/css/_schemes/Pisces/_sub-menu.styl","hash":"be72740313a9a0477b8a22f62e4c8ffa6d23a2e5","modified":1551148141689},{"_id":"themes/next-reloaded/source/css/_schemes/Pisces/_menu.styl","hash":"cc961108b12ab97d9216606ceb1cd1cd31ab20f0","modified":1551148141688},{"_id":"themes/next-reloaded/source/css/_schemes/Pisces/index.styl","hash":"a558803ca81cceae2bdc22c18ef638fcc023681b","modified":1551148141689},{"_id":"themes/next-reloaded/source/css/_schemes/Pisces/_sidebar.styl","hash":"df16dc995eb9ad498df2edcfc3e20528fc9aa133","modified":1551148141689},{"_id":"themes/next-reloaded/source/css/_schemes/Gemini/index.styl","hash":"7e4e499964c2112d47e6f9d2b6e87c31ec8269e2","modified":1551148141680},{"_id":"themes/next-reloaded/source/lib/velocity/velocity.js","hash":"4237c6e9d59da349639de20e559e87c2c0218cfd","modified":1551148141712},{"_id":"themes/next-reloaded/source/css/_common/components/header/headerband.styl","hash":"d63e0cacc53dd375fcc113465a4328c59ff5f2c1","modified":1551148141652},{"_id":"themes/next-reloaded/source/css/_common/components/header/github-banner.styl","hash":"3f3d2a43d1a326bad25b633c8ec9ddd87867224c","modified":1551148141651},{"_id":"themes/next-reloaded/source/css/_common/components/footer/footer.styl","hash":"7dd247c8869fdefb5a007045d00f3ef8ceecf300","modified":1551148141651},{"_id":"themes/next-reloaded/source/css/_common/components/header/site-nav.styl","hash":"1727702eac5d326b5c81a667944a245016668231","modified":1551148141654},{"_id":"themes/next-reloaded/source/css/_common/components/header/header.styl","hash":"34f5ac3c1ed2dd31e9297cc4c0733e71bc2e252f","modified":1551148141652},{"_id":"themes/next-reloaded/source/css/_common/components/header/site-meta.styl","hash":"0656e753f182c9f47fef7304c847b7587a85ef0d","modified":1551148141653},{"_id":"themes/next-reloaded/source/css/_common/components/highlight/diff.styl","hash":"167986d0f649516671ddf7193eebba7b421cd115","modified":1551148141654},{"_id":"themes/next-reloaded/source/css/_common/components/highlight/theme.styl","hash":"7fe4d4d656e86276c17cb4e48a560cb6a4def703","modified":1551148141655},{"_id":"themes/next-reloaded/source/css/_common/components/highlight/highlight.styl","hash":"835c1340571bd6c4ec263c482cf13283fb047e49","modified":1551148141655},{"_id":"themes/next-reloaded/source/css/_common/components/header/menu.styl","hash":"1a0d059799a298fe17c49a44298d32cebde93785","modified":1551148141653},{"_id":"themes/next-reloaded/source/css/_common/components/pages/archive.styl","hash":"b6f3a06a94a6ee5470c956663164d58eda818a64","modified":1551148141656},{"_id":"themes/next-reloaded/source/css/_common/components/pages/pages.styl","hash":"ad4cae23c8e383f4fabc9a2a95bca6055020d22e","modified":1551148141657},{"_id":"themes/next-reloaded/source/css/_common/components/pages/categories.styl","hash":"7fb593f90d74a99c21840679933b9ef6fdc16a61","modified":1551148141656},{"_id":"themes/next-reloaded/source/css/_common/components/pages/breadcrumb.styl","hash":"630be616447a982413030e561bbd3a80ac14b120","modified":1551148141656},{"_id":"themes/next-reloaded/source/css/_common/components/pages/post-detail.styl","hash":"4e3838d7ac81d9ad133960f0f7ed58a44a015285","modified":1551148141657},{"_id":"themes/next-reloaded/source/css/_common/components/pages/schedule.styl","hash":"8cf318644acc8b4978537c263290363e21c7f5af","modified":1551148141657},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-button.styl","hash":"62fbbd32cf5a99ae550c45c763a2c4813a138d01","modified":1551148141658},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-eof.styl","hash":"a200c0a1c5a895ac9dc41e0641a5dfcd766be99b","modified":1551148141660},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-copyright.styl","hash":"caf263d1928496688c0e1419801eafd7e6919ce5","modified":1551148141659},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-expand.styl","hash":"317c9ceda655e9dc373ce8e7b71d20b794fce9a4","modified":1551148141660},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-collapse.styl","hash":"875cbe88d5c7f6248990e2beb97c9828920e7e24","modified":1551148141659},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-gallery.styl","hash":"cd9e214e502697f2f2db84eb721bac57a49b0fce","modified":1551148141660},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-meta.styl","hash":"330c8884efb5612e7eb03986d87d29e8b0651974","modified":1551148141661},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-nav.styl","hash":"27deb3d3a243d30022055dac7dad851024099a8b","modified":1551148141661},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-reading_progress.styl","hash":"82bc7fa5d38d98e98cc25f9a73189024fda25e63","modified":1551148141661},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-reward.styl","hash":"ca88ea6999a61fb905eb6e72eba5f92d4ee31e6e","modified":1551148141662},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-tags.styl","hash":"5a982d8ef3b3623ea5f59e63728990f5623c1b57","modified":1551148141662},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-rtl.styl","hash":"b2495ae5e04dcca610aacadc47881d9e716cd440","modified":1551148141662},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-type.styl","hash":"01567edaea6978628aa5521a122a85434c418bfd","modified":1551148141663},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-title.styl","hash":"adfd6d2d3b34adc4b476a0ea91e19020456a3b1a","modified":1551148141663},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-widgets.styl","hash":"5c3141d58970a0614896b6a62fd7a8a8caf4e401","modified":1551148141663},{"_id":"themes/next-reloaded/source/css/_common/components/post/post.styl","hash":"bb8162bb7c7b0b255a0e8e234eb382a0879a4962","modified":1551148141664},{"_id":"themes/next-reloaded/source/css/_common/components/sidebar/sidebar-author.styl","hash":"debe322cc9e2688ecf38d0b6afcd6b71ad02fbd0","modified":1551148141665},{"_id":"themes/next-reloaded/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"fa57ec9a6f1943c0558856dfba2d6b8faca0cd4d","modified":1551148141664},{"_id":"themes/next-reloaded/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"8dd9a1c6f4f6baa00c2cf01837e7617120cf9660","modified":1551148141665},{"_id":"themes/next-reloaded/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"61f8cea3c01acd600e90e1bc2a07def405503748","modified":1551148141666},{"_id":"themes/next-reloaded/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"11c22f0fb3f6beb13e5a425ec064a4ff974c13b7","modified":1551148141665},{"_id":"themes/next-reloaded/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"1153bb71edf253765145559674390e16dd67c633","modified":1551148141666},{"_id":"themes/next-reloaded/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"9e05a2232faabb41bcebb51d545d897a76f077da","modified":1551148141666},{"_id":"themes/next-reloaded/source/css/_common/components/sidebar/site-state.styl","hash":"e71652d3216e289c8548b1ea2357822c1476a425","modified":1551148141667},{"_id":"themes/next-reloaded/source/css/_common/components/sidebar/sidebar.styl","hash":"94d76e6da600a36d80e2470326ebb6b3be447ccb","modified":1551148141667},{"_id":"themes/next-reloaded/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"a1521d48bb06d8d703753f52a198baa197af7da2","modified":1551148141667},{"_id":"themes/next-reloaded/source/css/_common/components/tags/group-pictures.styl","hash":"2ad1a2a9bbf6742d1b0762c4c623b68113d1e0fe","modified":1551148141669},{"_id":"themes/next-reloaded/source/css/_common/components/tags/full-image.styl","hash":"2d58ad90f148e845bc7023751a7a13260600f8d6","modified":1551148141669},{"_id":"themes/next-reloaded/source/css/_common/components/tags/exturl.styl","hash":"02ee0eb49c256ecb4e71bbc65072f9147418d7d7","modified":1551148141668},{"_id":"themes/next-reloaded/source/css/_common/components/tags/blockquote-center.styl","hash":"2fe76476432b31993338cb45cdb3b29a518b6379","modified":1551148141668},{"_id":"themes/next-reloaded/source/css/_common/components/tags/label.styl","hash":"2ab1322fe52ab5aafd49e68f5bd890e8380ee927","modified":1551148141670},{"_id":"themes/next-reloaded/source/css/_common/components/tags/note-modern.styl","hash":"b7076e58d647265ee0ad2b461fe8ce72c9373bc5","modified":1551148141670},{"_id":"themes/next-reloaded/source/css/_common/components/tags/note.styl","hash":"9a409b798decdefdaf7a23f0b11004a8c27e82f3","modified":1551148141670},{"_id":"themes/next-reloaded/source/css/_common/components/tags/tabs.styl","hash":"154a87a32d2fead480d5e909c37f6c476671c5e6","modified":1551148141671},{"_id":"themes/next-reloaded/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"a6e7d698702c2e383dde3fde2abde27951679084","modified":1551148141672},{"_id":"themes/next-reloaded/source/css/_common/components/third-party/algolia-search.styl","hash":"f4d8144c22544bdb89787c14ab9d39578dae4b7c","modified":1551148141672},{"_id":"themes/next-reloaded/source/css/_common/components/third-party/han.styl","hash":"10599e16414a8b7a76c4e79e6617b5fe3d4d1adf","modified":1551148141673},{"_id":"themes/next-reloaded/source/css/_common/components/third-party/localsearch.styl","hash":"16087276945fa038f199692e3eabb1c52b8ea633","modified":1551148141673},{"_id":"themes/next-reloaded/source/css/_common/components/third-party/needsharebutton.styl","hash":"28825ae15fa20ae3942cdaa7bcc1f3523ce59acc","modified":1551148141673},{"_id":"themes/next-reloaded/source/css/_common/components/third-party/gitment.styl","hash":"874278147115601d2abf15987f5f7a84ada1ac6b","modified":1551148141672},{"_id":"themes/next-reloaded/source/css/_common/components/third-party/third-party.styl","hash":"c31fbaec7e6373ecfb8588500b972d451695a6ad","modified":1551148141674},{"_id":"themes/next-reloaded/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1551148141684},{"_id":"themes/next-reloaded/source/css/_common/components/third-party/related-posts.styl","hash":"acfdd76b1c90d2e384affb3d0006a39b524609d2","modified":1551148141674},{"_id":"themes/next-reloaded/source/css/_common/components/tags/tags.styl","hash":"b80604868e4f5cf20fccafd7ee415c20c804f700","modified":1551148141671},{"_id":"themes/next-reloaded/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1551148141686},{"_id":"themes/next-reloaded/source/css/_schemes/Mist/outline/outline.styl","hash":"a07aa12cc36ac5c819670c2a3c17d07ed7a08986","modified":1551148141683},{"_id":"public/tags/index.html","hash":"5f2daaaffbf498cef060a3f7d6aa3bd54463f656","modified":1551148845999},{"_id":"public/2018/07/16/docker/index.html","hash":"ec3ba0b3fb3bea78134698e56edcec40da2fd50c","modified":1551148846000},{"_id":"public/archives/index.html","hash":"f5331e1fcd40ada160f5c7531119c0159bb5badf","modified":1551148846000},{"_id":"public/archives/page/2/index.html","hash":"bd65e5744fad87be92e917b3cfd7ec1996181cd1","modified":1551148846000},{"_id":"public/archives/2018/index.html","hash":"082711c431cc83d3534827ab797d9bf3bcb46eef","modified":1551148846000},{"_id":"public/archives/2018/page/2/index.html","hash":"1bc6306b8a466519451372a4d4851d38cc22b6c1","modified":1551148846000},{"_id":"public/archives/2018/08/index.html","hash":"eac29b58fac2a2f255fab00ce31a0737cfad0603","modified":1551148846000},{"_id":"public/archives/2018/07/index.html","hash":"fe4edf9859698745e8b2d0a8608df1a18bffe689","modified":1551148846000},{"_id":"public/tags/Java/index.html","hash":"825f1f3178fbdb0df2ff609bf2c21ce31b80ac95","modified":1551148846000},{"_id":"public/tags/Docker/index.html","hash":"a684b3a4878848dc47768b8bb75be902c6a3dd8f","modified":1551148846000},{"_id":"public/tags/Go/index.html","hash":"162bfac13791c89dc766239feffbac8dab0f227e","modified":1551148846001},{"_id":"public/tags/Netty/index.html","hash":"9113ad2f44f009ec5fbad2e6d56412cc28551a6e","modified":1551148846001},{"_id":"public/2018/08/20/zero-copy/index.html","hash":"2edb53d88b54cd3c1217eecf078800bb0e82963f","modified":1551148846001},{"_id":"public/2018/08/17/RUN vs CMD vs ENTRYPOINT/index.html","hash":"2b8628b765d860add0135ef93bbe2c48ab516f51","modified":1551148846001},{"_id":"public/2018/07/27/error/index.html","hash":"aed21ef2c28ffbc2b2ad4ee13f1c0d9d13c5895b","modified":1551148846001},{"_id":"public/2018/08/03/Golang的调度模型概览/index.html","hash":"cf228808d1701a323f6103365b1868a8e1931473","modified":1551148846001},{"_id":"public/2018/07/26/clone/index.html","hash":"da82dd2c32b3efd24ce16c1e6384526eb1fd43d9","modified":1551148846001},{"_id":"public/2018/07/16/slice/index.html","hash":"ca9b4c1586e38d9fbcfecd29a1550463b59f7995","modified":1551148846001},{"_id":"public/index.html","hash":"c811232cef5ecb656234836cc6ec10e379a32f71","modified":1551148846002},{"_id":"public/archives/2019/index.html","hash":"f5319e99cf3bed74ba7d1ad668443f134fb5a5e4","modified":1551148846041},{"_id":"public/archives/2019/02/index.html","hash":"396faa63f8f095756970f0b04b107f3e39a5a3c8","modified":1551148846042},{"_id":"public/2019/02/26/EXPLAIN命令详解/index.html","hash":"96768f2c0444a44759004e3ce10fc31f5df4ab72","modified":1551148846042},{"_id":"public/tags/Mysql/index.html","hash":"f154a766f501638d4f25d7a62cd995ee2244a80d","modified":1551148846044}],"Category":[],"Data":[],"Page":[{"title":"tags","date":"2018-07-30T01:28:29.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2018-07-30 09:28:29\ntype: \"tags\"\n---\n","updated":"2019-02-26T02:29:01.543Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjsl5qftl0001k8v3f95563yq","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"EXPLAIN 命令详解","date":"2019-02-26T02:37:24.000Z","_content":"\n在工作中，我们用于捕捉性能问题最常用的就是打开慢查询，定位执行效率差的SQL，那么当我们定位到一个SQL以后还不算完事，我们还需要知道该SQL的执行计划，比如是全表扫描，还是索引扫描，这些都需要通过EXPLAIN去完成。EXPLAIN命令是查看优化器如何决定执行查询的主要方法。可以帮助我们深入了解MySQL的基于开销的优化器，还可以获得很多可能被优化器考虑到的访问策略的细节，以及当运行SQL语句时哪种策略预计会被优化器采用。需要注意的是，生成的QEP并不确定，它可能会根据很多因素发生改变。MySQL不会将一个QEP和某个给定查询绑定，QEP将由SQL语句每次执行时的实际情况确定，即便使用存储过程也是如此。尽管在存储过程中SQL语句都是预先解析过的，但QEP仍然会在每次调用存储过程的时候才被确定。\n\n## 执行计划包含的信息\n\nid | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |\n---|---|---|---|---|---|---|---|---|---|---\n\n## id\n\n包含一组数字，表示查询中执行select子句或操作表的顺序\n\n1. id相同，执行顺序由上至下\n2. 如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行\n3. id如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id值越大，优先级越高，越先执行\n\n<!-- more -->\n\n## select_type\n\n表示查询中每个select子句的类型（简单OR复杂）\n\n1. SIMPLE：查询中不包含子查询或者UNION\n2. 查询中若包含任何复杂的子部分，最外层查询则被标记为：PRIMARY\n3. 在SELECT或WHERE列表中包含了子查询，该子查询被标记为：SUBQUERY\n4. 在FROM列表中包含的子查询被标记为：DERIVED（衍生）用来表示包含在from子句中的子查询的select，mysql会递归执行并将结果放到一个临时表中。服务器内部称为\"派生表\"，因为该临时表是从子查询中派生出来的\n5. 若第二个SELECT出现在UNION之后，则被标记为UNION；若UNION包含在FROM子句的子查询中，外层SELECT将被标记为：DERIVED\n6. 从UNION表获取结果的SELECT被标记为：UNION RESULT\n\nSUBQUERY和UNION还可以被标记为DEPENDENT和UNCACHEABLE。\nDEPENDENT意味着select依赖于外层查询中发现的数据。\nUNCACHEABLE意味着select中的某些 特性阻止结果被缓存于一个item_cache中。\n\n## type\n\n表示MySQL在表中找到所需行的方式，又称“访问类型”，常见类型如下:\n\nALL, index,  range, ref, eq_ref, const, system, NULL\n\n从左到右，性能从最差到最好\n\n1. ALL：Full Table Scan， MySQL将遍历全表以找到匹配的行\n2. index：Full Index Scan，index与ALL区别为index类型只遍历索引树\n3. range:索引范围扫描，对索引的扫描开始于某一点，返回匹配值域的行。显而易见的索引范围扫描是带有between或者where子句里带有<, >查询。当mysql使用索引去查找一系列值时，例如IN()和OR列表，也会显示range（范围扫描）,当然性能上面是有差异的。\n4. ref：使用非唯一索引扫描或者唯一索引的前缀扫描，返回匹配某个单独值的记录行\n5. eq_ref：类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条件\n6. const、system：当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转换为一个常量\n7. NULL：MySQL在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。\n\n## possible_keys\n\n指出MySQL能使用哪个索引在表中找到记录，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用\n\n## key\n\n显示MySQL在查询中实际使用的索引，若没有使用索引，显示为NULL\n\n## key_len\n\n表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度（key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的）\n\n## ref\n\n表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值\n\n## rows\n\n表示MySQL根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行数\n\n## Extra\n\n包含不适合在其他列中显示但十分重要的额外信息\na. Using index\n该值表示相应的select操作中使用了覆盖索引（Covering Index）\n\n1. 覆盖索引（Covering Index）\nMySQL可以利用索引返回select列表中的字段，而不必根据索引再次读取数据文件\n包含所有满足查询需要的数据的索引称为覆盖索引（Covering Index）\n注意：如果要使用覆盖索引，一定要注意select列表中只取出需要的列，不可select *，因为如果将所有字段一起做索引会导致索引文件过大，查询性能下降\n2. Using where 表示mysql服务器将在存储引擎检索行后再进行过滤。许多where条件里涉及索引中的列，当（并且如果）它读取索引时，就能被存储引擎检验，因此不是所有带where字句的查询都会显示\"Using where\"。有时\"Using where\"的出现就是一个暗示：查询可受益与不同的索引。\n3. Using temporary\n表示MySQL需要使用临时表来存储结果集，常见于排序和分组查询。\n这个值表示使用了内部临时(基于内存的)表。一个查询可能用到多个临时表。有很多原因都会导致MySQL在执行查询期间创建临时表。两个常见的原因是在来自不同表的上使用了DISTINCT,或者使用了不同的ORDER BY和GROUP BY列。可以强制指定一个临时表使用基于磁盘的MyISAM存储引擎。这样做的原因主要有两个：一、内部临时表占用的空间超过min(tmp_table_size，max_heap_table_size)系统变量的限制；二、使用了TEXT/BLOB 列\n4. Using filesort\nMySQL中无法利用索引完成的排序操作称为“文件排序”\n5. Using join buffer\n改值强调了在获取连接条件时没有使用索引，并且需要连接缓冲区来存储中间结果。如果出现了这个值，那应该注意，根据查询的具体情况可能需要添加索引来改进能。\n6. Impossible where\n这个值强调了where语句会导致没有符合条件的行。\n7. Select tables optimized away\n这个值意味着仅通过使用索引，优化器可能仅从聚合函数结果中返回一行.\n8. Index merges\n当MySQL 决定要在一个给定的表上使用超过一个索引的时候，就会出现以下格式中的一个，详细说明使用的索引以及合并的类型。\nUsing sort_union(...)Using union(...)Using intersect(...)\n\n#总结\n- EXPLAIN不会告诉你关于触发器、存储过程的信息或用户自定义函数对查询的影响情况\n- EXPLAIN不考虑各种Cache\n- EXPLAIN不能显示MySQL在执行查询时所作的优化工作\n- 部分统计信息是估算的，并非精确值\n- EXPALIN只能解释SELECT操作，其他操作要重写为SELECT后查看执行计划。\n\n","source":"_posts/EXPLAIN命令详解.md","raw":"---\ntitle: EXPLAIN 命令详解\ndate: 2019-2-26 10:37:24\ntags: Mysql\n---\n\n在工作中，我们用于捕捉性能问题最常用的就是打开慢查询，定位执行效率差的SQL，那么当我们定位到一个SQL以后还不算完事，我们还需要知道该SQL的执行计划，比如是全表扫描，还是索引扫描，这些都需要通过EXPLAIN去完成。EXPLAIN命令是查看优化器如何决定执行查询的主要方法。可以帮助我们深入了解MySQL的基于开销的优化器，还可以获得很多可能被优化器考虑到的访问策略的细节，以及当运行SQL语句时哪种策略预计会被优化器采用。需要注意的是，生成的QEP并不确定，它可能会根据很多因素发生改变。MySQL不会将一个QEP和某个给定查询绑定，QEP将由SQL语句每次执行时的实际情况确定，即便使用存储过程也是如此。尽管在存储过程中SQL语句都是预先解析过的，但QEP仍然会在每次调用存储过程的时候才被确定。\n\n## 执行计划包含的信息\n\nid | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |\n---|---|---|---|---|---|---|---|---|---|---\n\n## id\n\n包含一组数字，表示查询中执行select子句或操作表的顺序\n\n1. id相同，执行顺序由上至下\n2. 如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行\n3. id如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id值越大，优先级越高，越先执行\n\n<!-- more -->\n\n## select_type\n\n表示查询中每个select子句的类型（简单OR复杂）\n\n1. SIMPLE：查询中不包含子查询或者UNION\n2. 查询中若包含任何复杂的子部分，最外层查询则被标记为：PRIMARY\n3. 在SELECT或WHERE列表中包含了子查询，该子查询被标记为：SUBQUERY\n4. 在FROM列表中包含的子查询被标记为：DERIVED（衍生）用来表示包含在from子句中的子查询的select，mysql会递归执行并将结果放到一个临时表中。服务器内部称为\"派生表\"，因为该临时表是从子查询中派生出来的\n5. 若第二个SELECT出现在UNION之后，则被标记为UNION；若UNION包含在FROM子句的子查询中，外层SELECT将被标记为：DERIVED\n6. 从UNION表获取结果的SELECT被标记为：UNION RESULT\n\nSUBQUERY和UNION还可以被标记为DEPENDENT和UNCACHEABLE。\nDEPENDENT意味着select依赖于外层查询中发现的数据。\nUNCACHEABLE意味着select中的某些 特性阻止结果被缓存于一个item_cache中。\n\n## type\n\n表示MySQL在表中找到所需行的方式，又称“访问类型”，常见类型如下:\n\nALL, index,  range, ref, eq_ref, const, system, NULL\n\n从左到右，性能从最差到最好\n\n1. ALL：Full Table Scan， MySQL将遍历全表以找到匹配的行\n2. index：Full Index Scan，index与ALL区别为index类型只遍历索引树\n3. range:索引范围扫描，对索引的扫描开始于某一点，返回匹配值域的行。显而易见的索引范围扫描是带有between或者where子句里带有<, >查询。当mysql使用索引去查找一系列值时，例如IN()和OR列表，也会显示range（范围扫描）,当然性能上面是有差异的。\n4. ref：使用非唯一索引扫描或者唯一索引的前缀扫描，返回匹配某个单独值的记录行\n5. eq_ref：类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条件\n6. const、system：当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转换为一个常量\n7. NULL：MySQL在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。\n\n## possible_keys\n\n指出MySQL能使用哪个索引在表中找到记录，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用\n\n## key\n\n显示MySQL在查询中实际使用的索引，若没有使用索引，显示为NULL\n\n## key_len\n\n表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度（key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的）\n\n## ref\n\n表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值\n\n## rows\n\n表示MySQL根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行数\n\n## Extra\n\n包含不适合在其他列中显示但十分重要的额外信息\na. Using index\n该值表示相应的select操作中使用了覆盖索引（Covering Index）\n\n1. 覆盖索引（Covering Index）\nMySQL可以利用索引返回select列表中的字段，而不必根据索引再次读取数据文件\n包含所有满足查询需要的数据的索引称为覆盖索引（Covering Index）\n注意：如果要使用覆盖索引，一定要注意select列表中只取出需要的列，不可select *，因为如果将所有字段一起做索引会导致索引文件过大，查询性能下降\n2. Using where 表示mysql服务器将在存储引擎检索行后再进行过滤。许多where条件里涉及索引中的列，当（并且如果）它读取索引时，就能被存储引擎检验，因此不是所有带where字句的查询都会显示\"Using where\"。有时\"Using where\"的出现就是一个暗示：查询可受益与不同的索引。\n3. Using temporary\n表示MySQL需要使用临时表来存储结果集，常见于排序和分组查询。\n这个值表示使用了内部临时(基于内存的)表。一个查询可能用到多个临时表。有很多原因都会导致MySQL在执行查询期间创建临时表。两个常见的原因是在来自不同表的上使用了DISTINCT,或者使用了不同的ORDER BY和GROUP BY列。可以强制指定一个临时表使用基于磁盘的MyISAM存储引擎。这样做的原因主要有两个：一、内部临时表占用的空间超过min(tmp_table_size，max_heap_table_size)系统变量的限制；二、使用了TEXT/BLOB 列\n4. Using filesort\nMySQL中无法利用索引完成的排序操作称为“文件排序”\n5. Using join buffer\n改值强调了在获取连接条件时没有使用索引，并且需要连接缓冲区来存储中间结果。如果出现了这个值，那应该注意，根据查询的具体情况可能需要添加索引来改进能。\n6. Impossible where\n这个值强调了where语句会导致没有符合条件的行。\n7. Select tables optimized away\n这个值意味着仅通过使用索引，优化器可能仅从聚合函数结果中返回一行.\n8. Index merges\n当MySQL 决定要在一个给定的表上使用超过一个索引的时候，就会出现以下格式中的一个，详细说明使用的索引以及合并的类型。\nUsing sort_union(...)Using union(...)Using intersect(...)\n\n#总结\n- EXPLAIN不会告诉你关于触发器、存储过程的信息或用户自定义函数对查询的影响情况\n- EXPLAIN不考虑各种Cache\n- EXPLAIN不能显示MySQL在执行查询时所作的优化工作\n- 部分统计信息是估算的，并非精确值\n- EXPALIN只能解释SELECT操作，其他操作要重写为SELECT后查看执行计划。\n\n","slug":"EXPLAIN命令详解","published":1,"updated":"2019-02-26T02:39:42.332Z","_id":"cjsl5qftg0000k8v30i0kcs5q","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在工作中，我们用于捕捉性能问题最常用的就是打开慢查询，定位执行效率差的SQL，那么当我们定位到一个SQL以后还不算完事，我们还需要知道该SQL的执行计划，比如是全表扫描，还是索引扫描，这些都需要通过EXPLAIN去完成。EXPLAIN命令是查看优化器如何决定执行查询的主要方法。可以帮助我们深入了解MySQL的基于开销的优化器，还可以获得很多可能被优化器考虑到的访问策略的细节，以及当运行SQL语句时哪种策略预计会被优化器采用。需要注意的是，生成的QEP并不确定，它可能会根据很多因素发生改变。MySQL不会将一个QEP和某个给定查询绑定，QEP将由SQL语句每次执行时的实际情况确定，即便使用存储过程也是如此。尽管在存储过程中SQL语句都是预先解析过的，但QEP仍然会在每次调用存储过程的时候才被确定。</p>\n<h2 id=\"执行计划包含的信息\"><a href=\"#执行计划包含的信息\" class=\"headerlink\" title=\"执行计划包含的信息\"></a>执行计划包含的信息</h2><table>\n<thead>\n<tr>\n<th>id</th>\n<th>select_type</th>\n<th>table</th>\n<th>type</th>\n<th>possible_keys</th>\n<th>key</th>\n<th>key_len</th>\n<th>ref</th>\n<th>rows</th>\n<th>Extra</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"id\"><a href=\"#id\" class=\"headerlink\" title=\"id\"></a>id</h2><p>包含一组数字，表示查询中执行select子句或操作表的顺序</p>\n<ol>\n<li>id相同，执行顺序由上至下</li>\n<li>如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</li>\n<li>id如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id值越大，优先级越高，越先执行</li>\n</ol>\n<a id=\"more\"></a>\n<h2 id=\"select-type\"><a href=\"#select-type\" class=\"headerlink\" title=\"select_type\"></a>select_type</h2><p>表示查询中每个select子句的类型（简单OR复杂）</p>\n<ol>\n<li>SIMPLE：查询中不包含子查询或者UNION</li>\n<li>查询中若包含任何复杂的子部分，最外层查询则被标记为：PRIMARY</li>\n<li>在SELECT或WHERE列表中包含了子查询，该子查询被标记为：SUBQUERY</li>\n<li>在FROM列表中包含的子查询被标记为：DERIVED（衍生）用来表示包含在from子句中的子查询的select，mysql会递归执行并将结果放到一个临时表中。服务器内部称为”派生表”，因为该临时表是从子查询中派生出来的</li>\n<li>若第二个SELECT出现在UNION之后，则被标记为UNION；若UNION包含在FROM子句的子查询中，外层SELECT将被标记为：DERIVED</li>\n<li>从UNION表获取结果的SELECT被标记为：UNION RESULT</li>\n</ol>\n<p>SUBQUERY和UNION还可以被标记为DEPENDENT和UNCACHEABLE。<br>DEPENDENT意味着select依赖于外层查询中发现的数据。<br>UNCACHEABLE意味着select中的某些 特性阻止结果被缓存于一个item_cache中。</p>\n<h2 id=\"type\"><a href=\"#type\" class=\"headerlink\" title=\"type\"></a>type</h2><p>表示MySQL在表中找到所需行的方式，又称“访问类型”，常见类型如下:</p>\n<p>ALL, index,  range, ref, eq_ref, const, system, NULL</p>\n<p>从左到右，性能从最差到最好</p>\n<ol>\n<li>ALL：Full Table Scan， MySQL将遍历全表以找到匹配的行</li>\n<li>index：Full Index Scan，index与ALL区别为index类型只遍历索引树</li>\n<li>range:索引范围扫描，对索引的扫描开始于某一点，返回匹配值域的行。显而易见的索引范围扫描是带有between或者where子句里带有&lt;, &gt;查询。当mysql使用索引去查找一系列值时，例如IN()和OR列表，也会显示range（范围扫描）,当然性能上面是有差异的。</li>\n<li>ref：使用非唯一索引扫描或者唯一索引的前缀扫描，返回匹配某个单独值的记录行</li>\n<li>eq_ref：类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条件</li>\n<li>const、system：当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转换为一个常量</li>\n<li>NULL：MySQL在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。</li>\n</ol>\n<h2 id=\"possible-keys\"><a href=\"#possible-keys\" class=\"headerlink\" title=\"possible_keys\"></a>possible_keys</h2><p>指出MySQL能使用哪个索引在表中找到记录，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用</p>\n<h2 id=\"key\"><a href=\"#key\" class=\"headerlink\" title=\"key\"></a>key</h2><p>显示MySQL在查询中实际使用的索引，若没有使用索引，显示为NULL</p>\n<h2 id=\"key-len\"><a href=\"#key-len\" class=\"headerlink\" title=\"key_len\"></a>key_len</h2><p>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度（key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的）</p>\n<h2 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h2><p>表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</p>\n<h2 id=\"rows\"><a href=\"#rows\" class=\"headerlink\" title=\"rows\"></a>rows</h2><p>表示MySQL根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行数</p>\n<h2 id=\"Extra\"><a href=\"#Extra\" class=\"headerlink\" title=\"Extra\"></a>Extra</h2><p>包含不适合在其他列中显示但十分重要的额外信息<br>a. Using index<br>该值表示相应的select操作中使用了覆盖索引（Covering Index）</p>\n<ol>\n<li>覆盖索引（Covering Index）<br>MySQL可以利用索引返回select列表中的字段，而不必根据索引再次读取数据文件<br>包含所有满足查询需要的数据的索引称为覆盖索引（Covering Index）<br>注意：如果要使用覆盖索引，一定要注意select列表中只取出需要的列，不可select *，因为如果将所有字段一起做索引会导致索引文件过大，查询性能下降</li>\n<li>Using where 表示mysql服务器将在存储引擎检索行后再进行过滤。许多where条件里涉及索引中的列，当（并且如果）它读取索引时，就能被存储引擎检验，因此不是所有带where字句的查询都会显示”Using where”。有时”Using where”的出现就是一个暗示：查询可受益与不同的索引。</li>\n<li>Using temporary<br>表示MySQL需要使用临时表来存储结果集，常见于排序和分组查询。<br>这个值表示使用了内部临时(基于内存的)表。一个查询可能用到多个临时表。有很多原因都会导致MySQL在执行查询期间创建临时表。两个常见的原因是在来自不同表的上使用了DISTINCT,或者使用了不同的ORDER BY和GROUP BY列。可以强制指定一个临时表使用基于磁盘的MyISAM存储引擎。这样做的原因主要有两个：一、内部临时表占用的空间超过min(tmp_table_size，max_heap_table_size)系统变量的限制；二、使用了TEXT/BLOB 列</li>\n<li>Using filesort<br>MySQL中无法利用索引完成的排序操作称为“文件排序”</li>\n<li>Using join buffer<br>改值强调了在获取连接条件时没有使用索引，并且需要连接缓冲区来存储中间结果。如果出现了这个值，那应该注意，根据查询的具体情况可能需要添加索引来改进能。</li>\n<li>Impossible where<br>这个值强调了where语句会导致没有符合条件的行。</li>\n<li>Select tables optimized away<br>这个值意味着仅通过使用索引，优化器可能仅从聚合函数结果中返回一行.</li>\n<li>Index merges<br>当MySQL 决定要在一个给定的表上使用超过一个索引的时候，就会出现以下格式中的一个，详细说明使用的索引以及合并的类型。<br>Using sort_union(…)Using union(…)Using intersect(…)</li>\n</ol>\n<p>#总结</p>\n<ul>\n<li>EXPLAIN不会告诉你关于触发器、存储过程的信息或用户自定义函数对查询的影响情况</li>\n<li>EXPLAIN不考虑各种Cache</li>\n<li>EXPLAIN不能显示MySQL在执行查询时所作的优化工作</li>\n<li>部分统计信息是估算的，并非精确值</li>\n<li>EXPALIN只能解释SELECT操作，其他操作要重写为SELECT后查看执行计划。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>在工作中，我们用于捕捉性能问题最常用的就是打开慢查询，定位执行效率差的SQL，那么当我们定位到一个SQL以后还不算完事，我们还需要知道该SQL的执行计划，比如是全表扫描，还是索引扫描，这些都需要通过EXPLAIN去完成。EXPLAIN命令是查看优化器如何决定执行查询的主要方法。可以帮助我们深入了解MySQL的基于开销的优化器，还可以获得很多可能被优化器考虑到的访问策略的细节，以及当运行SQL语句时哪种策略预计会被优化器采用。需要注意的是，生成的QEP并不确定，它可能会根据很多因素发生改变。MySQL不会将一个QEP和某个给定查询绑定，QEP将由SQL语句每次执行时的实际情况确定，即便使用存储过程也是如此。尽管在存储过程中SQL语句都是预先解析过的，但QEP仍然会在每次调用存储过程的时候才被确定。</p>\n<h2 id=\"执行计划包含的信息\"><a href=\"#执行计划包含的信息\" class=\"headerlink\" title=\"执行计划包含的信息\"></a>执行计划包含的信息</h2><table>\n<thead>\n<tr>\n<th>id</th>\n<th>select_type</th>\n<th>table</th>\n<th>type</th>\n<th>possible_keys</th>\n<th>key</th>\n<th>key_len</th>\n<th>ref</th>\n<th>rows</th>\n<th>Extra</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"id\"><a href=\"#id\" class=\"headerlink\" title=\"id\"></a>id</h2><p>包含一组数字，表示查询中执行select子句或操作表的顺序</p>\n<ol>\n<li>id相同，执行顺序由上至下</li>\n<li>如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</li>\n<li>id如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id值越大，优先级越高，越先执行</li>\n</ol>","more":"<h2 id=\"select-type\"><a href=\"#select-type\" class=\"headerlink\" title=\"select_type\"></a>select_type</h2><p>表示查询中每个select子句的类型（简单OR复杂）</p>\n<ol>\n<li>SIMPLE：查询中不包含子查询或者UNION</li>\n<li>查询中若包含任何复杂的子部分，最外层查询则被标记为：PRIMARY</li>\n<li>在SELECT或WHERE列表中包含了子查询，该子查询被标记为：SUBQUERY</li>\n<li>在FROM列表中包含的子查询被标记为：DERIVED（衍生）用来表示包含在from子句中的子查询的select，mysql会递归执行并将结果放到一个临时表中。服务器内部称为”派生表”，因为该临时表是从子查询中派生出来的</li>\n<li>若第二个SELECT出现在UNION之后，则被标记为UNION；若UNION包含在FROM子句的子查询中，外层SELECT将被标记为：DERIVED</li>\n<li>从UNION表获取结果的SELECT被标记为：UNION RESULT</li>\n</ol>\n<p>SUBQUERY和UNION还可以被标记为DEPENDENT和UNCACHEABLE。<br>DEPENDENT意味着select依赖于外层查询中发现的数据。<br>UNCACHEABLE意味着select中的某些 特性阻止结果被缓存于一个item_cache中。</p>\n<h2 id=\"type\"><a href=\"#type\" class=\"headerlink\" title=\"type\"></a>type</h2><p>表示MySQL在表中找到所需行的方式，又称“访问类型”，常见类型如下:</p>\n<p>ALL, index,  range, ref, eq_ref, const, system, NULL</p>\n<p>从左到右，性能从最差到最好</p>\n<ol>\n<li>ALL：Full Table Scan， MySQL将遍历全表以找到匹配的行</li>\n<li>index：Full Index Scan，index与ALL区别为index类型只遍历索引树</li>\n<li>range:索引范围扫描，对索引的扫描开始于某一点，返回匹配值域的行。显而易见的索引范围扫描是带有between或者where子句里带有&lt;, &gt;查询。当mysql使用索引去查找一系列值时，例如IN()和OR列表，也会显示range（范围扫描）,当然性能上面是有差异的。</li>\n<li>ref：使用非唯一索引扫描或者唯一索引的前缀扫描，返回匹配某个单独值的记录行</li>\n<li>eq_ref：类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条件</li>\n<li>const、system：当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转换为一个常量</li>\n<li>NULL：MySQL在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。</li>\n</ol>\n<h2 id=\"possible-keys\"><a href=\"#possible-keys\" class=\"headerlink\" title=\"possible_keys\"></a>possible_keys</h2><p>指出MySQL能使用哪个索引在表中找到记录，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用</p>\n<h2 id=\"key\"><a href=\"#key\" class=\"headerlink\" title=\"key\"></a>key</h2><p>显示MySQL在查询中实际使用的索引，若没有使用索引，显示为NULL</p>\n<h2 id=\"key-len\"><a href=\"#key-len\" class=\"headerlink\" title=\"key_len\"></a>key_len</h2><p>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度（key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的）</p>\n<h2 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h2><p>表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</p>\n<h2 id=\"rows\"><a href=\"#rows\" class=\"headerlink\" title=\"rows\"></a>rows</h2><p>表示MySQL根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行数</p>\n<h2 id=\"Extra\"><a href=\"#Extra\" class=\"headerlink\" title=\"Extra\"></a>Extra</h2><p>包含不适合在其他列中显示但十分重要的额外信息<br>a. Using index<br>该值表示相应的select操作中使用了覆盖索引（Covering Index）</p>\n<ol>\n<li>覆盖索引（Covering Index）<br>MySQL可以利用索引返回select列表中的字段，而不必根据索引再次读取数据文件<br>包含所有满足查询需要的数据的索引称为覆盖索引（Covering Index）<br>注意：如果要使用覆盖索引，一定要注意select列表中只取出需要的列，不可select *，因为如果将所有字段一起做索引会导致索引文件过大，查询性能下降</li>\n<li>Using where 表示mysql服务器将在存储引擎检索行后再进行过滤。许多where条件里涉及索引中的列，当（并且如果）它读取索引时，就能被存储引擎检验，因此不是所有带where字句的查询都会显示”Using where”。有时”Using where”的出现就是一个暗示：查询可受益与不同的索引。</li>\n<li>Using temporary<br>表示MySQL需要使用临时表来存储结果集，常见于排序和分组查询。<br>这个值表示使用了内部临时(基于内存的)表。一个查询可能用到多个临时表。有很多原因都会导致MySQL在执行查询期间创建临时表。两个常见的原因是在来自不同表的上使用了DISTINCT,或者使用了不同的ORDER BY和GROUP BY列。可以强制指定一个临时表使用基于磁盘的MyISAM存储引擎。这样做的原因主要有两个：一、内部临时表占用的空间超过min(tmp_table_size，max_heap_table_size)系统变量的限制；二、使用了TEXT/BLOB 列</li>\n<li>Using filesort<br>MySQL中无法利用索引完成的排序操作称为“文件排序”</li>\n<li>Using join buffer<br>改值强调了在获取连接条件时没有使用索引，并且需要连接缓冲区来存储中间结果。如果出现了这个值，那应该注意，根据查询的具体情况可能需要添加索引来改进能。</li>\n<li>Impossible where<br>这个值强调了where语句会导致没有符合条件的行。</li>\n<li>Select tables optimized away<br>这个值意味着仅通过使用索引，优化器可能仅从聚合函数结果中返回一行.</li>\n<li>Index merges<br>当MySQL 决定要在一个给定的表上使用超过一个索引的时候，就会出现以下格式中的一个，详细说明使用的索引以及合并的类型。<br>Using sort_union(…)Using union(…)Using intersect(…)</li>\n</ol>\n<p>#总结</p>\n<ul>\n<li>EXPLAIN不会告诉你关于触发器、存储过程的信息或用户自定义函数对查询的影响情况</li>\n<li>EXPLAIN不考虑各种Cache</li>\n<li>EXPLAIN不能显示MySQL在执行查询时所作的优化工作</li>\n<li>部分统计信息是估算的，并非精确值</li>\n<li>EXPALIN只能解释SELECT操作，其他操作要重写为SELECT后查看执行计划。</li>\n</ul>"},{"title":"java的浅拷贝和深拷贝","date":"2018-07-26T06:11:52.000Z","_content":"\n> 浅拷贝\n\n所谓浅拷贝，是指原对象与拷贝对象公用一份实体，仅仅是对象名字不同而已（类似引用，即对原对象起别名），其中任何一个对象改变都会导致其他的对象也跟着它变。\n\n> 深拷贝\n\n所谓深拷贝，就是为新对象开辟一块新的空间，并将原对象的内容拷贝给新开的空间，释放时就不会牵扯到多次析构的问题。\n\n所有对象都继承了父类Object，Object有一个protected修饰的clone()方法：\n\n> protected native Object clone() throws CloneNotSupportedException;\n\n<!-- more -->\n\n当我们想实现一个类的浅拷贝，只需实现Cloneable接口，override父类的clone()方法\n\n```\nimport java.io.Serializable;\nimport java.util.List;\n\npublic class Man implements Cloneable, Serializable {\n    private int age;\n\n    private String name;\n\n    private List<Man> girls;\n\n    public Man(int age, String name, List<Man> girls) {\n        this.age = age;\n        this.name = name;\n        this.girls = girls;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public List<Man> getGirls() {\n        return girls;\n    }\n\n    public void setGirls(List<Man> girls) {\n        this.girls = girls;\n    }\n\n    @Override\n    protected Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n\n    @Override\n    public String toString() {\n        return \"Man{\" +\n                \"age=\" + age +\n                \", name='\" + name + '\\'' +\n                \", girls=\" + girls +\n                '}';\n    }\n}\n```\n\n> 测试如下\n\n```\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Man girl = new Man(18, \"美女\", null);\n        List<Man> girls = new ArrayList<>(1);\n        girls.add(girl);\n        Man man = new Man(25, \"帅哥\", girls);\n        Man clone = null;\n        try {\n            clone = (Man) man.clone();\n        } catch (CloneNotSupportedException e) {\n            e.printStackTrace();\n        }\n        man.setAge(20);\n        man.setName(\"美女\");\n        man.getGirls().get(0).setAge(20);\n        man.getGirls().get(0).setName(null);\n        System.out.println(man);\n        System.out.println(clone);\n    }\n}\n```\n\n> 运行结果如下\n\nMan{age=20, name='美女', girls=[Man{age=20, name='null', girls=null}]}\n\nMan{age=25, name='帅哥', girls=[Man{age=20, name='null', girls=null}]}\n\n> 分析一下，age是int基础数据类型，clone的时候应该是值传递，name是String类型对象，查看SString的源码,没有实现Cloneable接口，但按照运行结果来看对象clone的时候String类型的属性应该是new了一个新的String对象和原来的String属性一模一样，并指向clone对象的String类型的属性，但List<T>确实浅拷贝，只拷贝了原对象的引用，并没有拷贝原对象的值.\n\n```\npublic final class String\n    implements java.io.Serializable, Comparable<String>, CharSequence {\n```\n> 这里有个地方要注意：Arrays.asList(T... a)返回的的ArrayList对象并不是java.util.ArrayList,而是Arrays的一个一个静态内部类，\njava.util.ArrayList实现了Cloneable接口，而Arrays.asList(T... a)返回的的ArrayList没有实现Cloneable接口。\n\n```\n    public static <T> List<T> asList(T... a) {\n        return new ArrayList<>(a);\n    }\n    \n    private static class ArrayList<E> extends AbstractList<E>\n        implements RandomAccess, java.io.Serializable\n\n```\n\n> 从ArrayList的源码可以看出实现的是浅拷贝\n\n```\n    /**\n     * Returns a shallow copy of this <tt>ArrayList</tt> instance.  (The\n     * elements themselves are not copied.)\n     *\n     * @return a clone of this <tt>ArrayList</tt> instance\n     */\n    public Object clone() {\n        try {\n            ArrayList<?> v = (ArrayList<?>) super.clone();\n            v.elementData = Arrays.copyOf(elementData, size);\n            v.modCount = 0;\n            return v;\n        } catch (CloneNotSupportedException e) {\n            // this shouldn't happen, since we are Cloneable\n            throw new InternalError(e);\n        }\n    }\n```\n\n> 假如在开发环境的时候需要clone集合的时候，就很容易出现隐形的bug，下面给出集合的深拷贝的解决方案：就是使用序列化和反序列化，要考虑的对象要实现Serializable接口\n\n```\nimport java.io.*;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Man girl = new Man(18, \"美女\", null);\n        List<Man> girls = new ArrayList<>(2);\n        girls.add(girl);\n        Man man = new Man(25, \"帅哥\", girls);\n        Man clone = null;\n        try {\n            clone = (Man) man.clone();\n            clone.setGirls(depCopy(clone.getGirls()));\n        } catch (CloneNotSupportedException e) {\n            e.printStackTrace();\n        }\n        man.setAge(20);\n        man.setName(\"美女\");\n        man.getGirls().get(0).setAge(20);\n        man.getGirls().get(0).setName(null);\n        System.out.println(man);\n        System.out.println(clone);\n    }\n\n    public static <T> List<T> depCopy(List<T> srcList) {\n        ByteArrayOutputStream byteOut = new ByteArrayOutputStream();\n        try (ObjectOutputStream out = new ObjectOutputStream(byteOut)) {\n            out.writeObject(srcList);\n            ByteArrayInputStream byteIn = new ByteArrayInputStream(byteOut.toByteArray());\n            ObjectInputStream inStream = new ObjectInputStream(byteIn);\n            List<T> destList = (List<T>) inStream.readObject();\n            return destList;\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n}\n\n```\n> 测试结果如下\n\nMan{age=20, name='美女', girls=[Man{age=20, name='null', girls=null}]}\n\nMan{age=25, name='帅哥', girls=[Man{age=18, name='美女', girls=null}]}\n","source":"_posts/clone.md","raw":"---\ntitle: java的浅拷贝和深拷贝\ndate: 2018-7-26 14:11:52\ntags: Java\n---\n\n> 浅拷贝\n\n所谓浅拷贝，是指原对象与拷贝对象公用一份实体，仅仅是对象名字不同而已（类似引用，即对原对象起别名），其中任何一个对象改变都会导致其他的对象也跟着它变。\n\n> 深拷贝\n\n所谓深拷贝，就是为新对象开辟一块新的空间，并将原对象的内容拷贝给新开的空间，释放时就不会牵扯到多次析构的问题。\n\n所有对象都继承了父类Object，Object有一个protected修饰的clone()方法：\n\n> protected native Object clone() throws CloneNotSupportedException;\n\n<!-- more -->\n\n当我们想实现一个类的浅拷贝，只需实现Cloneable接口，override父类的clone()方法\n\n```\nimport java.io.Serializable;\nimport java.util.List;\n\npublic class Man implements Cloneable, Serializable {\n    private int age;\n\n    private String name;\n\n    private List<Man> girls;\n\n    public Man(int age, String name, List<Man> girls) {\n        this.age = age;\n        this.name = name;\n        this.girls = girls;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public List<Man> getGirls() {\n        return girls;\n    }\n\n    public void setGirls(List<Man> girls) {\n        this.girls = girls;\n    }\n\n    @Override\n    protected Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n\n    @Override\n    public String toString() {\n        return \"Man{\" +\n                \"age=\" + age +\n                \", name='\" + name + '\\'' +\n                \", girls=\" + girls +\n                '}';\n    }\n}\n```\n\n> 测试如下\n\n```\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Man girl = new Man(18, \"美女\", null);\n        List<Man> girls = new ArrayList<>(1);\n        girls.add(girl);\n        Man man = new Man(25, \"帅哥\", girls);\n        Man clone = null;\n        try {\n            clone = (Man) man.clone();\n        } catch (CloneNotSupportedException e) {\n            e.printStackTrace();\n        }\n        man.setAge(20);\n        man.setName(\"美女\");\n        man.getGirls().get(0).setAge(20);\n        man.getGirls().get(0).setName(null);\n        System.out.println(man);\n        System.out.println(clone);\n    }\n}\n```\n\n> 运行结果如下\n\nMan{age=20, name='美女', girls=[Man{age=20, name='null', girls=null}]}\n\nMan{age=25, name='帅哥', girls=[Man{age=20, name='null', girls=null}]}\n\n> 分析一下，age是int基础数据类型，clone的时候应该是值传递，name是String类型对象，查看SString的源码,没有实现Cloneable接口，但按照运行结果来看对象clone的时候String类型的属性应该是new了一个新的String对象和原来的String属性一模一样，并指向clone对象的String类型的属性，但List<T>确实浅拷贝，只拷贝了原对象的引用，并没有拷贝原对象的值.\n\n```\npublic final class String\n    implements java.io.Serializable, Comparable<String>, CharSequence {\n```\n> 这里有个地方要注意：Arrays.asList(T... a)返回的的ArrayList对象并不是java.util.ArrayList,而是Arrays的一个一个静态内部类，\njava.util.ArrayList实现了Cloneable接口，而Arrays.asList(T... a)返回的的ArrayList没有实现Cloneable接口。\n\n```\n    public static <T> List<T> asList(T... a) {\n        return new ArrayList<>(a);\n    }\n    \n    private static class ArrayList<E> extends AbstractList<E>\n        implements RandomAccess, java.io.Serializable\n\n```\n\n> 从ArrayList的源码可以看出实现的是浅拷贝\n\n```\n    /**\n     * Returns a shallow copy of this <tt>ArrayList</tt> instance.  (The\n     * elements themselves are not copied.)\n     *\n     * @return a clone of this <tt>ArrayList</tt> instance\n     */\n    public Object clone() {\n        try {\n            ArrayList<?> v = (ArrayList<?>) super.clone();\n            v.elementData = Arrays.copyOf(elementData, size);\n            v.modCount = 0;\n            return v;\n        } catch (CloneNotSupportedException e) {\n            // this shouldn't happen, since we are Cloneable\n            throw new InternalError(e);\n        }\n    }\n```\n\n> 假如在开发环境的时候需要clone集合的时候，就很容易出现隐形的bug，下面给出集合的深拷贝的解决方案：就是使用序列化和反序列化，要考虑的对象要实现Serializable接口\n\n```\nimport java.io.*;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Man girl = new Man(18, \"美女\", null);\n        List<Man> girls = new ArrayList<>(2);\n        girls.add(girl);\n        Man man = new Man(25, \"帅哥\", girls);\n        Man clone = null;\n        try {\n            clone = (Man) man.clone();\n            clone.setGirls(depCopy(clone.getGirls()));\n        } catch (CloneNotSupportedException e) {\n            e.printStackTrace();\n        }\n        man.setAge(20);\n        man.setName(\"美女\");\n        man.getGirls().get(0).setAge(20);\n        man.getGirls().get(0).setName(null);\n        System.out.println(man);\n        System.out.println(clone);\n    }\n\n    public static <T> List<T> depCopy(List<T> srcList) {\n        ByteArrayOutputStream byteOut = new ByteArrayOutputStream();\n        try (ObjectOutputStream out = new ObjectOutputStream(byteOut)) {\n            out.writeObject(srcList);\n            ByteArrayInputStream byteIn = new ByteArrayInputStream(byteOut.toByteArray());\n            ObjectInputStream inStream = new ObjectInputStream(byteIn);\n            List<T> destList = (List<T>) inStream.readObject();\n            return destList;\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n}\n\n```\n> 测试结果如下\n\nMan{age=20, name='美女', girls=[Man{age=20, name='null', girls=null}]}\n\nMan{age=25, name='帅哥', girls=[Man{age=18, name='美女', girls=null}]}\n","slug":"clone","published":1,"updated":"2019-02-26T02:29:01.539Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsl5qftn0002k8v3hw7c3711","content":"<blockquote>\n<p>浅拷贝</p>\n</blockquote>\n<p>所谓浅拷贝，是指原对象与拷贝对象公用一份实体，仅仅是对象名字不同而已（类似引用，即对原对象起别名），其中任何一个对象改变都会导致其他的对象也跟着它变。</p>\n<blockquote>\n<p>深拷贝</p>\n</blockquote>\n<p>所谓深拷贝，就是为新对象开辟一块新的空间，并将原对象的内容拷贝给新开的空间，释放时就不会牵扯到多次析构的问题。</p>\n<p>所有对象都继承了父类Object，Object有一个protected修饰的clone()方法：</p>\n<blockquote>\n<p>protected native Object clone() throws CloneNotSupportedException;</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>当我们想实现一个类的浅拷贝，只需实现Cloneable接口，override父类的clone()方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.io.Serializable;</span><br><span class=\"line\">import java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Man implements Cloneable, Serializable &#123;</span><br><span class=\"line\">    private int age;</span><br><span class=\"line\"></span><br><span class=\"line\">    private String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    private List&lt;Man&gt; girls;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Man(int age, String name, List&lt;Man&gt; girls) &#123;</span><br><span class=\"line\">        this.age = age;</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">        this.girls = girls;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public int getAge() &#123;</span><br><span class=\"line\">        return age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setAge(int age) &#123;</span><br><span class=\"line\">        this.age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String getName() &#123;</span><br><span class=\"line\">        return name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setName(String name) &#123;</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public List&lt;Man&gt; getGirls() &#123;</span><br><span class=\"line\">        return girls;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setGirls(List&lt;Man&gt; girls) &#123;</span><br><span class=\"line\">        this.girls = girls;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected Object clone() throws CloneNotSupportedException &#123;</span><br><span class=\"line\">        return super.clone();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public String toString() &#123;</span><br><span class=\"line\">        return &quot;Man&#123;&quot; +</span><br><span class=\"line\">                &quot;age=&quot; + age +</span><br><span class=\"line\">                &quot;, name=&apos;&quot; + name + &apos;\\&apos;&apos; +</span><br><span class=\"line\">                &quot;, girls=&quot; + girls +</span><br><span class=\"line\">                &apos;&#125;&apos;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>测试如下</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.util.ArrayList;</span><br><span class=\"line\">import java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Main &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Man girl = new Man(18, &quot;美女&quot;, null);</span><br><span class=\"line\">        List&lt;Man&gt; girls = new ArrayList&lt;&gt;(1);</span><br><span class=\"line\">        girls.add(girl);</span><br><span class=\"line\">        Man man = new Man(25, &quot;帅哥&quot;, girls);</span><br><span class=\"line\">        Man clone = null;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            clone = (Man) man.clone();</span><br><span class=\"line\">        &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        man.setAge(20);</span><br><span class=\"line\">        man.setName(&quot;美女&quot;);</span><br><span class=\"line\">        man.getGirls().get(0).setAge(20);</span><br><span class=\"line\">        man.getGirls().get(0).setName(null);</span><br><span class=\"line\">        System.out.println(man);</span><br><span class=\"line\">        System.out.println(clone);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>运行结果如下</p>\n</blockquote>\n<p>Man{age=20, name=’美女’, girls=[Man{age=20, name=’null’, girls=null}]}</p>\n<p>Man{age=25, name=’帅哥’, girls=[Man{age=20, name=’null’, girls=null}]}</p>\n<blockquote>\n<p>分析一下，age是int基础数据类型，clone的时候应该是值传递，name是String类型对象，查看SString的源码,没有实现Cloneable接口，但按照运行结果来看对象clone的时候String类型的属性应该是new了一个新的String对象和原来的String属性一模一样，并指向clone对象的String类型的属性，但List<t>确实浅拷贝，只拷贝了原对象的引用，并没有拷贝原对象的值.</t></p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public final class String</span><br><span class=\"line\">    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这里有个地方要注意：Arrays.asList(T… a)返回的的ArrayList对象并不是java.util.ArrayList,而是Arrays的一个一个静态内部类，<br>java.util.ArrayList实现了Cloneable接口，而Arrays.asList(T… a)返回的的ArrayList没有实现Cloneable接口。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static &lt;T&gt; List&lt;T&gt; asList(T... a) &#123;</span><br><span class=\"line\">    return new ArrayList&lt;&gt;(a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span><br><span class=\"line\">    implements RandomAccess, java.io.Serializable</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>从ArrayList的源码可以看出实现的是浅拷贝</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Returns a shallow copy of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance.  (The</span><br><span class=\"line\"> * elements themselves are not copied.)</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @return a clone of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance</span><br><span class=\"line\"> */</span><br><span class=\"line\">public Object clone() &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) super.clone();</span><br><span class=\"line\">        v.elementData = Arrays.copyOf(elementData, size);</span><br><span class=\"line\">        v.modCount = 0;</span><br><span class=\"line\">        return v;</span><br><span class=\"line\">    &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class=\"line\">        // this shouldn&apos;t happen, since we are Cloneable</span><br><span class=\"line\">        throw new InternalError(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>假如在开发环境的时候需要clone集合的时候，就很容易出现隐形的bug，下面给出集合的深拷贝的解决方案：就是使用序列化和反序列化，要考虑的对象要实现Serializable接口</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.io.*;</span><br><span class=\"line\">import java.util.ArrayList;</span><br><span class=\"line\">import java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Main &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Man girl = new Man(18, &quot;美女&quot;, null);</span><br><span class=\"line\">        List&lt;Man&gt; girls = new ArrayList&lt;&gt;(2);</span><br><span class=\"line\">        girls.add(girl);</span><br><span class=\"line\">        Man man = new Man(25, &quot;帅哥&quot;, girls);</span><br><span class=\"line\">        Man clone = null;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            clone = (Man) man.clone();</span><br><span class=\"line\">            clone.setGirls(depCopy(clone.getGirls()));</span><br><span class=\"line\">        &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        man.setAge(20);</span><br><span class=\"line\">        man.setName(&quot;美女&quot;);</span><br><span class=\"line\">        man.getGirls().get(0).setAge(20);</span><br><span class=\"line\">        man.getGirls().get(0).setName(null);</span><br><span class=\"line\">        System.out.println(man);</span><br><span class=\"line\">        System.out.println(clone);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static &lt;T&gt; List&lt;T&gt; depCopy(List&lt;T&gt; srcList) &#123;</span><br><span class=\"line\">        ByteArrayOutputStream byteOut = new ByteArrayOutputStream();</span><br><span class=\"line\">        try (ObjectOutputStream out = new ObjectOutputStream(byteOut)) &#123;</span><br><span class=\"line\">            out.writeObject(srcList);</span><br><span class=\"line\">            ByteArrayInputStream byteIn = new ByteArrayInputStream(byteOut.toByteArray());</span><br><span class=\"line\">            ObjectInputStream inStream = new ObjectInputStream(byteIn);</span><br><span class=\"line\">            List&lt;T&gt; destList = (List&lt;T&gt;) inStream.readObject();</span><br><span class=\"line\">            return destList;</span><br><span class=\"line\">        &#125; catch (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>测试结果如下</p>\n</blockquote>\n<p>Man{age=20, name=’美女’, girls=[Man{age=20, name=’null’, girls=null}]}</p>\n<p>Man{age=25, name=’帅哥’, girls=[Man{age=18, name=’美女’, girls=null}]}</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>浅拷贝</p>\n</blockquote>\n<p>所谓浅拷贝，是指原对象与拷贝对象公用一份实体，仅仅是对象名字不同而已（类似引用，即对原对象起别名），其中任何一个对象改变都会导致其他的对象也跟着它变。</p>\n<blockquote>\n<p>深拷贝</p>\n</blockquote>\n<p>所谓深拷贝，就是为新对象开辟一块新的空间，并将原对象的内容拷贝给新开的空间，释放时就不会牵扯到多次析构的问题。</p>\n<p>所有对象都继承了父类Object，Object有一个protected修饰的clone()方法：</p>\n<blockquote>\n<p>protected native Object clone() throws CloneNotSupportedException;</p>\n</blockquote>","more":"<p>当我们想实现一个类的浅拷贝，只需实现Cloneable接口，override父类的clone()方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.io.Serializable;</span><br><span class=\"line\">import java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Man implements Cloneable, Serializable &#123;</span><br><span class=\"line\">    private int age;</span><br><span class=\"line\"></span><br><span class=\"line\">    private String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    private List&lt;Man&gt; girls;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Man(int age, String name, List&lt;Man&gt; girls) &#123;</span><br><span class=\"line\">        this.age = age;</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">        this.girls = girls;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public int getAge() &#123;</span><br><span class=\"line\">        return age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setAge(int age) &#123;</span><br><span class=\"line\">        this.age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String getName() &#123;</span><br><span class=\"line\">        return name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setName(String name) &#123;</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public List&lt;Man&gt; getGirls() &#123;</span><br><span class=\"line\">        return girls;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setGirls(List&lt;Man&gt; girls) &#123;</span><br><span class=\"line\">        this.girls = girls;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected Object clone() throws CloneNotSupportedException &#123;</span><br><span class=\"line\">        return super.clone();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public String toString() &#123;</span><br><span class=\"line\">        return &quot;Man&#123;&quot; +</span><br><span class=\"line\">                &quot;age=&quot; + age +</span><br><span class=\"line\">                &quot;, name=&apos;&quot; + name + &apos;\\&apos;&apos; +</span><br><span class=\"line\">                &quot;, girls=&quot; + girls +</span><br><span class=\"line\">                &apos;&#125;&apos;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>测试如下</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.util.ArrayList;</span><br><span class=\"line\">import java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Main &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Man girl = new Man(18, &quot;美女&quot;, null);</span><br><span class=\"line\">        List&lt;Man&gt; girls = new ArrayList&lt;&gt;(1);</span><br><span class=\"line\">        girls.add(girl);</span><br><span class=\"line\">        Man man = new Man(25, &quot;帅哥&quot;, girls);</span><br><span class=\"line\">        Man clone = null;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            clone = (Man) man.clone();</span><br><span class=\"line\">        &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        man.setAge(20);</span><br><span class=\"line\">        man.setName(&quot;美女&quot;);</span><br><span class=\"line\">        man.getGirls().get(0).setAge(20);</span><br><span class=\"line\">        man.getGirls().get(0).setName(null);</span><br><span class=\"line\">        System.out.println(man);</span><br><span class=\"line\">        System.out.println(clone);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>运行结果如下</p>\n</blockquote>\n<p>Man{age=20, name=’美女’, girls=[Man{age=20, name=’null’, girls=null}]}</p>\n<p>Man{age=25, name=’帅哥’, girls=[Man{age=20, name=’null’, girls=null}]}</p>\n<blockquote>\n<p>分析一下，age是int基础数据类型，clone的时候应该是值传递，name是String类型对象，查看SString的源码,没有实现Cloneable接口，但按照运行结果来看对象clone的时候String类型的属性应该是new了一个新的String对象和原来的String属性一模一样，并指向clone对象的String类型的属性，但List<t>确实浅拷贝，只拷贝了原对象的引用，并没有拷贝原对象的值.</t></p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public final class String</span><br><span class=\"line\">    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这里有个地方要注意：Arrays.asList(T… a)返回的的ArrayList对象并不是java.util.ArrayList,而是Arrays的一个一个静态内部类，<br>java.util.ArrayList实现了Cloneable接口，而Arrays.asList(T… a)返回的的ArrayList没有实现Cloneable接口。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static &lt;T&gt; List&lt;T&gt; asList(T... a) &#123;</span><br><span class=\"line\">    return new ArrayList&lt;&gt;(a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span><br><span class=\"line\">    implements RandomAccess, java.io.Serializable</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>从ArrayList的源码可以看出实现的是浅拷贝</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Returns a shallow copy of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance.  (The</span><br><span class=\"line\"> * elements themselves are not copied.)</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @return a clone of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance</span><br><span class=\"line\"> */</span><br><span class=\"line\">public Object clone() &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) super.clone();</span><br><span class=\"line\">        v.elementData = Arrays.copyOf(elementData, size);</span><br><span class=\"line\">        v.modCount = 0;</span><br><span class=\"line\">        return v;</span><br><span class=\"line\">    &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class=\"line\">        // this shouldn&apos;t happen, since we are Cloneable</span><br><span class=\"line\">        throw new InternalError(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>假如在开发环境的时候需要clone集合的时候，就很容易出现隐形的bug，下面给出集合的深拷贝的解决方案：就是使用序列化和反序列化，要考虑的对象要实现Serializable接口</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.io.*;</span><br><span class=\"line\">import java.util.ArrayList;</span><br><span class=\"line\">import java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Main &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Man girl = new Man(18, &quot;美女&quot;, null);</span><br><span class=\"line\">        List&lt;Man&gt; girls = new ArrayList&lt;&gt;(2);</span><br><span class=\"line\">        girls.add(girl);</span><br><span class=\"line\">        Man man = new Man(25, &quot;帅哥&quot;, girls);</span><br><span class=\"line\">        Man clone = null;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            clone = (Man) man.clone();</span><br><span class=\"line\">            clone.setGirls(depCopy(clone.getGirls()));</span><br><span class=\"line\">        &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        man.setAge(20);</span><br><span class=\"line\">        man.setName(&quot;美女&quot;);</span><br><span class=\"line\">        man.getGirls().get(0).setAge(20);</span><br><span class=\"line\">        man.getGirls().get(0).setName(null);</span><br><span class=\"line\">        System.out.println(man);</span><br><span class=\"line\">        System.out.println(clone);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static &lt;T&gt; List&lt;T&gt; depCopy(List&lt;T&gt; srcList) &#123;</span><br><span class=\"line\">        ByteArrayOutputStream byteOut = new ByteArrayOutputStream();</span><br><span class=\"line\">        try (ObjectOutputStream out = new ObjectOutputStream(byteOut)) &#123;</span><br><span class=\"line\">            out.writeObject(srcList);</span><br><span class=\"line\">            ByteArrayInputStream byteIn = new ByteArrayInputStream(byteOut.toByteArray());</span><br><span class=\"line\">            ObjectInputStream inStream = new ObjectInputStream(byteIn);</span><br><span class=\"line\">            List&lt;T&gt; destList = (List&lt;T&gt;) inStream.readObject();</span><br><span class=\"line\">            return destList;</span><br><span class=\"line\">        &#125; catch (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>测试结果如下</p>\n</blockquote>\n<p>Man{age=20, name=’美女’, girls=[Man{age=20, name=’null’, girls=null}]}</p>\n<p>Man{age=25, name=’帅哥’, girls=[Man{age=18, name=’美女’, girls=null}]}</p>"},{"title":"Docker备忘录","date":"2018-07-16T02:08:18.000Z","_content":"\n> 删除全部image的话\n\ndocker rmi $(docker images -q)\n\n> 删除全部container\n\ndocker rm $(docker ps -aq)\n\n<!-- more -->\n\n>boot2docker用户和密码\n\n\n用户名 | 密码 | 进入方式\n---|---|---\ndocker | tcuser | ssh\nroot | 空 | command：sudo -i (docker用户下执行)\n\n> zookeeper docker运行命令\n\ndocker pull zookeeper\n\ndocker run --name zookeeper-1 --restart always -d zookeeper\n\ndocker exec -it 容器id zkCli.sh ","source":"_posts/docker.md","raw":"---\ntitle: Docker备忘录\ndate: 2018-07-16 10:08:18\ntags: Docker\n---\n\n> 删除全部image的话\n\ndocker rmi $(docker images -q)\n\n> 删除全部container\n\ndocker rm $(docker ps -aq)\n\n<!-- more -->\n\n>boot2docker用户和密码\n\n\n用户名 | 密码 | 进入方式\n---|---|---\ndocker | tcuser | ssh\nroot | 空 | command：sudo -i (docker用户下执行)\n\n> zookeeper docker运行命令\n\ndocker pull zookeeper\n\ndocker run --name zookeeper-1 --restart always -d zookeeper\n\ndocker exec -it 容器id zkCli.sh ","slug":"docker","published":1,"updated":"2019-02-26T02:29:01.539Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsl5qftr0003k8v3l5270meg","content":"<blockquote>\n<p>删除全部image的话</p>\n</blockquote>\n<p>docker rmi $(docker images -q)</p>\n<blockquote>\n<p>删除全部container</p>\n</blockquote>\n<p>docker rm $(docker ps -aq)</p>\n<a id=\"more\"></a>\n<blockquote>\n<p>boot2docker用户和密码</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>用户名</th>\n<th>密码</th>\n<th>进入方式</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>docker</td>\n<td>tcuser</td>\n<td>ssh</td>\n</tr>\n<tr>\n<td>root</td>\n<td>空</td>\n<td>command：sudo -i (docker用户下执行)</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>zookeeper docker运行命令</p>\n</blockquote>\n<p>docker pull zookeeper</p>\n<p>docker run –name zookeeper-1 –restart always -d zookeeper</p>\n<p>docker exec -it 容器id zkCli.sh </p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>删除全部image的话</p>\n</blockquote>\n<p>docker rmi $(docker images -q)</p>\n<blockquote>\n<p>删除全部container</p>\n</blockquote>\n<p>docker rm $(docker ps -aq)</p>","more":"<blockquote>\n<p>boot2docker用户和密码</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>用户名</th>\n<th>密码</th>\n<th>进入方式</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>docker</td>\n<td>tcuser</td>\n<td>ssh</td>\n</tr>\n<tr>\n<td>root</td>\n<td>空</td>\n<td>command：sudo -i (docker用户下执行)</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>zookeeper docker运行命令</p>\n</blockquote>\n<p>docker pull zookeeper</p>\n<p>docker run –name zookeeper-1 –restart always -d zookeeper</p>\n<p>docker exec -it 容器id zkCli.sh </p>"},{"title":"Go 异常处理机制——defer, error, panic, recover","date":"2018-07-27T07:00:17.000Z","_content":"### 1. 如果项目中的代码、使用的标准库以及第三方库在运行时内部捕获了异常并通过合适的 error 对象返回给调用者，那我们可以尽量少甚至可以不用 panic 函数。\n### 2. 如果无法保证上面的情况，那为了确保程序在运行时不会因为 未知的未知 导致崩溃，那 panic 函数的使用可能不得不加在任何需要的地方。\n### 3. 我们应该认识到，panic是我们和计算机都不希望看到的，应该在设计开发的时候充分考虑使用场景可能出现的情况，处理好 已知的未知，在确定需要的地方使用 panic 机制。\n\n# defer \n\ndefer关键字用来标记最后执行的Go语句，一般用在资源释放、关闭连接等操作，会在函数关闭前调用。\n\n多个defer的定义与执行类似于栈的操作：先进后出，最先定义的最后执行。\n\n<!-- more -->\n\n请先看下边几段代码，然后判断一下各自输出内容：\n```\n// 示例代码一：\nfunc funcA() int {\n    x := 5\n    defer func() {\n        x += 1\n    }()\n    return x\n}\n// 示例代码二：\nfunc funcB() (x int) {\n    defer func() {\n        x += 1\n    }()\n    return 5\n}\n\n// 示例代码三：\nfunc funcC() (y int) {\n    x := 5\n    defer func() {\n        x += 1\n    }()\n    return x\n}\n \n// 示例代码四：\nfunc funcD() (x int) {\n    defer func(x int) {\n        x += 1\n    }(x)\n    return 5\n}\n```\n解析这几段代码，主要需要理解清楚以下几点知识：\n### 1. return语句的处理过程\n\nreturn xxx 语句并不是一条原子指令，其在执行的时候会进行语句分解成 返回变量=xxx return，最后执行return\n\n### 2. defer语句执行时机\n\n上文说过，defer语句是在函数关闭的时候调用，确切的说是在执行return语句的时候调用，注意，是return 不是return xxx\n\n### 3. 函数参数的传递方式\n\nGo语言中普通的函数参数的传递方式是值传递，即新辟内存拷贝变量值，不包括slice和map，这两种类型是引用传递\n\n### 4. 变量赋值的传递方式\n\nGo语言变量的赋值跟函数参数类似，也是值拷贝，不包括slice和map，这两种类型是内存引用\n\n按照以上原则，解析代码：\n```\n// 解析代码一：返回temp的值，在将x赋值给temp后，temp未发生改变，最终返回值为5\nfunc funcA() int {\n    x := 5\n    temp=x      #temp变量表示未显示声明的return变量\n    func() {\n        x += 1\n    }()\n    return\n}\n\n// 解析代码二：返回x的值，先对其复制5，接着函数中改变为6，最终返回值为6\nfunc funcB() (x int) {\n    x = 5\n    func() {\n        x += 1\n    }()\n    return\n}\n\n// 解析代码三：返回y的值，在将x赋值给y后，y未发生改变，最终返回值为5\nfunc funcC() (y int) {\n    x := 5\n    y = x       #这里是值拷贝\n    func() {\n        x += 1\n    }()\n    return\n}\n\n// 解析代码四：返回x的值，传递x到匿名函数中执行时，传递的是x的拷贝，不影响外部x的值，最终返回值为5\nfunc funcD() (x int) {\n    x := 5\n    func(x int) { #这里是值拷贝\n        x += 1\n    }(x)\n    return\n}\n```\n# Error\nGo语言 通过支持多返回值，让在运行时返回详细的错误信息给调用者变得非常方便。我们可以在编码中通过实现 error 接口类型来生成错误信息，error 接口的定义如下：\n```\ntype error interface {\n    Error() string\n}\n```\n还是通过下面的例子来看看：\n```\npackage main\n\nimport (\n\t\"fmt\"\n)\n\n// 定义一个 DivideError 结构\ntype DivideError struct {\n\tdividee int\n\tdivider int\n}\n\n// 实现 \t`error` 接口\nfunc (de *DivideError) Error() string {\n\tstrFormat := `\n\tCannot proceed, the divider is zero.\n\tdividee: %d\n\tdivider: 0`\n\treturn fmt.Sprintf(strFormat, de.dividee)\n}\n\n// 定义 `int` 类型除法运算的函数\nfunc Divide(varDividee int, varDivider int) (result int, errorMsg string) {\n\tif varDivider == 0 {\n\t\tdData := DivideError{\n\t\t\tdividee: varDividee,\n\t\t\tdivider: varDivider,\n\t\t}\n\t\terrorMsg = dData.Error()\n\t\treturn\n\t} else {\n\t\treturn varDividee / varDivider, \"\"\n\t}\n\n}\n\nfunc main() {\n\n\t// 正常情况\n\tif result, errorMsg := Divide(100, 10); errorMsg == \"\" {\n\t\tfmt.Println(\"100/10 = \", result)\n\t}\n\t// 当被除数为零的时候会返回错误信息\n\tif _, errorMsg := Divide(100, 0); errorMsg != \"\" {\n\t\tfmt.Println(\"errorMsg is: \", errorMsg)\n\t}\n\n}\n```\n运行后可以看到下面的输出：\n```\n100/10 =  10\nerrorMsg is:  \n\tCannot proceed, the divider is zero.\n\tdividee: 100\n\tdivider: 0\n```\n# Panic 和 recover\n定义如下：\n```\nfunc panic(interface{})\nfunc recover() interface{}\n```\npanic 和 recover 是两个内置函数，用于处理 run-time panics 以及程序中自定义的错误。\n\n当执行一个函数 F 的时候，如果显式地调用 panic 函数或者一个 run-time panics 发生时，F 会结束运行，所有 F 中 defer 的函数会按照 FILO 的规则被执行。之后，F 函数的调用者中 defer 的函数再被执行，如此一直到最外层代码。这时，程序已经被中断了而且错误也被一层层抛出来了，其中包括 panic 函数的参数。当前被中断的 goroutine 被称为处于 panicking 状态。由于 panic 函数的参数是空接口类型，所以可以接受任何类型的对象：\n```\npanic(42)\npanic(42)\npanic(\"unreachable\")\npanic(Error(\"cannot parse\"))\n```\nrecover 函数用来获取 panic 函数的参数信息，只能在延时调用 defer 语句调用的函数中直接调用才能生效，如果在 defer 语句中也调用 panic 函数，则只有最后一个被调用的 panic 函数的参数会被 recover 函数获取到。如果 goroutine 没有 panic，那调用 recover 函数会返回 nil。\n```\npackage main\n\nimport (\n\t\"fmt\"\n)\n\n// 最简单的例子\nfunc SimplePanicRecover() {\n\tdefer func() {\n\t\tif err := recover(); err != nil {\n\t\t\tfmt.Println(\"Panic info is: \", err)\n\t\t}\n\t}()\n\tpanic(\"SimplePanicRecover function panic-ed!\")\n}\n\n// 当 defer 中也调用了 panic 函数时，最后被调用的 panic 函数的参数会被后面的 recover 函数获取到\n// 一个函数中可以定义多个 defer 函数，按照 FILO 的规则执行\nfunc MultiPanicRecover() {\n\tdefer func() {\n\t\tif err := recover(); err != nil {\n\t\t\tfmt.Println(\"Panic info is: \", err)\n\t\t}\n\t}()\n\tdefer func() {\n\t\tpanic(\"MultiPanicRecover defer inner panic\")\n\t}()\n\tdefer func() {\n\t\tif err := recover(); err != nil {\n\t\t\tfmt.Println(\"Panic info is: \", err)\n\t\t}\n\t}()\n\tpanic(\"MultiPanicRecover function panic-ed!\")\n}\n\n// recover 函数只有在 defer 函数中被直接调用的时候才可以获取 panic 的参数\nfunc RecoverPlaceTest() {\n\t// 下面一行代码中 recover 函数会返回 nil，但也不影响程序运行\n\tdefer recover()\n\t// recover 函数返回 nil\n\tdefer fmt.Println(\"recover() is: \", recover())\n\tdefer func() {\n\t\tfunc() {\n\t\t\t// 由于不是在 defer 调用函数中直接调用 recover 函数，recover 函数会返回 nil\n\t\t\tif err := recover(); err != nil {\n\t\t\t\tfmt.Println(\"Panic info is: \", err)\n\t\t\t}\n\t\t}()\n\n\t}()\n\tdefer func() {\n\t\tif err := recover(); err != nil {\n\t\t\tfmt.Println(\"Panic info is: \", err)\n\t\t}\n\t}()\n\tpanic(\"RecoverPlaceTest function panic-ed!\")\n}\n\n// 如果函数没有 panic，调用 recover 函数不会获取到任何信息，也不会影响当前进程。\nfunc NoPanicButHasRecover() {\n\tif err := recover(); err != nil {\n\t\tfmt.Println(\"NoPanicButHasRecover Panic info is: \", err)\n\t} else {\n\t\tfmt.Println(\"NoPanicButHasRecover Panic info is: \", err)\n\t}\n}\n\n// 定义一个调用 recover 函数的函数\nfunc CallRecover() {\n\tif err := recover(); err != nil {\n\t\tfmt.Println(\"Panic info is: \", err)\n\t}\n}\n\n// 定义个函数，在其中 defer 另一个调用了 recover 函数的函数\nfunc RecoverInOutterFunc() {\n\tdefer CallRecover()\n\tpanic(\"RecoverInOutterFunc function panic-ed!\")\n}\n\nfunc main() {\n\tSimplePanicRecover()\n\tMultiPanicRecover()\n\tRecoverPlaceTest()\n\tNoPanicButHasRecover()\n\tRecoverInOutterFunc()\n}\n```\n运行后可以看到下面的输出：\n```\nPanic info is:  SimplePanicRecover function panic-ed!\nPanic info is:  MultiPanicRecover function panic-ed!\nPanic info is:  MultiPanicRecover defer inner panic\nPanic info is:  RecoverPlaceTest function panic-ed!\nrecover() is:  <nil>\nNoPanicButHasRecover Panic info is:  <nil>\nPanic info is:  RecoverInOutterFunc function panic-ed!\n```\n","source":"_posts/error.md","raw":"---\ntitle: Go 异常处理机制——defer, error, panic, recover\ndate: 2018-07-27 15:00:17\ntags: Go\n---\n### 1. 如果项目中的代码、使用的标准库以及第三方库在运行时内部捕获了异常并通过合适的 error 对象返回给调用者，那我们可以尽量少甚至可以不用 panic 函数。\n### 2. 如果无法保证上面的情况，那为了确保程序在运行时不会因为 未知的未知 导致崩溃，那 panic 函数的使用可能不得不加在任何需要的地方。\n### 3. 我们应该认识到，panic是我们和计算机都不希望看到的，应该在设计开发的时候充分考虑使用场景可能出现的情况，处理好 已知的未知，在确定需要的地方使用 panic 机制。\n\n# defer \n\ndefer关键字用来标记最后执行的Go语句，一般用在资源释放、关闭连接等操作，会在函数关闭前调用。\n\n多个defer的定义与执行类似于栈的操作：先进后出，最先定义的最后执行。\n\n<!-- more -->\n\n请先看下边几段代码，然后判断一下各自输出内容：\n```\n// 示例代码一：\nfunc funcA() int {\n    x := 5\n    defer func() {\n        x += 1\n    }()\n    return x\n}\n// 示例代码二：\nfunc funcB() (x int) {\n    defer func() {\n        x += 1\n    }()\n    return 5\n}\n\n// 示例代码三：\nfunc funcC() (y int) {\n    x := 5\n    defer func() {\n        x += 1\n    }()\n    return x\n}\n \n// 示例代码四：\nfunc funcD() (x int) {\n    defer func(x int) {\n        x += 1\n    }(x)\n    return 5\n}\n```\n解析这几段代码，主要需要理解清楚以下几点知识：\n### 1. return语句的处理过程\n\nreturn xxx 语句并不是一条原子指令，其在执行的时候会进行语句分解成 返回变量=xxx return，最后执行return\n\n### 2. defer语句执行时机\n\n上文说过，defer语句是在函数关闭的时候调用，确切的说是在执行return语句的时候调用，注意，是return 不是return xxx\n\n### 3. 函数参数的传递方式\n\nGo语言中普通的函数参数的传递方式是值传递，即新辟内存拷贝变量值，不包括slice和map，这两种类型是引用传递\n\n### 4. 变量赋值的传递方式\n\nGo语言变量的赋值跟函数参数类似，也是值拷贝，不包括slice和map，这两种类型是内存引用\n\n按照以上原则，解析代码：\n```\n// 解析代码一：返回temp的值，在将x赋值给temp后，temp未发生改变，最终返回值为5\nfunc funcA() int {\n    x := 5\n    temp=x      #temp变量表示未显示声明的return变量\n    func() {\n        x += 1\n    }()\n    return\n}\n\n// 解析代码二：返回x的值，先对其复制5，接着函数中改变为6，最终返回值为6\nfunc funcB() (x int) {\n    x = 5\n    func() {\n        x += 1\n    }()\n    return\n}\n\n// 解析代码三：返回y的值，在将x赋值给y后，y未发生改变，最终返回值为5\nfunc funcC() (y int) {\n    x := 5\n    y = x       #这里是值拷贝\n    func() {\n        x += 1\n    }()\n    return\n}\n\n// 解析代码四：返回x的值，传递x到匿名函数中执行时，传递的是x的拷贝，不影响外部x的值，最终返回值为5\nfunc funcD() (x int) {\n    x := 5\n    func(x int) { #这里是值拷贝\n        x += 1\n    }(x)\n    return\n}\n```\n# Error\nGo语言 通过支持多返回值，让在运行时返回详细的错误信息给调用者变得非常方便。我们可以在编码中通过实现 error 接口类型来生成错误信息，error 接口的定义如下：\n```\ntype error interface {\n    Error() string\n}\n```\n还是通过下面的例子来看看：\n```\npackage main\n\nimport (\n\t\"fmt\"\n)\n\n// 定义一个 DivideError 结构\ntype DivideError struct {\n\tdividee int\n\tdivider int\n}\n\n// 实现 \t`error` 接口\nfunc (de *DivideError) Error() string {\n\tstrFormat := `\n\tCannot proceed, the divider is zero.\n\tdividee: %d\n\tdivider: 0`\n\treturn fmt.Sprintf(strFormat, de.dividee)\n}\n\n// 定义 `int` 类型除法运算的函数\nfunc Divide(varDividee int, varDivider int) (result int, errorMsg string) {\n\tif varDivider == 0 {\n\t\tdData := DivideError{\n\t\t\tdividee: varDividee,\n\t\t\tdivider: varDivider,\n\t\t}\n\t\terrorMsg = dData.Error()\n\t\treturn\n\t} else {\n\t\treturn varDividee / varDivider, \"\"\n\t}\n\n}\n\nfunc main() {\n\n\t// 正常情况\n\tif result, errorMsg := Divide(100, 10); errorMsg == \"\" {\n\t\tfmt.Println(\"100/10 = \", result)\n\t}\n\t// 当被除数为零的时候会返回错误信息\n\tif _, errorMsg := Divide(100, 0); errorMsg != \"\" {\n\t\tfmt.Println(\"errorMsg is: \", errorMsg)\n\t}\n\n}\n```\n运行后可以看到下面的输出：\n```\n100/10 =  10\nerrorMsg is:  \n\tCannot proceed, the divider is zero.\n\tdividee: 100\n\tdivider: 0\n```\n# Panic 和 recover\n定义如下：\n```\nfunc panic(interface{})\nfunc recover() interface{}\n```\npanic 和 recover 是两个内置函数，用于处理 run-time panics 以及程序中自定义的错误。\n\n当执行一个函数 F 的时候，如果显式地调用 panic 函数或者一个 run-time panics 发生时，F 会结束运行，所有 F 中 defer 的函数会按照 FILO 的规则被执行。之后，F 函数的调用者中 defer 的函数再被执行，如此一直到最外层代码。这时，程序已经被中断了而且错误也被一层层抛出来了，其中包括 panic 函数的参数。当前被中断的 goroutine 被称为处于 panicking 状态。由于 panic 函数的参数是空接口类型，所以可以接受任何类型的对象：\n```\npanic(42)\npanic(42)\npanic(\"unreachable\")\npanic(Error(\"cannot parse\"))\n```\nrecover 函数用来获取 panic 函数的参数信息，只能在延时调用 defer 语句调用的函数中直接调用才能生效，如果在 defer 语句中也调用 panic 函数，则只有最后一个被调用的 panic 函数的参数会被 recover 函数获取到。如果 goroutine 没有 panic，那调用 recover 函数会返回 nil。\n```\npackage main\n\nimport (\n\t\"fmt\"\n)\n\n// 最简单的例子\nfunc SimplePanicRecover() {\n\tdefer func() {\n\t\tif err := recover(); err != nil {\n\t\t\tfmt.Println(\"Panic info is: \", err)\n\t\t}\n\t}()\n\tpanic(\"SimplePanicRecover function panic-ed!\")\n}\n\n// 当 defer 中也调用了 panic 函数时，最后被调用的 panic 函数的参数会被后面的 recover 函数获取到\n// 一个函数中可以定义多个 defer 函数，按照 FILO 的规则执行\nfunc MultiPanicRecover() {\n\tdefer func() {\n\t\tif err := recover(); err != nil {\n\t\t\tfmt.Println(\"Panic info is: \", err)\n\t\t}\n\t}()\n\tdefer func() {\n\t\tpanic(\"MultiPanicRecover defer inner panic\")\n\t}()\n\tdefer func() {\n\t\tif err := recover(); err != nil {\n\t\t\tfmt.Println(\"Panic info is: \", err)\n\t\t}\n\t}()\n\tpanic(\"MultiPanicRecover function panic-ed!\")\n}\n\n// recover 函数只有在 defer 函数中被直接调用的时候才可以获取 panic 的参数\nfunc RecoverPlaceTest() {\n\t// 下面一行代码中 recover 函数会返回 nil，但也不影响程序运行\n\tdefer recover()\n\t// recover 函数返回 nil\n\tdefer fmt.Println(\"recover() is: \", recover())\n\tdefer func() {\n\t\tfunc() {\n\t\t\t// 由于不是在 defer 调用函数中直接调用 recover 函数，recover 函数会返回 nil\n\t\t\tif err := recover(); err != nil {\n\t\t\t\tfmt.Println(\"Panic info is: \", err)\n\t\t\t}\n\t\t}()\n\n\t}()\n\tdefer func() {\n\t\tif err := recover(); err != nil {\n\t\t\tfmt.Println(\"Panic info is: \", err)\n\t\t}\n\t}()\n\tpanic(\"RecoverPlaceTest function panic-ed!\")\n}\n\n// 如果函数没有 panic，调用 recover 函数不会获取到任何信息，也不会影响当前进程。\nfunc NoPanicButHasRecover() {\n\tif err := recover(); err != nil {\n\t\tfmt.Println(\"NoPanicButHasRecover Panic info is: \", err)\n\t} else {\n\t\tfmt.Println(\"NoPanicButHasRecover Panic info is: \", err)\n\t}\n}\n\n// 定义一个调用 recover 函数的函数\nfunc CallRecover() {\n\tif err := recover(); err != nil {\n\t\tfmt.Println(\"Panic info is: \", err)\n\t}\n}\n\n// 定义个函数，在其中 defer 另一个调用了 recover 函数的函数\nfunc RecoverInOutterFunc() {\n\tdefer CallRecover()\n\tpanic(\"RecoverInOutterFunc function panic-ed!\")\n}\n\nfunc main() {\n\tSimplePanicRecover()\n\tMultiPanicRecover()\n\tRecoverPlaceTest()\n\tNoPanicButHasRecover()\n\tRecoverInOutterFunc()\n}\n```\n运行后可以看到下面的输出：\n```\nPanic info is:  SimplePanicRecover function panic-ed!\nPanic info is:  MultiPanicRecover function panic-ed!\nPanic info is:  MultiPanicRecover defer inner panic\nPanic info is:  RecoverPlaceTest function panic-ed!\nrecover() is:  <nil>\nNoPanicButHasRecover Panic info is:  <nil>\nPanic info is:  RecoverInOutterFunc function panic-ed!\n```\n","slug":"error","published":1,"updated":"2019-02-26T02:29:01.540Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsl5qftu0005k8v32khn41t7","content":"<h3 id=\"1-如果项目中的代码、使用的标准库以及第三方库在运行时内部捕获了异常并通过合适的-error-对象返回给调用者，那我们可以尽量少甚至可以不用-panic-函数。\"><a href=\"#1-如果项目中的代码、使用的标准库以及第三方库在运行时内部捕获了异常并通过合适的-error-对象返回给调用者，那我们可以尽量少甚至可以不用-panic-函数。\" class=\"headerlink\" title=\"1. 如果项目中的代码、使用的标准库以及第三方库在运行时内部捕获了异常并通过合适的 error 对象返回给调用者，那我们可以尽量少甚至可以不用 panic 函数。\"></a>1. 如果项目中的代码、使用的标准库以及第三方库在运行时内部捕获了异常并通过合适的 error 对象返回给调用者，那我们可以尽量少甚至可以不用 panic 函数。</h3><h3 id=\"2-如果无法保证上面的情况，那为了确保程序在运行时不会因为-未知的未知-导致崩溃，那-panic-函数的使用可能不得不加在任何需要的地方。\"><a href=\"#2-如果无法保证上面的情况，那为了确保程序在运行时不会因为-未知的未知-导致崩溃，那-panic-函数的使用可能不得不加在任何需要的地方。\" class=\"headerlink\" title=\"2. 如果无法保证上面的情况，那为了确保程序在运行时不会因为 未知的未知 导致崩溃，那 panic 函数的使用可能不得不加在任何需要的地方。\"></a>2. 如果无法保证上面的情况，那为了确保程序在运行时不会因为 未知的未知 导致崩溃，那 panic 函数的使用可能不得不加在任何需要的地方。</h3><h3 id=\"3-我们应该认识到，panic是我们和计算机都不希望看到的，应该在设计开发的时候充分考虑使用场景可能出现的情况，处理好-已知的未知，在确定需要的地方使用-panic-机制。\"><a href=\"#3-我们应该认识到，panic是我们和计算机都不希望看到的，应该在设计开发的时候充分考虑使用场景可能出现的情况，处理好-已知的未知，在确定需要的地方使用-panic-机制。\" class=\"headerlink\" title=\"3. 我们应该认识到，panic是我们和计算机都不希望看到的，应该在设计开发的时候充分考虑使用场景可能出现的情况，处理好 已知的未知，在确定需要的地方使用 panic 机制。\"></a>3. 我们应该认识到，panic是我们和计算机都不希望看到的，应该在设计开发的时候充分考虑使用场景可能出现的情况，处理好 已知的未知，在确定需要的地方使用 panic 机制。</h3><h1 id=\"defer\"><a href=\"#defer\" class=\"headerlink\" title=\"defer\"></a>defer</h1><p>defer关键字用来标记最后执行的Go语句，一般用在资源释放、关闭连接等操作，会在函数关闭前调用。</p>\n<p>多个defer的定义与执行类似于栈的操作：先进后出，最先定义的最后执行。</p>\n<a id=\"more\"></a>\n<p>请先看下边几段代码，然后判断一下各自输出内容：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 示例代码一：</span><br><span class=\"line\">func funcA() int &#123;</span><br><span class=\"line\">    x := 5</span><br><span class=\"line\">    defer func() &#123;</span><br><span class=\"line\">        x += 1</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    return x</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 示例代码二：</span><br><span class=\"line\">func funcB() (x int) &#123;</span><br><span class=\"line\">    defer func() &#123;</span><br><span class=\"line\">        x += 1</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    return 5</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 示例代码三：</span><br><span class=\"line\">func funcC() (y int) &#123;</span><br><span class=\"line\">    x := 5</span><br><span class=\"line\">    defer func() &#123;</span><br><span class=\"line\">        x += 1</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    return x</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">// 示例代码四：</span><br><span class=\"line\">func funcD() (x int) &#123;</span><br><span class=\"line\">    defer func(x int) &#123;</span><br><span class=\"line\">        x += 1</span><br><span class=\"line\">    &#125;(x)</span><br><span class=\"line\">    return 5</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>解析这几段代码，主要需要理解清楚以下几点知识：</p>\n<h3 id=\"1-return语句的处理过程\"><a href=\"#1-return语句的处理过程\" class=\"headerlink\" title=\"1. return语句的处理过程\"></a>1. return语句的处理过程</h3><p>return xxx 语句并不是一条原子指令，其在执行的时候会进行语句分解成 返回变量=xxx return，最后执行return</p>\n<h3 id=\"2-defer语句执行时机\"><a href=\"#2-defer语句执行时机\" class=\"headerlink\" title=\"2. defer语句执行时机\"></a>2. defer语句执行时机</h3><p>上文说过，defer语句是在函数关闭的时候调用，确切的说是在执行return语句的时候调用，注意，是return 不是return xxx</p>\n<h3 id=\"3-函数参数的传递方式\"><a href=\"#3-函数参数的传递方式\" class=\"headerlink\" title=\"3. 函数参数的传递方式\"></a>3. 函数参数的传递方式</h3><p>Go语言中普通的函数参数的传递方式是值传递，即新辟内存拷贝变量值，不包括slice和map，这两种类型是引用传递</p>\n<h3 id=\"4-变量赋值的传递方式\"><a href=\"#4-变量赋值的传递方式\" class=\"headerlink\" title=\"4. 变量赋值的传递方式\"></a>4. 变量赋值的传递方式</h3><p>Go语言变量的赋值跟函数参数类似，也是值拷贝，不包括slice和map，这两种类型是内存引用</p>\n<p>按照以上原则，解析代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 解析代码一：返回temp的值，在将x赋值给temp后，temp未发生改变，最终返回值为5</span><br><span class=\"line\">func funcA() int &#123;</span><br><span class=\"line\">    x := 5</span><br><span class=\"line\">    temp=x      #temp变量表示未显示声明的return变量</span><br><span class=\"line\">    func() &#123;</span><br><span class=\"line\">        x += 1</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    return</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 解析代码二：返回x的值，先对其复制5，接着函数中改变为6，最终返回值为6</span><br><span class=\"line\">func funcB() (x int) &#123;</span><br><span class=\"line\">    x = 5</span><br><span class=\"line\">    func() &#123;</span><br><span class=\"line\">        x += 1</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    return</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 解析代码三：返回y的值，在将x赋值给y后，y未发生改变，最终返回值为5</span><br><span class=\"line\">func funcC() (y int) &#123;</span><br><span class=\"line\">    x := 5</span><br><span class=\"line\">    y = x       #这里是值拷贝</span><br><span class=\"line\">    func() &#123;</span><br><span class=\"line\">        x += 1</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    return</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 解析代码四：返回x的值，传递x到匿名函数中执行时，传递的是x的拷贝，不影响外部x的值，最终返回值为5</span><br><span class=\"line\">func funcD() (x int) &#123;</span><br><span class=\"line\">    x := 5</span><br><span class=\"line\">    func(x int) &#123; #这里是值拷贝</span><br><span class=\"line\">        x += 1</span><br><span class=\"line\">    &#125;(x)</span><br><span class=\"line\">    return</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"Error\"><a href=\"#Error\" class=\"headerlink\" title=\"Error\"></a>Error</h1><p>Go语言 通过支持多返回值，让在运行时返回详细的错误信息给调用者变得非常方便。我们可以在编码中通过实现 error 接口类型来生成错误信息，error 接口的定义如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type error interface &#123;</span><br><span class=\"line\">    Error() string</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>还是通过下面的例子来看看：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">\t&quot;fmt&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">// 定义一个 DivideError 结构</span><br><span class=\"line\">type DivideError struct &#123;</span><br><span class=\"line\">\tdividee int</span><br><span class=\"line\">\tdivider int</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 实现 \t`error` 接口</span><br><span class=\"line\">func (de *DivideError) Error() string &#123;</span><br><span class=\"line\">\tstrFormat := `</span><br><span class=\"line\">\tCannot proceed, the divider is zero.</span><br><span class=\"line\">\tdividee: %d</span><br><span class=\"line\">\tdivider: 0`</span><br><span class=\"line\">\treturn fmt.Sprintf(strFormat, de.dividee)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 定义 `int` 类型除法运算的函数</span><br><span class=\"line\">func Divide(varDividee int, varDivider int) (result int, errorMsg string) &#123;</span><br><span class=\"line\">\tif varDivider == 0 &#123;</span><br><span class=\"line\">\t\tdData := DivideError&#123;</span><br><span class=\"line\">\t\t\tdividee: varDividee,</span><br><span class=\"line\">\t\t\tdivider: varDivider,</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\terrorMsg = dData.Error()</span><br><span class=\"line\">\t\treturn</span><br><span class=\"line\">\t&#125; else &#123;</span><br><span class=\"line\">\t\treturn varDividee / varDivider, &quot;&quot;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t// 正常情况</span><br><span class=\"line\">\tif result, errorMsg := Divide(100, 10); errorMsg == &quot;&quot; &#123;</span><br><span class=\"line\">\t\tfmt.Println(&quot;100/10 = &quot;, result)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t// 当被除数为零的时候会返回错误信息</span><br><span class=\"line\">\tif _, errorMsg := Divide(100, 0); errorMsg != &quot;&quot; &#123;</span><br><span class=\"line\">\t\tfmt.Println(&quot;errorMsg is: &quot;, errorMsg)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行后可以看到下面的输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">100/10 =  10</span><br><span class=\"line\">errorMsg is:  </span><br><span class=\"line\">\tCannot proceed, the divider is zero.</span><br><span class=\"line\">\tdividee: 100</span><br><span class=\"line\">\tdivider: 0</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"Panic-和-recover\"><a href=\"#Panic-和-recover\" class=\"headerlink\" title=\"Panic 和 recover\"></a>Panic 和 recover</h1><p>定义如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func panic(interface&#123;&#125;)</span><br><span class=\"line\">func recover() interface&#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>panic 和 recover 是两个内置函数，用于处理 run-time panics 以及程序中自定义的错误。</p>\n<p>当执行一个函数 F 的时候，如果显式地调用 panic 函数或者一个 run-time panics 发生时，F 会结束运行，所有 F 中 defer 的函数会按照 FILO 的规则被执行。之后，F 函数的调用者中 defer 的函数再被执行，如此一直到最外层代码。这时，程序已经被中断了而且错误也被一层层抛出来了，其中包括 panic 函数的参数。当前被中断的 goroutine 被称为处于 panicking 状态。由于 panic 函数的参数是空接口类型，所以可以接受任何类型的对象：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">panic(42)</span><br><span class=\"line\">panic(42)</span><br><span class=\"line\">panic(&quot;unreachable&quot;)</span><br><span class=\"line\">panic(Error(&quot;cannot parse&quot;))</span><br></pre></td></tr></table></figure></p>\n<p>recover 函数用来获取 panic 函数的参数信息，只能在延时调用 defer 语句调用的函数中直接调用才能生效，如果在 defer 语句中也调用 panic 函数，则只有最后一个被调用的 panic 函数的参数会被 recover 函数获取到。如果 goroutine 没有 panic，那调用 recover 函数会返回 nil。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">\t&quot;fmt&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">// 最简单的例子</span><br><span class=\"line\">func SimplePanicRecover() &#123;</span><br><span class=\"line\">\tdefer func() &#123;</span><br><span class=\"line\">\t\tif err := recover(); err != nil &#123;</span><br><span class=\"line\">\t\t\tfmt.Println(&quot;Panic info is: &quot;, err)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\tpanic(&quot;SimplePanicRecover function panic-ed!&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 当 defer 中也调用了 panic 函数时，最后被调用的 panic 函数的参数会被后面的 recover 函数获取到</span><br><span class=\"line\">// 一个函数中可以定义多个 defer 函数，按照 FILO 的规则执行</span><br><span class=\"line\">func MultiPanicRecover() &#123;</span><br><span class=\"line\">\tdefer func() &#123;</span><br><span class=\"line\">\t\tif err := recover(); err != nil &#123;</span><br><span class=\"line\">\t\t\tfmt.Println(&quot;Panic info is: &quot;, err)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\tdefer func() &#123;</span><br><span class=\"line\">\t\tpanic(&quot;MultiPanicRecover defer inner panic&quot;)</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\tdefer func() &#123;</span><br><span class=\"line\">\t\tif err := recover(); err != nil &#123;</span><br><span class=\"line\">\t\t\tfmt.Println(&quot;Panic info is: &quot;, err)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\tpanic(&quot;MultiPanicRecover function panic-ed!&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// recover 函数只有在 defer 函数中被直接调用的时候才可以获取 panic 的参数</span><br><span class=\"line\">func RecoverPlaceTest() &#123;</span><br><span class=\"line\">\t// 下面一行代码中 recover 函数会返回 nil，但也不影响程序运行</span><br><span class=\"line\">\tdefer recover()</span><br><span class=\"line\">\t// recover 函数返回 nil</span><br><span class=\"line\">\tdefer fmt.Println(&quot;recover() is: &quot;, recover())</span><br><span class=\"line\">\tdefer func() &#123;</span><br><span class=\"line\">\t\tfunc() &#123;</span><br><span class=\"line\">\t\t\t// 由于不是在 defer 调用函数中直接调用 recover 函数，recover 函数会返回 nil</span><br><span class=\"line\">\t\t\tif err := recover(); err != nil &#123;</span><br><span class=\"line\">\t\t\t\tfmt.Println(&quot;Panic info is: &quot;, err)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\tdefer func() &#123;</span><br><span class=\"line\">\t\tif err := recover(); err != nil &#123;</span><br><span class=\"line\">\t\t\tfmt.Println(&quot;Panic info is: &quot;, err)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\tpanic(&quot;RecoverPlaceTest function panic-ed!&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 如果函数没有 panic，调用 recover 函数不会获取到任何信息，也不会影响当前进程。</span><br><span class=\"line\">func NoPanicButHasRecover() &#123;</span><br><span class=\"line\">\tif err := recover(); err != nil &#123;</span><br><span class=\"line\">\t\tfmt.Println(&quot;NoPanicButHasRecover Panic info is: &quot;, err)</span><br><span class=\"line\">\t&#125; else &#123;</span><br><span class=\"line\">\t\tfmt.Println(&quot;NoPanicButHasRecover Panic info is: &quot;, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 定义一个调用 recover 函数的函数</span><br><span class=\"line\">func CallRecover() &#123;</span><br><span class=\"line\">\tif err := recover(); err != nil &#123;</span><br><span class=\"line\">\t\tfmt.Println(&quot;Panic info is: &quot;, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 定义个函数，在其中 defer 另一个调用了 recover 函数的函数</span><br><span class=\"line\">func RecoverInOutterFunc() &#123;</span><br><span class=\"line\">\tdefer CallRecover()</span><br><span class=\"line\">\tpanic(&quot;RecoverInOutterFunc function panic-ed!&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">\tSimplePanicRecover()</span><br><span class=\"line\">\tMultiPanicRecover()</span><br><span class=\"line\">\tRecoverPlaceTest()</span><br><span class=\"line\">\tNoPanicButHasRecover()</span><br><span class=\"line\">\tRecoverInOutterFunc()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行后可以看到下面的输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Panic info is:  SimplePanicRecover function panic-ed!</span><br><span class=\"line\">Panic info is:  MultiPanicRecover function panic-ed!</span><br><span class=\"line\">Panic info is:  MultiPanicRecover defer inner panic</span><br><span class=\"line\">Panic info is:  RecoverPlaceTest function panic-ed!</span><br><span class=\"line\">recover() is:  &lt;nil&gt;</span><br><span class=\"line\">NoPanicButHasRecover Panic info is:  &lt;nil&gt;</span><br><span class=\"line\">Panic info is:  RecoverInOutterFunc function panic-ed!</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"1-如果项目中的代码、使用的标准库以及第三方库在运行时内部捕获了异常并通过合适的-error-对象返回给调用者，那我们可以尽量少甚至可以不用-panic-函数。\"><a href=\"#1-如果项目中的代码、使用的标准库以及第三方库在运行时内部捕获了异常并通过合适的-error-对象返回给调用者，那我们可以尽量少甚至可以不用-panic-函数。\" class=\"headerlink\" title=\"1. 如果项目中的代码、使用的标准库以及第三方库在运行时内部捕获了异常并通过合适的 error 对象返回给调用者，那我们可以尽量少甚至可以不用 panic 函数。\"></a>1. 如果项目中的代码、使用的标准库以及第三方库在运行时内部捕获了异常并通过合适的 error 对象返回给调用者，那我们可以尽量少甚至可以不用 panic 函数。</h3><h3 id=\"2-如果无法保证上面的情况，那为了确保程序在运行时不会因为-未知的未知-导致崩溃，那-panic-函数的使用可能不得不加在任何需要的地方。\"><a href=\"#2-如果无法保证上面的情况，那为了确保程序在运行时不会因为-未知的未知-导致崩溃，那-panic-函数的使用可能不得不加在任何需要的地方。\" class=\"headerlink\" title=\"2. 如果无法保证上面的情况，那为了确保程序在运行时不会因为 未知的未知 导致崩溃，那 panic 函数的使用可能不得不加在任何需要的地方。\"></a>2. 如果无法保证上面的情况，那为了确保程序在运行时不会因为 未知的未知 导致崩溃，那 panic 函数的使用可能不得不加在任何需要的地方。</h3><h3 id=\"3-我们应该认识到，panic是我们和计算机都不希望看到的，应该在设计开发的时候充分考虑使用场景可能出现的情况，处理好-已知的未知，在确定需要的地方使用-panic-机制。\"><a href=\"#3-我们应该认识到，panic是我们和计算机都不希望看到的，应该在设计开发的时候充分考虑使用场景可能出现的情况，处理好-已知的未知，在确定需要的地方使用-panic-机制。\" class=\"headerlink\" title=\"3. 我们应该认识到，panic是我们和计算机都不希望看到的，应该在设计开发的时候充分考虑使用场景可能出现的情况，处理好 已知的未知，在确定需要的地方使用 panic 机制。\"></a>3. 我们应该认识到，panic是我们和计算机都不希望看到的，应该在设计开发的时候充分考虑使用场景可能出现的情况，处理好 已知的未知，在确定需要的地方使用 panic 机制。</h3><h1 id=\"defer\"><a href=\"#defer\" class=\"headerlink\" title=\"defer\"></a>defer</h1><p>defer关键字用来标记最后执行的Go语句，一般用在资源释放、关闭连接等操作，会在函数关闭前调用。</p>\n<p>多个defer的定义与执行类似于栈的操作：先进后出，最先定义的最后执行。</p>","more":"<p>请先看下边几段代码，然后判断一下各自输出内容：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 示例代码一：</span><br><span class=\"line\">func funcA() int &#123;</span><br><span class=\"line\">    x := 5</span><br><span class=\"line\">    defer func() &#123;</span><br><span class=\"line\">        x += 1</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    return x</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 示例代码二：</span><br><span class=\"line\">func funcB() (x int) &#123;</span><br><span class=\"line\">    defer func() &#123;</span><br><span class=\"line\">        x += 1</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    return 5</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 示例代码三：</span><br><span class=\"line\">func funcC() (y int) &#123;</span><br><span class=\"line\">    x := 5</span><br><span class=\"line\">    defer func() &#123;</span><br><span class=\"line\">        x += 1</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    return x</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">// 示例代码四：</span><br><span class=\"line\">func funcD() (x int) &#123;</span><br><span class=\"line\">    defer func(x int) &#123;</span><br><span class=\"line\">        x += 1</span><br><span class=\"line\">    &#125;(x)</span><br><span class=\"line\">    return 5</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>解析这几段代码，主要需要理解清楚以下几点知识：</p>\n<h3 id=\"1-return语句的处理过程\"><a href=\"#1-return语句的处理过程\" class=\"headerlink\" title=\"1. return语句的处理过程\"></a>1. return语句的处理过程</h3><p>return xxx 语句并不是一条原子指令，其在执行的时候会进行语句分解成 返回变量=xxx return，最后执行return</p>\n<h3 id=\"2-defer语句执行时机\"><a href=\"#2-defer语句执行时机\" class=\"headerlink\" title=\"2. defer语句执行时机\"></a>2. defer语句执行时机</h3><p>上文说过，defer语句是在函数关闭的时候调用，确切的说是在执行return语句的时候调用，注意，是return 不是return xxx</p>\n<h3 id=\"3-函数参数的传递方式\"><a href=\"#3-函数参数的传递方式\" class=\"headerlink\" title=\"3. 函数参数的传递方式\"></a>3. 函数参数的传递方式</h3><p>Go语言中普通的函数参数的传递方式是值传递，即新辟内存拷贝变量值，不包括slice和map，这两种类型是引用传递</p>\n<h3 id=\"4-变量赋值的传递方式\"><a href=\"#4-变量赋值的传递方式\" class=\"headerlink\" title=\"4. 变量赋值的传递方式\"></a>4. 变量赋值的传递方式</h3><p>Go语言变量的赋值跟函数参数类似，也是值拷贝，不包括slice和map，这两种类型是内存引用</p>\n<p>按照以上原则，解析代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 解析代码一：返回temp的值，在将x赋值给temp后，temp未发生改变，最终返回值为5</span><br><span class=\"line\">func funcA() int &#123;</span><br><span class=\"line\">    x := 5</span><br><span class=\"line\">    temp=x      #temp变量表示未显示声明的return变量</span><br><span class=\"line\">    func() &#123;</span><br><span class=\"line\">        x += 1</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    return</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 解析代码二：返回x的值，先对其复制5，接着函数中改变为6，最终返回值为6</span><br><span class=\"line\">func funcB() (x int) &#123;</span><br><span class=\"line\">    x = 5</span><br><span class=\"line\">    func() &#123;</span><br><span class=\"line\">        x += 1</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    return</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 解析代码三：返回y的值，在将x赋值给y后，y未发生改变，最终返回值为5</span><br><span class=\"line\">func funcC() (y int) &#123;</span><br><span class=\"line\">    x := 5</span><br><span class=\"line\">    y = x       #这里是值拷贝</span><br><span class=\"line\">    func() &#123;</span><br><span class=\"line\">        x += 1</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    return</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 解析代码四：返回x的值，传递x到匿名函数中执行时，传递的是x的拷贝，不影响外部x的值，最终返回值为5</span><br><span class=\"line\">func funcD() (x int) &#123;</span><br><span class=\"line\">    x := 5</span><br><span class=\"line\">    func(x int) &#123; #这里是值拷贝</span><br><span class=\"line\">        x += 1</span><br><span class=\"line\">    &#125;(x)</span><br><span class=\"line\">    return</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"Error\"><a href=\"#Error\" class=\"headerlink\" title=\"Error\"></a>Error</h1><p>Go语言 通过支持多返回值，让在运行时返回详细的错误信息给调用者变得非常方便。我们可以在编码中通过实现 error 接口类型来生成错误信息，error 接口的定义如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type error interface &#123;</span><br><span class=\"line\">    Error() string</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>还是通过下面的例子来看看：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">\t&quot;fmt&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">// 定义一个 DivideError 结构</span><br><span class=\"line\">type DivideError struct &#123;</span><br><span class=\"line\">\tdividee int</span><br><span class=\"line\">\tdivider int</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 实现 \t`error` 接口</span><br><span class=\"line\">func (de *DivideError) Error() string &#123;</span><br><span class=\"line\">\tstrFormat := `</span><br><span class=\"line\">\tCannot proceed, the divider is zero.</span><br><span class=\"line\">\tdividee: %d</span><br><span class=\"line\">\tdivider: 0`</span><br><span class=\"line\">\treturn fmt.Sprintf(strFormat, de.dividee)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 定义 `int` 类型除法运算的函数</span><br><span class=\"line\">func Divide(varDividee int, varDivider int) (result int, errorMsg string) &#123;</span><br><span class=\"line\">\tif varDivider == 0 &#123;</span><br><span class=\"line\">\t\tdData := DivideError&#123;</span><br><span class=\"line\">\t\t\tdividee: varDividee,</span><br><span class=\"line\">\t\t\tdivider: varDivider,</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\terrorMsg = dData.Error()</span><br><span class=\"line\">\t\treturn</span><br><span class=\"line\">\t&#125; else &#123;</span><br><span class=\"line\">\t\treturn varDividee / varDivider, &quot;&quot;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t// 正常情况</span><br><span class=\"line\">\tif result, errorMsg := Divide(100, 10); errorMsg == &quot;&quot; &#123;</span><br><span class=\"line\">\t\tfmt.Println(&quot;100/10 = &quot;, result)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t// 当被除数为零的时候会返回错误信息</span><br><span class=\"line\">\tif _, errorMsg := Divide(100, 0); errorMsg != &quot;&quot; &#123;</span><br><span class=\"line\">\t\tfmt.Println(&quot;errorMsg is: &quot;, errorMsg)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行后可以看到下面的输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">100/10 =  10</span><br><span class=\"line\">errorMsg is:  </span><br><span class=\"line\">\tCannot proceed, the divider is zero.</span><br><span class=\"line\">\tdividee: 100</span><br><span class=\"line\">\tdivider: 0</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"Panic-和-recover\"><a href=\"#Panic-和-recover\" class=\"headerlink\" title=\"Panic 和 recover\"></a>Panic 和 recover</h1><p>定义如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func panic(interface&#123;&#125;)</span><br><span class=\"line\">func recover() interface&#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>panic 和 recover 是两个内置函数，用于处理 run-time panics 以及程序中自定义的错误。</p>\n<p>当执行一个函数 F 的时候，如果显式地调用 panic 函数或者一个 run-time panics 发生时，F 会结束运行，所有 F 中 defer 的函数会按照 FILO 的规则被执行。之后，F 函数的调用者中 defer 的函数再被执行，如此一直到最外层代码。这时，程序已经被中断了而且错误也被一层层抛出来了，其中包括 panic 函数的参数。当前被中断的 goroutine 被称为处于 panicking 状态。由于 panic 函数的参数是空接口类型，所以可以接受任何类型的对象：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">panic(42)</span><br><span class=\"line\">panic(42)</span><br><span class=\"line\">panic(&quot;unreachable&quot;)</span><br><span class=\"line\">panic(Error(&quot;cannot parse&quot;))</span><br></pre></td></tr></table></figure></p>\n<p>recover 函数用来获取 panic 函数的参数信息，只能在延时调用 defer 语句调用的函数中直接调用才能生效，如果在 defer 语句中也调用 panic 函数，则只有最后一个被调用的 panic 函数的参数会被 recover 函数获取到。如果 goroutine 没有 panic，那调用 recover 函数会返回 nil。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">\t&quot;fmt&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">// 最简单的例子</span><br><span class=\"line\">func SimplePanicRecover() &#123;</span><br><span class=\"line\">\tdefer func() &#123;</span><br><span class=\"line\">\t\tif err := recover(); err != nil &#123;</span><br><span class=\"line\">\t\t\tfmt.Println(&quot;Panic info is: &quot;, err)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\tpanic(&quot;SimplePanicRecover function panic-ed!&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 当 defer 中也调用了 panic 函数时，最后被调用的 panic 函数的参数会被后面的 recover 函数获取到</span><br><span class=\"line\">// 一个函数中可以定义多个 defer 函数，按照 FILO 的规则执行</span><br><span class=\"line\">func MultiPanicRecover() &#123;</span><br><span class=\"line\">\tdefer func() &#123;</span><br><span class=\"line\">\t\tif err := recover(); err != nil &#123;</span><br><span class=\"line\">\t\t\tfmt.Println(&quot;Panic info is: &quot;, err)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\tdefer func() &#123;</span><br><span class=\"line\">\t\tpanic(&quot;MultiPanicRecover defer inner panic&quot;)</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\tdefer func() &#123;</span><br><span class=\"line\">\t\tif err := recover(); err != nil &#123;</span><br><span class=\"line\">\t\t\tfmt.Println(&quot;Panic info is: &quot;, err)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\tpanic(&quot;MultiPanicRecover function panic-ed!&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// recover 函数只有在 defer 函数中被直接调用的时候才可以获取 panic 的参数</span><br><span class=\"line\">func RecoverPlaceTest() &#123;</span><br><span class=\"line\">\t// 下面一行代码中 recover 函数会返回 nil，但也不影响程序运行</span><br><span class=\"line\">\tdefer recover()</span><br><span class=\"line\">\t// recover 函数返回 nil</span><br><span class=\"line\">\tdefer fmt.Println(&quot;recover() is: &quot;, recover())</span><br><span class=\"line\">\tdefer func() &#123;</span><br><span class=\"line\">\t\tfunc() &#123;</span><br><span class=\"line\">\t\t\t// 由于不是在 defer 调用函数中直接调用 recover 函数，recover 函数会返回 nil</span><br><span class=\"line\">\t\t\tif err := recover(); err != nil &#123;</span><br><span class=\"line\">\t\t\t\tfmt.Println(&quot;Panic info is: &quot;, err)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\tdefer func() &#123;</span><br><span class=\"line\">\t\tif err := recover(); err != nil &#123;</span><br><span class=\"line\">\t\t\tfmt.Println(&quot;Panic info is: &quot;, err)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\tpanic(&quot;RecoverPlaceTest function panic-ed!&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 如果函数没有 panic，调用 recover 函数不会获取到任何信息，也不会影响当前进程。</span><br><span class=\"line\">func NoPanicButHasRecover() &#123;</span><br><span class=\"line\">\tif err := recover(); err != nil &#123;</span><br><span class=\"line\">\t\tfmt.Println(&quot;NoPanicButHasRecover Panic info is: &quot;, err)</span><br><span class=\"line\">\t&#125; else &#123;</span><br><span class=\"line\">\t\tfmt.Println(&quot;NoPanicButHasRecover Panic info is: &quot;, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 定义一个调用 recover 函数的函数</span><br><span class=\"line\">func CallRecover() &#123;</span><br><span class=\"line\">\tif err := recover(); err != nil &#123;</span><br><span class=\"line\">\t\tfmt.Println(&quot;Panic info is: &quot;, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 定义个函数，在其中 defer 另一个调用了 recover 函数的函数</span><br><span class=\"line\">func RecoverInOutterFunc() &#123;</span><br><span class=\"line\">\tdefer CallRecover()</span><br><span class=\"line\">\tpanic(&quot;RecoverInOutterFunc function panic-ed!&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">\tSimplePanicRecover()</span><br><span class=\"line\">\tMultiPanicRecover()</span><br><span class=\"line\">\tRecoverPlaceTest()</span><br><span class=\"line\">\tNoPanicButHasRecover()</span><br><span class=\"line\">\tRecoverInOutterFunc()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行后可以看到下面的输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Panic info is:  SimplePanicRecover function panic-ed!</span><br><span class=\"line\">Panic info is:  MultiPanicRecover function panic-ed!</span><br><span class=\"line\">Panic info is:  MultiPanicRecover defer inner panic</span><br><span class=\"line\">Panic info is:  RecoverPlaceTest function panic-ed!</span><br><span class=\"line\">recover() is:  &lt;nil&gt;</span><br><span class=\"line\">NoPanicButHasRecover Panic info is:  &lt;nil&gt;</span><br><span class=\"line\">Panic info is:  RecoverInOutterFunc function panic-ed!</span><br></pre></td></tr></table></figure></p>"},{"title":"RUN vs CMD vs ENTRYPOINT","date":"2018-08-17T01:14:42.000Z","_content":"\nRUN、CMD 和 ENTRYPOINT 这三个 Dockerfile 指令看上去很类似，很容易混淆。本节将通过实践详细讨论它们的区别。\n\n简单的说：\n1. RUN 执行命令并创建新的镜像层，RUN 经常用于安装软件包。\n2. CMD 设置容器启动后默认执行的命令及其参数，但 CMD 能够被 docker run 后面跟的命令行参数替换。\n3. ENTRYPOINT 配置容器启动时运行的命令。\n\n下面我们详细分析。\n\n<!-- more -->\n\n# Shell 和 Exec 格式\n我们可用两种方式指定 RUN、CMD 和 ENTRYPOINT 要运行的命令：Shell 格式和 Exec 格式，二者在使用上有细微的区别。\n\n==Shell 格式 <instruction> <command>==\n\n例如：\n- RUN apt-get install python3  \n- CMD echo \"Hello world\"  \n- ENTRYPOINT echo \"Hello world\" \n\n当指令执行时，shell 格式底层会调用 ==/bin/sh -c <command>==\n\n例如下面的 Dockerfile 片段：\n\n```\nENV name Cloud Man  \n\nENTRYPOINT echo \"Hello, $name\"\n```\n\n执行 docker run <image> 将输出：Hello, Cloud Man\n\n注意环境变量 name 已经被值 Cloud Man 替换\n\n==Exec 格式 <instruction> [\"executable\", \"param1\", \"param2\", ...]==\n\n例如：\n- RUN [\"apt-get\", \"install\", \"python3\"]\n- CMD [\"/bin/echo\", \"Hello world\"]  \n- ENTRYPOINT [\"/bin/echo\", \"Hello world\"]\n\n当指令执行时，会直接调用 <command>，不会被 shell 解析\n\n例如下面的 Dockerfile 片段：\n\n```\nENV name Cloud Man  \n\nENTRYPOINT [\"/bin/echo\", \"Hello, $name\"]\n```\n\n运行容器将输出：Hello, $name\n\n注意环境变量“name”没有被替换，如果希望使用环境变量，照如下修改\n```\nENV name Cloud Man  \n\nENTRYPOINT [\"/bin/sh\", \"-c\", \"echo Hello, $name\"]\n```\n运行容器将输出：Hello, Cloud Man\n\n==CMD 和 ENTRYPOINT 推荐使用 Exec 格式，因为指令可读性更强，更容易理解。RUN 则两种格式都可以。==\n\n# RUN\n\nRUN 指令通常用于安装应用和软件包。\n\nRUN 在当前镜像的顶部执行命令，并通过创建新的镜像层。Dockerfile 中常常包含多个 RUN 指令。\n\nRUN 有两种格式：\n1. Shell 格式：RUN\n2. Exec 格式：RUN [\"executable\", \"param1\", \"param2\"]\n\n下面是使用 RUN 安装多个包的例子：\n```\n bzr \\\n\n cvs \\\n\n git \\\n\n mercurial \\\n\n subversion\n```\n注意：apt-get update 和 apt-get install 被放在一个 RUN 指令中执行，这样能够保证每次安装的是最新的包。如果 apt-get install 在单独的 RUN 中执行，则会使用 apt-get update 创建的镜像层，而这一层可能是很久以前缓存的。\n\n# CMD\nCMD 指令允许用户指定容器的默认执行的命令\n此命令会在容器启动且 docker run 没有指定其他命令时运行。\n1. 如果 docker run 指定了其他命令，CMD 指定的默认命令将被忽略。\n2. 如果 Dockerfile 中有多个 CMD 指令，只有最后一个 CMD 有效。\n\nCMD 有三种格式：\n1. Exec 格式：==CMD [\"executable\",\"param1\",\"param2\"]== 这是 CMD 的推荐格式。\n2. ==CMD [\"param1\",\"param2\"]== 为 ENTRYPOINT 提供额外的参数，此时 ENTRYPOINT 必须使用 Exec 格式。\n3. Shell 格式：==CMD command param1 param2==\n\nExec 和 Shell 格式前面已经介绍过了。第二种格式 CMD [\"param1\",\"param2\"] 要与 Exec 格式 的 ENTRYPOINT 指令配合使用，其用途是为 ENTRYPOINT 设置默认的参数。我们将在后面讨论 ENTRYPOINT 时举例说明。\n\n下面看看 CMD 是如何工作的。Dockerfile 片段如下：\n```\nCMD echo \"Hello world\"\n```\n运行容器 docker run -it [image] 将输出：\n```\nHello world\n```\n但当后面加上一个命令，比如 docker run -it [image] /bin/bash，CMD 会被忽略掉，命令 bash 将被执行：\n```\nroot@10a32dc7d3d3:/#\n```\n# ENTRYPOINT\nENTRYPOINT 指令可让容器以应用程序或者服务的形式运行。\n\nENTRYPOINT 看上去与 CMD 很像，它们都可以指定要执行的命令及其参数。不同的地方在于 ENTRYPOINT 不会被忽略，一定会被执行，即使运行 docker run 时指定了其他命令。\n\nENTRYPOINT 有两种格式：\n1. Exec 格式：==ENTRYPOINT [\"executable\", \"param1\", \"param2\"]== 这是 ENTRYPOINT 的推荐格式。\n2. Shell 格式：==ENTRYPOINT command param1 param2==\n\n在为 ENTRYPOINT 选择格式时必须小心，因为这两种格式的效果差别很大。\n\n## Exec 格式\nENTRYPOINT 的 Exec 格式用于设置要执行的命令及其参数，同时可通过 CMD 提供额外的参数。\n\nENTRYPOINT 中的参数始终会被使用，而 CMD 的额外参数可以在容器启动时动态替换掉。\n\n比如下面的 Dockerfile 片段：\n```\nENTRYPOINT [\"/bin/echo\", \"Hello\"]  \n\nCMD [\"world\"]\n```\n当容器通过 docker run -it [image] 启动时，输出为：\n```\nHello world\n```\n而如果通过 docker run -it [image] CloudMan 启动，则输出为：\n```\nHello CloudMan\n```\n## Shell 格式\nENTRYPOINT 的 Shell 格式会忽略任何 CMD 或 docker run 提供的参数。\n\n# 最佳实践\n1. 使用 RUN 指令安装应用和软件包，构建镜像。\n2. 如果 Docker 镜像的用途是运行应用程序或服务，比如运行一个 MySQL，应该优先使用 Exec 格式的 ENTRYPOINT 指令。CMD 可为 ENTRYPOINT 提供额外的默认参数，同时可利用 docker run 命令行替换默认参数。\n3. 如果想为容器设置默认的启动命令，可使用 CMD 指令。用户可在 docker run 命令行中替换此默认命令。\n","source":"_posts/RUN vs CMD vs ENTRYPOINT.md","raw":"---\ntitle: RUN vs CMD vs ENTRYPOINT\ndate: 2018-08-17 09:14:42\ntags: Docker\n---\n\nRUN、CMD 和 ENTRYPOINT 这三个 Dockerfile 指令看上去很类似，很容易混淆。本节将通过实践详细讨论它们的区别。\n\n简单的说：\n1. RUN 执行命令并创建新的镜像层，RUN 经常用于安装软件包。\n2. CMD 设置容器启动后默认执行的命令及其参数，但 CMD 能够被 docker run 后面跟的命令行参数替换。\n3. ENTRYPOINT 配置容器启动时运行的命令。\n\n下面我们详细分析。\n\n<!-- more -->\n\n# Shell 和 Exec 格式\n我们可用两种方式指定 RUN、CMD 和 ENTRYPOINT 要运行的命令：Shell 格式和 Exec 格式，二者在使用上有细微的区别。\n\n==Shell 格式 <instruction> <command>==\n\n例如：\n- RUN apt-get install python3  \n- CMD echo \"Hello world\"  \n- ENTRYPOINT echo \"Hello world\" \n\n当指令执行时，shell 格式底层会调用 ==/bin/sh -c <command>==\n\n例如下面的 Dockerfile 片段：\n\n```\nENV name Cloud Man  \n\nENTRYPOINT echo \"Hello, $name\"\n```\n\n执行 docker run <image> 将输出：Hello, Cloud Man\n\n注意环境变量 name 已经被值 Cloud Man 替换\n\n==Exec 格式 <instruction> [\"executable\", \"param1\", \"param2\", ...]==\n\n例如：\n- RUN [\"apt-get\", \"install\", \"python3\"]\n- CMD [\"/bin/echo\", \"Hello world\"]  \n- ENTRYPOINT [\"/bin/echo\", \"Hello world\"]\n\n当指令执行时，会直接调用 <command>，不会被 shell 解析\n\n例如下面的 Dockerfile 片段：\n\n```\nENV name Cloud Man  \n\nENTRYPOINT [\"/bin/echo\", \"Hello, $name\"]\n```\n\n运行容器将输出：Hello, $name\n\n注意环境变量“name”没有被替换，如果希望使用环境变量，照如下修改\n```\nENV name Cloud Man  \n\nENTRYPOINT [\"/bin/sh\", \"-c\", \"echo Hello, $name\"]\n```\n运行容器将输出：Hello, Cloud Man\n\n==CMD 和 ENTRYPOINT 推荐使用 Exec 格式，因为指令可读性更强，更容易理解。RUN 则两种格式都可以。==\n\n# RUN\n\nRUN 指令通常用于安装应用和软件包。\n\nRUN 在当前镜像的顶部执行命令，并通过创建新的镜像层。Dockerfile 中常常包含多个 RUN 指令。\n\nRUN 有两种格式：\n1. Shell 格式：RUN\n2. Exec 格式：RUN [\"executable\", \"param1\", \"param2\"]\n\n下面是使用 RUN 安装多个包的例子：\n```\n bzr \\\n\n cvs \\\n\n git \\\n\n mercurial \\\n\n subversion\n```\n注意：apt-get update 和 apt-get install 被放在一个 RUN 指令中执行，这样能够保证每次安装的是最新的包。如果 apt-get install 在单独的 RUN 中执行，则会使用 apt-get update 创建的镜像层，而这一层可能是很久以前缓存的。\n\n# CMD\nCMD 指令允许用户指定容器的默认执行的命令\n此命令会在容器启动且 docker run 没有指定其他命令时运行。\n1. 如果 docker run 指定了其他命令，CMD 指定的默认命令将被忽略。\n2. 如果 Dockerfile 中有多个 CMD 指令，只有最后一个 CMD 有效。\n\nCMD 有三种格式：\n1. Exec 格式：==CMD [\"executable\",\"param1\",\"param2\"]== 这是 CMD 的推荐格式。\n2. ==CMD [\"param1\",\"param2\"]== 为 ENTRYPOINT 提供额外的参数，此时 ENTRYPOINT 必须使用 Exec 格式。\n3. Shell 格式：==CMD command param1 param2==\n\nExec 和 Shell 格式前面已经介绍过了。第二种格式 CMD [\"param1\",\"param2\"] 要与 Exec 格式 的 ENTRYPOINT 指令配合使用，其用途是为 ENTRYPOINT 设置默认的参数。我们将在后面讨论 ENTRYPOINT 时举例说明。\n\n下面看看 CMD 是如何工作的。Dockerfile 片段如下：\n```\nCMD echo \"Hello world\"\n```\n运行容器 docker run -it [image] 将输出：\n```\nHello world\n```\n但当后面加上一个命令，比如 docker run -it [image] /bin/bash，CMD 会被忽略掉，命令 bash 将被执行：\n```\nroot@10a32dc7d3d3:/#\n```\n# ENTRYPOINT\nENTRYPOINT 指令可让容器以应用程序或者服务的形式运行。\n\nENTRYPOINT 看上去与 CMD 很像，它们都可以指定要执行的命令及其参数。不同的地方在于 ENTRYPOINT 不会被忽略，一定会被执行，即使运行 docker run 时指定了其他命令。\n\nENTRYPOINT 有两种格式：\n1. Exec 格式：==ENTRYPOINT [\"executable\", \"param1\", \"param2\"]== 这是 ENTRYPOINT 的推荐格式。\n2. Shell 格式：==ENTRYPOINT command param1 param2==\n\n在为 ENTRYPOINT 选择格式时必须小心，因为这两种格式的效果差别很大。\n\n## Exec 格式\nENTRYPOINT 的 Exec 格式用于设置要执行的命令及其参数，同时可通过 CMD 提供额外的参数。\n\nENTRYPOINT 中的参数始终会被使用，而 CMD 的额外参数可以在容器启动时动态替换掉。\n\n比如下面的 Dockerfile 片段：\n```\nENTRYPOINT [\"/bin/echo\", \"Hello\"]  \n\nCMD [\"world\"]\n```\n当容器通过 docker run -it [image] 启动时，输出为：\n```\nHello world\n```\n而如果通过 docker run -it [image] CloudMan 启动，则输出为：\n```\nHello CloudMan\n```\n## Shell 格式\nENTRYPOINT 的 Shell 格式会忽略任何 CMD 或 docker run 提供的参数。\n\n# 最佳实践\n1. 使用 RUN 指令安装应用和软件包，构建镜像。\n2. 如果 Docker 镜像的用途是运行应用程序或服务，比如运行一个 MySQL，应该优先使用 Exec 格式的 ENTRYPOINT 指令。CMD 可为 ENTRYPOINT 提供额外的默认参数，同时可利用 docker run 命令行替换默认参数。\n3. 如果想为容器设置默认的启动命令，可使用 CMD 指令。用户可在 docker run 命令行中替换此默认命令。\n","slug":"RUN vs CMD vs ENTRYPOINT","published":1,"updated":"2019-02-26T02:29:01.539Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsl5qftw0006k8v3hrp050s1","content":"<p>RUN、CMD 和 ENTRYPOINT 这三个 Dockerfile 指令看上去很类似，很容易混淆。本节将通过实践详细讨论它们的区别。</p>\n<p>简单的说：</p>\n<ol>\n<li>RUN 执行命令并创建新的镜像层，RUN 经常用于安装软件包。</li>\n<li>CMD 设置容器启动后默认执行的命令及其参数，但 CMD 能够被 docker run 后面跟的命令行参数替换。</li>\n<li>ENTRYPOINT 配置容器启动时运行的命令。</li>\n</ol>\n<p>下面我们详细分析。</p>\n<a id=\"more\"></a>\n<h1 id=\"Shell-和-Exec-格式\"><a href=\"#Shell-和-Exec-格式\" class=\"headerlink\" title=\"Shell 和 Exec 格式\"></a>Shell 和 Exec 格式</h1><p>我们可用两种方式指定 RUN、CMD 和 ENTRYPOINT 要运行的命令：Shell 格式和 Exec 格式，二者在使用上有细微的区别。</p>\n<p>==Shell 格式 <instruction> <command>==</instruction></p>\n<p>例如：</p>\n<ul>\n<li>RUN apt-get install python3  </li>\n<li>CMD echo “Hello world”  </li>\n<li>ENTRYPOINT echo “Hello world” </li>\n</ul>\n<p>当指令执行时，shell 格式底层会调用 ==/bin/sh -c <command>==</p>\n<p>例如下面的 Dockerfile 片段：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ENV name Cloud Man  </span><br><span class=\"line\"></span><br><span class=\"line\">ENTRYPOINT echo &quot;Hello, $name&quot;</span><br></pre></td></tr></table></figure>\n<p>执行 docker run <image> 将输出：Hello, Cloud Man</image></p>\n<p>注意环境变量 name 已经被值 Cloud Man 替换</p>\n<p>==Exec 格式 <instruction> [“executable”, “param1”, “param2”, …]==</instruction></p>\n<p>例如：</p>\n<ul>\n<li>RUN [“apt-get”, “install”, “python3”]</li>\n<li>CMD [“/bin/echo”, “Hello world”]  </li>\n<li>ENTRYPOINT [“/bin/echo”, “Hello world”]</li>\n</ul>\n<p>当指令执行时，会直接调用 <command>，不会被 shell 解析</p>\n<p>例如下面的 Dockerfile 片段：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ENV name Cloud Man  </span><br><span class=\"line\"></span><br><span class=\"line\">ENTRYPOINT [&quot;/bin/echo&quot;, &quot;Hello, $name&quot;]</span><br></pre></td></tr></table></figure>\n<p>运行容器将输出：Hello, $name</p>\n<p>注意环境变量“name”没有被替换，如果希望使用环境变量，照如下修改<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ENV name Cloud Man  </span><br><span class=\"line\"></span><br><span class=\"line\">ENTRYPOINT [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;echo Hello, $name&quot;]</span><br></pre></td></tr></table></figure></p>\n<p>运行容器将输出：Hello, Cloud Man</p>\n<p>==CMD 和 ENTRYPOINT 推荐使用 Exec 格式，因为指令可读性更强，更容易理解。RUN 则两种格式都可以。==</p>\n<h1 id=\"RUN\"><a href=\"#RUN\" class=\"headerlink\" title=\"RUN\"></a>RUN</h1><p>RUN 指令通常用于安装应用和软件包。</p>\n<p>RUN 在当前镜像的顶部执行命令，并通过创建新的镜像层。Dockerfile 中常常包含多个 RUN 指令。</p>\n<p>RUN 有两种格式：</p>\n<ol>\n<li>Shell 格式：RUN</li>\n<li>Exec 格式：RUN [“executable”, “param1”, “param2”]</li>\n</ol>\n<p>下面是使用 RUN 安装多个包的例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bzr \\</span><br><span class=\"line\"></span><br><span class=\"line\">cvs \\</span><br><span class=\"line\"></span><br><span class=\"line\">git \\</span><br><span class=\"line\"></span><br><span class=\"line\">mercurial \\</span><br><span class=\"line\"></span><br><span class=\"line\">subversion</span><br></pre></td></tr></table></figure></p>\n<p>注意：apt-get update 和 apt-get install 被放在一个 RUN 指令中执行，这样能够保证每次安装的是最新的包。如果 apt-get install 在单独的 RUN 中执行，则会使用 apt-get update 创建的镜像层，而这一层可能是很久以前缓存的。</p>\n<h1 id=\"CMD\"><a href=\"#CMD\" class=\"headerlink\" title=\"CMD\"></a>CMD</h1><p>CMD 指令允许用户指定容器的默认执行的命令<br>此命令会在容器启动且 docker run 没有指定其他命令时运行。</p>\n<ol>\n<li>如果 docker run 指定了其他命令，CMD 指定的默认命令将被忽略。</li>\n<li>如果 Dockerfile 中有多个 CMD 指令，只有最后一个 CMD 有效。</li>\n</ol>\n<p>CMD 有三种格式：</p>\n<ol>\n<li>Exec 格式：==CMD [“executable”,”param1”,”param2”]== 这是 CMD 的推荐格式。</li>\n<li>==CMD [“param1”,”param2”]== 为 ENTRYPOINT 提供额外的参数，此时 ENTRYPOINT 必须使用 Exec 格式。</li>\n<li>Shell 格式：==CMD command param1 param2==</li>\n</ol>\n<p>Exec 和 Shell 格式前面已经介绍过了。第二种格式 CMD [“param1”,”param2”] 要与 Exec 格式 的 ENTRYPOINT 指令配合使用，其用途是为 ENTRYPOINT 设置默认的参数。我们将在后面讨论 ENTRYPOINT 时举例说明。</p>\n<p>下面看看 CMD 是如何工作的。Dockerfile 片段如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CMD echo &quot;Hello world&quot;</span><br></pre></td></tr></table></figure></p>\n<p>运行容器 docker run -it [image] 将输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hello world</span><br></pre></td></tr></table></figure></p>\n<p>但当后面加上一个命令，比如 docker run -it [image] /bin/bash，CMD 会被忽略掉，命令 bash 将被执行：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@10a32dc7d3d3:/#</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"ENTRYPOINT\"><a href=\"#ENTRYPOINT\" class=\"headerlink\" title=\"ENTRYPOINT\"></a>ENTRYPOINT</h1><p>ENTRYPOINT 指令可让容器以应用程序或者服务的形式运行。</p>\n<p>ENTRYPOINT 看上去与 CMD 很像，它们都可以指定要执行的命令及其参数。不同的地方在于 ENTRYPOINT 不会被忽略，一定会被执行，即使运行 docker run 时指定了其他命令。</p>\n<p>ENTRYPOINT 有两种格式：</p>\n<ol>\n<li>Exec 格式：==ENTRYPOINT [“executable”, “param1”, “param2”]== 这是 ENTRYPOINT 的推荐格式。</li>\n<li>Shell 格式：==ENTRYPOINT command param1 param2==</li>\n</ol>\n<p>在为 ENTRYPOINT 选择格式时必须小心，因为这两种格式的效果差别很大。</p>\n<h2 id=\"Exec-格式\"><a href=\"#Exec-格式\" class=\"headerlink\" title=\"Exec 格式\"></a>Exec 格式</h2><p>ENTRYPOINT 的 Exec 格式用于设置要执行的命令及其参数，同时可通过 CMD 提供额外的参数。</p>\n<p>ENTRYPOINT 中的参数始终会被使用，而 CMD 的额外参数可以在容器启动时动态替换掉。</p>\n<p>比如下面的 Dockerfile 片段：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ENTRYPOINT [&quot;/bin/echo&quot;, &quot;Hello&quot;]  </span><br><span class=\"line\"></span><br><span class=\"line\">CMD [&quot;world&quot;]</span><br></pre></td></tr></table></figure></p>\n<p>当容器通过 docker run -it [image] 启动时，输出为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hello world</span><br></pre></td></tr></table></figure></p>\n<p>而如果通过 docker run -it [image] CloudMan 启动，则输出为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hello CloudMan</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Shell-格式\"><a href=\"#Shell-格式\" class=\"headerlink\" title=\"Shell 格式\"></a>Shell 格式</h2><p>ENTRYPOINT 的 Shell 格式会忽略任何 CMD 或 docker run 提供的参数。</p>\n<h1 id=\"最佳实践\"><a href=\"#最佳实践\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h1><ol>\n<li>使用 RUN 指令安装应用和软件包，构建镜像。</li>\n<li>如果 Docker 镜像的用途是运行应用程序或服务，比如运行一个 MySQL，应该优先使用 Exec 格式的 ENTRYPOINT 指令。CMD 可为 ENTRYPOINT 提供额外的默认参数，同时可利用 docker run 命令行替换默认参数。</li>\n<li>如果想为容器设置默认的启动命令，可使用 CMD 指令。用户可在 docker run 命令行中替换此默认命令。</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>RUN、CMD 和 ENTRYPOINT 这三个 Dockerfile 指令看上去很类似，很容易混淆。本节将通过实践详细讨论它们的区别。</p>\n<p>简单的说：</p>\n<ol>\n<li>RUN 执行命令并创建新的镜像层，RUN 经常用于安装软件包。</li>\n<li>CMD 设置容器启动后默认执行的命令及其参数，但 CMD 能够被 docker run 后面跟的命令行参数替换。</li>\n<li>ENTRYPOINT 配置容器启动时运行的命令。</li>\n</ol>\n<p>下面我们详细分析。</p>","more":"<h1 id=\"Shell-和-Exec-格式\"><a href=\"#Shell-和-Exec-格式\" class=\"headerlink\" title=\"Shell 和 Exec 格式\"></a>Shell 和 Exec 格式</h1><p>我们可用两种方式指定 RUN、CMD 和 ENTRYPOINT 要运行的命令：Shell 格式和 Exec 格式，二者在使用上有细微的区别。</p>\n<p>==Shell 格式 <instruction> <command>==</instruction></p>\n<p>例如：</p>\n<ul>\n<li>RUN apt-get install python3  </li>\n<li>CMD echo “Hello world”  </li>\n<li>ENTRYPOINT echo “Hello world” </li>\n</ul>\n<p>当指令执行时，shell 格式底层会调用 ==/bin/sh -c <command>==</p>\n<p>例如下面的 Dockerfile 片段：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ENV name Cloud Man  </span><br><span class=\"line\"></span><br><span class=\"line\">ENTRYPOINT echo &quot;Hello, $name&quot;</span><br></pre></td></tr></table></figure>\n<p>执行 docker run <image> 将输出：Hello, Cloud Man</image></p>\n<p>注意环境变量 name 已经被值 Cloud Man 替换</p>\n<p>==Exec 格式 <instruction> [“executable”, “param1”, “param2”, …]==</instruction></p>\n<p>例如：</p>\n<ul>\n<li>RUN [“apt-get”, “install”, “python3”]</li>\n<li>CMD [“/bin/echo”, “Hello world”]  </li>\n<li>ENTRYPOINT [“/bin/echo”, “Hello world”]</li>\n</ul>\n<p>当指令执行时，会直接调用 <command>，不会被 shell 解析</p>\n<p>例如下面的 Dockerfile 片段：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ENV name Cloud Man  </span><br><span class=\"line\"></span><br><span class=\"line\">ENTRYPOINT [&quot;/bin/echo&quot;, &quot;Hello, $name&quot;]</span><br></pre></td></tr></table></figure>\n<p>运行容器将输出：Hello, $name</p>\n<p>注意环境变量“name”没有被替换，如果希望使用环境变量，照如下修改<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ENV name Cloud Man  </span><br><span class=\"line\"></span><br><span class=\"line\">ENTRYPOINT [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;echo Hello, $name&quot;]</span><br></pre></td></tr></table></figure></p>\n<p>运行容器将输出：Hello, Cloud Man</p>\n<p>==CMD 和 ENTRYPOINT 推荐使用 Exec 格式，因为指令可读性更强，更容易理解。RUN 则两种格式都可以。==</p>\n<h1 id=\"RUN\"><a href=\"#RUN\" class=\"headerlink\" title=\"RUN\"></a>RUN</h1><p>RUN 指令通常用于安装应用和软件包。</p>\n<p>RUN 在当前镜像的顶部执行命令，并通过创建新的镜像层。Dockerfile 中常常包含多个 RUN 指令。</p>\n<p>RUN 有两种格式：</p>\n<ol>\n<li>Shell 格式：RUN</li>\n<li>Exec 格式：RUN [“executable”, “param1”, “param2”]</li>\n</ol>\n<p>下面是使用 RUN 安装多个包的例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bzr \\</span><br><span class=\"line\"></span><br><span class=\"line\">cvs \\</span><br><span class=\"line\"></span><br><span class=\"line\">git \\</span><br><span class=\"line\"></span><br><span class=\"line\">mercurial \\</span><br><span class=\"line\"></span><br><span class=\"line\">subversion</span><br></pre></td></tr></table></figure></p>\n<p>注意：apt-get update 和 apt-get install 被放在一个 RUN 指令中执行，这样能够保证每次安装的是最新的包。如果 apt-get install 在单独的 RUN 中执行，则会使用 apt-get update 创建的镜像层，而这一层可能是很久以前缓存的。</p>\n<h1 id=\"CMD\"><a href=\"#CMD\" class=\"headerlink\" title=\"CMD\"></a>CMD</h1><p>CMD 指令允许用户指定容器的默认执行的命令<br>此命令会在容器启动且 docker run 没有指定其他命令时运行。</p>\n<ol>\n<li>如果 docker run 指定了其他命令，CMD 指定的默认命令将被忽略。</li>\n<li>如果 Dockerfile 中有多个 CMD 指令，只有最后一个 CMD 有效。</li>\n</ol>\n<p>CMD 有三种格式：</p>\n<ol>\n<li>Exec 格式：==CMD [“executable”,”param1”,”param2”]== 这是 CMD 的推荐格式。</li>\n<li>==CMD [“param1”,”param2”]== 为 ENTRYPOINT 提供额外的参数，此时 ENTRYPOINT 必须使用 Exec 格式。</li>\n<li>Shell 格式：==CMD command param1 param2==</li>\n</ol>\n<p>Exec 和 Shell 格式前面已经介绍过了。第二种格式 CMD [“param1”,”param2”] 要与 Exec 格式 的 ENTRYPOINT 指令配合使用，其用途是为 ENTRYPOINT 设置默认的参数。我们将在后面讨论 ENTRYPOINT 时举例说明。</p>\n<p>下面看看 CMD 是如何工作的。Dockerfile 片段如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CMD echo &quot;Hello world&quot;</span><br></pre></td></tr></table></figure></p>\n<p>运行容器 docker run -it [image] 将输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hello world</span><br></pre></td></tr></table></figure></p>\n<p>但当后面加上一个命令，比如 docker run -it [image] /bin/bash，CMD 会被忽略掉，命令 bash 将被执行：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@10a32dc7d3d3:/#</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"ENTRYPOINT\"><a href=\"#ENTRYPOINT\" class=\"headerlink\" title=\"ENTRYPOINT\"></a>ENTRYPOINT</h1><p>ENTRYPOINT 指令可让容器以应用程序或者服务的形式运行。</p>\n<p>ENTRYPOINT 看上去与 CMD 很像，它们都可以指定要执行的命令及其参数。不同的地方在于 ENTRYPOINT 不会被忽略，一定会被执行，即使运行 docker run 时指定了其他命令。</p>\n<p>ENTRYPOINT 有两种格式：</p>\n<ol>\n<li>Exec 格式：==ENTRYPOINT [“executable”, “param1”, “param2”]== 这是 ENTRYPOINT 的推荐格式。</li>\n<li>Shell 格式：==ENTRYPOINT command param1 param2==</li>\n</ol>\n<p>在为 ENTRYPOINT 选择格式时必须小心，因为这两种格式的效果差别很大。</p>\n<h2 id=\"Exec-格式\"><a href=\"#Exec-格式\" class=\"headerlink\" title=\"Exec 格式\"></a>Exec 格式</h2><p>ENTRYPOINT 的 Exec 格式用于设置要执行的命令及其参数，同时可通过 CMD 提供额外的参数。</p>\n<p>ENTRYPOINT 中的参数始终会被使用，而 CMD 的额外参数可以在容器启动时动态替换掉。</p>\n<p>比如下面的 Dockerfile 片段：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ENTRYPOINT [&quot;/bin/echo&quot;, &quot;Hello&quot;]  </span><br><span class=\"line\"></span><br><span class=\"line\">CMD [&quot;world&quot;]</span><br></pre></td></tr></table></figure></p>\n<p>当容器通过 docker run -it [image] 启动时，输出为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hello world</span><br></pre></td></tr></table></figure></p>\n<p>而如果通过 docker run -it [image] CloudMan 启动，则输出为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hello CloudMan</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Shell-格式\"><a href=\"#Shell-格式\" class=\"headerlink\" title=\"Shell 格式\"></a>Shell 格式</h2><p>ENTRYPOINT 的 Shell 格式会忽略任何 CMD 或 docker run 提供的参数。</p>\n<h1 id=\"最佳实践\"><a href=\"#最佳实践\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h1><ol>\n<li>使用 RUN 指令安装应用和软件包，构建镜像。</li>\n<li>如果 Docker 镜像的用途是运行应用程序或服务，比如运行一个 MySQL，应该优先使用 Exec 格式的 ENTRYPOINT 指令。CMD 可为 ENTRYPOINT 提供额外的默认参数，同时可利用 docker run 命令行替换默认参数。</li>\n<li>如果想为容器设置默认的启动命令，可使用 CMD 指令。用户可在 docker run 命令行中替换此默认命令。</li>\n</ol>"},{"title":"slice切片的操作——切片的追加、删除、插入等","date":"2018-07-15T18:02:30.000Z","_content":"# 一、一般操作\n\n1. 声明变量，go自动初始化为nil，长度：0，地址：0，nil\n\n```\nfunc main(){\n    var ss []string;\n    fmt.Printf(\"length:%v \\taddr:%p \\tisnil:%v\",len(ss),ss, ss==nil)    \n}\n\n---\nRunning...\n\nlength:0     addr:0x0     isnil:true\nSuccess: process exited with code 0.\n```\n\n<!-- more -->\n\n2. 切片的追加，删除，插入操作\n\n```\nfunc main(){\n    var ss []string;\n    fmt.Printf(\"[ local print ]\\t:\\t length:%v\\taddr:%p\\tisnil:%v\\n\",len(ss),ss, ss==nil)    \n    print(\"func print\",ss)\n    //切片尾部追加元素append elemnt\n    for i:=0;i<10;i++{\n        ss=append(ss,fmt.Sprintf(\"s%d\",i));\n    }\n    fmt.Printf(\"[ local print ]\\t:\\tlength:%v\\taddr:%p\\tisnil:%v\\n\",len(ss),ss, ss==nil)    \n    print(\"after append\",ss)\n    //删除切片元素remove element at index\n    index:=5;\n    ss=append(ss[:index],ss[index+1:]...)\n    print(\"after delete\",ss)\n    //在切片中间插入元素insert element at index;\n    //注意：保存后部剩余元素，必须新建一个临时切片\n    rear:=append([]string{},ss[index:]...) \n    ss=append(ss[0:index],\"inserted\")\n    ss=append(ss,rear...)\n    print(\"after insert\",ss)\n}\nfunc print(msg string,ss []string){\n    fmt.Printf(\"[ %20s ]\\t:\\tlength:%v\\taddr:%p\\tisnil:%v\\tcontent:%v\",msg,len(ss),ss, ss==nil,ss)    \n    fmt.Println()\n}\n------\nRunning...\n\n[ local print ]    :     length:0    addr:0x0    isnil:true\n[           func print ]    :    length:0    addr:0x0    isnil:true    content:[]\n[ local print ]    :    length:10    addr:0xc208056000    isnil:false\n[         after append ]    :    length:10    addr:0xc208056000    isnil:false    content:[s0 s1 s2 s3 s4 s5 s6 s7 s8 s9]\n[         after delete ]    :    length:9    addr:0xc208056000    isnil:false    content:[s0 s1 s2 s3 s4 s6 s7 s8 s9]\n[         after insert ]    :    length:10    addr:0xc208056000    isnil:false    content:[s0 s1 s2 s3 s4 inserted s6 s7 s8 s9]\n\nSuccess: process exited with code 0.\n```\n3. copy的使用\n\n在使用copy复制切片之前，要保证目标切片有足够的大小，注意是大小，而不是容量，还是看例子：\n\n```\nfunc main() {\n    var sa = make ([]string,0);\n    for i:=0;i<10;i++{\n        sa=append(sa,fmt.Sprintf(\"%v\",i))\n        \n    }\n    var da =make([]string,0,10);\n    var cc=0;\n    cc= copy(da,sa);\n    fmt.Printf(\"copy to da(len=%d)\\t%v\\n\",len(da),da)\n    da = make([]string,5)\n    cc=copy(da,sa);\n    fmt.Printf(\"copy to da(len=%d)\\tcopied=%d\\t%v\\n\",len(da),cc,da)\n     da = make([]string,10)\n    cc =copy(da,sa);\n    fmt.Printf(\"copy to da(len=%d)\\tcopied=%d\\t%v\\n\",len(da),cc,da)\n    \n}\n\n---\nRunning...\n\ncopy to da(len=0)    []\ncopy to da(len=5)    copied=5    [0 1 2 3 4]\ncopy to da(len=10)    copied=10    [0 1 2 3 4 5 6 7 8 9]\n```\n从上面运行结果，明显看出，目标切片大小0，容量10，copy不能复制。目标切片大小小于源切片大小，copy就按照目标切片大小复制，不会报错。\n# 二、初始大小和容量\n\n当我们使用make初始化切片的时候，必须给出size。go语言的书上一般都会告诉我们，当切片有足够大小的时候，append操作是非常快的。但是当给出初始大小后，我们得到的实际上是一个含有这个size数量切片类型的空元素，看例子：\n\n```\nfunc main(){\n    var ss=make([]string,10);\n    ss=append(ss,\"last\");\n    print(\"after append\",ss)\n    \n}\n---\nRunning...\n\n[         after append ]    :    length:11    addr:0xc20804c000    isnil:false    content:[          last]\n```\n实际上，此时我们应该先用下标为切片元素负值。但是如果我们既想有好的效率，有想继续使用append函数而不想区分是否有空的元素，此时就要请出make的第三个参数，容量，也就是我们通过传递给make，0的大小和足够大的容量数值就行了。\n\n```\nfunc main(){\n    var ss=make([]string,0,10);\n    ss=append(ss,\"last\");\n    print(\"after append\",ss)\n    \n}\n\n---\nRunning...\n\n[         after append ]    :    length:1    addr:0xc20804a000    isnil:false    content:[last]\n```\n# 三、切片的指针\n1. 当我们用append追加元素到切片时，如果容量不够，go就会创建一个新的切片变量，看下面程序的执行结果：\n\n```\nfunc main() {\n    var sa []string\nfmt.Printf(\"addr:%p \\t\\tlen:%v content:%v\\n\",sa,len(sa),sa);\n    for i:=0;i<10;i++{\n        sa=append(sa,fmt.Sprintf(\"%v\",i))\n        fmt.Printf(\"addr:%p \\t\\tlen:%v content:%v\\n\",sa,len(sa),sa);\n    }\n    fmt.Printf(\"addr:%p \\t\\tlen:%v content:%v\\n\",sa,len(sa),sa);\n\n}\n\n---\nRunning ...\naddr:0x0         len:0 content:[]\naddr:0x1030e0c8         len:1 content:[0]\naddr:0x10328120         len:2 content:[0 1]\naddr:0x10322180         len:3 content:[0 1 2]\naddr:0x10322180         len:4 content:[0 1 2 3]\naddr:0x10342080         len:5 content:[0 1 2 3 4]\naddr:0x10342080         len:6 content:[0 1 2 3 4 5]\naddr:0x10342080         len:7 content:[0 1 2 3 4 5 6]\naddr:0x10342080         len:8 content:[0 1 2 3 4 5 6 7]\naddr:0x10324a00         len:9 content:[0 1 2 3 4 5 6 7 8]\naddr:0x10324a00         len:10 content:[0 1 2 3 4 5 6 7 8 9]\naddr:0x10324a00         len:10 content:[0 1 2 3 4 5 6 7 8 9]\n\n//很明显，切片的地址经过了数次改变。\n```\n2.如果，在make初始化切片的时候给出了足够的容量，append操作不会创建新的切片：\n\n```\nfunc main() {\n    var sa = make ([]string,0,10);\nfmt.Printf(\"addr:%p \\t\\tlen:%v content:%v\\n\",sa,len(sa),sa);\n    for i:=0;i<10;i++{\n        sa=append(sa,fmt.Sprintf(\"%v\",i))\n        fmt.Printf(\"addr:%p \\t\\tlen:%v content:%v\\n\",sa,len(sa),sa);\n    }\n    fmt.Printf(\"addr:%p \\t\\tlen:%v content:%v\\n\",sa,len(sa),sa);\n\n}\naddr:0x10304140         len:0 content:[]\naddr:0x10304140         len:1 content:[0]\naddr:0x10304140         len:2 content:[0 1]\naddr:0x10304140         len:3 content:[0 1 2]\naddr:0x10304140         len:4 content:[0 1 2 3]\naddr:0x10304140         len:5 content:[0 1 2 3 4]\naddr:0x10304140         len:6 content:[0 1 2 3 4 5]\naddr:0x10304140         len:7 content:[0 1 2 3 4 5 6]\naddr:0x10304140         len:8 content:[0 1 2 3 4 5 6 7]\naddr:0x10304140         len:9 content:[0 1 2 3 4 5 6 7 8]\naddr:0x10304140         len:10 content:[0 1 2 3 4 5 6 7 8 9]\naddr:0x10304140         len:10 content:[0 1 2 3 4 5 6 7 8 9]\n\n//可见，切片的地址一直保持不变\n```\n3.如果不能准确预估切片的大小，又不想改变变量（如：为了共享数据的改变），这时候就要请出指针来帮忙了，下面程序中，sa就是osa这个切片的指针，我们共享切片数据和操作切片的时候都使用这个切片地址就ok了，其本质上是：append操作亦然会在需要的时候构造新的切片，不过是将地址都保存到了sa中，因此我们通过该指针始终可以访问到真正的数据。\n\n```\nfunc main() {\n    var osa = make ([]string,0);\n    sa:=&osa;\n    for i:=0;i<10;i++{\n        *sa=append(*sa,fmt.Sprintf(\"%v\",i))\n        fmt.Printf(\"addr of osa:%p,\\taddr:%p \\t content:%v\\n\",osa,sa,sa);\n    }\n    fmt.Printf(\"addr of osa:%p,\\taddr:%p \\t content:%v\\n\",osa,sa,sa);\n   \n}\n\n---\nRunning...\n\naddr of osa:0xc20800a220,    addr:0xc20801e020      content:&[0]\naddr of osa:0xc20801e0a0,    addr:0xc20801e020      content:&[0 1]\naddr of osa:0xc20803e0c0,    addr:0xc20801e020      content:&[0 1 2]\naddr of osa:0xc20803e0c0,    addr:0xc20801e020      content:&[0 1 2 3]\naddr of osa:0xc208050080,    addr:0xc20801e020      content:&[0 1 2 3 4]\naddr of osa:0xc208050080,    addr:0xc20801e020      content:&[0 1 2 3 4 5]\naddr of osa:0xc208050080,    addr:0xc20801e020      content:&[0 1 2 3 4 5 6]\naddr of osa:0xc208050080,    addr:0xc20801e020      content:&[0 1 2 3 4 5 6 7]\naddr of osa:0xc208052000,    addr:0xc20801e020      content:&[0 1 2 3 4 5 6 7 8]\naddr of osa:0xc208052000,    addr:0xc20801e020      content:&[0 1 2 3 4 5 6 7 8 9]\naddr of osa:0xc208052000,    addr:0xc20801e020      content:&[0 1 2 3 4 5 6 7 8 9]\n```\n\n","source":"_posts/slice.md","raw":"---\ntitle: slice切片的操作——切片的追加、删除、插入等\ndate: 2018-07-16 02:02:30\ntags: Go\n---\n# 一、一般操作\n\n1. 声明变量，go自动初始化为nil，长度：0，地址：0，nil\n\n```\nfunc main(){\n    var ss []string;\n    fmt.Printf(\"length:%v \\taddr:%p \\tisnil:%v\",len(ss),ss, ss==nil)    \n}\n\n---\nRunning...\n\nlength:0     addr:0x0     isnil:true\nSuccess: process exited with code 0.\n```\n\n<!-- more -->\n\n2. 切片的追加，删除，插入操作\n\n```\nfunc main(){\n    var ss []string;\n    fmt.Printf(\"[ local print ]\\t:\\t length:%v\\taddr:%p\\tisnil:%v\\n\",len(ss),ss, ss==nil)    \n    print(\"func print\",ss)\n    //切片尾部追加元素append elemnt\n    for i:=0;i<10;i++{\n        ss=append(ss,fmt.Sprintf(\"s%d\",i));\n    }\n    fmt.Printf(\"[ local print ]\\t:\\tlength:%v\\taddr:%p\\tisnil:%v\\n\",len(ss),ss, ss==nil)    \n    print(\"after append\",ss)\n    //删除切片元素remove element at index\n    index:=5;\n    ss=append(ss[:index],ss[index+1:]...)\n    print(\"after delete\",ss)\n    //在切片中间插入元素insert element at index;\n    //注意：保存后部剩余元素，必须新建一个临时切片\n    rear:=append([]string{},ss[index:]...) \n    ss=append(ss[0:index],\"inserted\")\n    ss=append(ss,rear...)\n    print(\"after insert\",ss)\n}\nfunc print(msg string,ss []string){\n    fmt.Printf(\"[ %20s ]\\t:\\tlength:%v\\taddr:%p\\tisnil:%v\\tcontent:%v\",msg,len(ss),ss, ss==nil,ss)    \n    fmt.Println()\n}\n------\nRunning...\n\n[ local print ]    :     length:0    addr:0x0    isnil:true\n[           func print ]    :    length:0    addr:0x0    isnil:true    content:[]\n[ local print ]    :    length:10    addr:0xc208056000    isnil:false\n[         after append ]    :    length:10    addr:0xc208056000    isnil:false    content:[s0 s1 s2 s3 s4 s5 s6 s7 s8 s9]\n[         after delete ]    :    length:9    addr:0xc208056000    isnil:false    content:[s0 s1 s2 s3 s4 s6 s7 s8 s9]\n[         after insert ]    :    length:10    addr:0xc208056000    isnil:false    content:[s0 s1 s2 s3 s4 inserted s6 s7 s8 s9]\n\nSuccess: process exited with code 0.\n```\n3. copy的使用\n\n在使用copy复制切片之前，要保证目标切片有足够的大小，注意是大小，而不是容量，还是看例子：\n\n```\nfunc main() {\n    var sa = make ([]string,0);\n    for i:=0;i<10;i++{\n        sa=append(sa,fmt.Sprintf(\"%v\",i))\n        \n    }\n    var da =make([]string,0,10);\n    var cc=0;\n    cc= copy(da,sa);\n    fmt.Printf(\"copy to da(len=%d)\\t%v\\n\",len(da),da)\n    da = make([]string,5)\n    cc=copy(da,sa);\n    fmt.Printf(\"copy to da(len=%d)\\tcopied=%d\\t%v\\n\",len(da),cc,da)\n     da = make([]string,10)\n    cc =copy(da,sa);\n    fmt.Printf(\"copy to da(len=%d)\\tcopied=%d\\t%v\\n\",len(da),cc,da)\n    \n}\n\n---\nRunning...\n\ncopy to da(len=0)    []\ncopy to da(len=5)    copied=5    [0 1 2 3 4]\ncopy to da(len=10)    copied=10    [0 1 2 3 4 5 6 7 8 9]\n```\n从上面运行结果，明显看出，目标切片大小0，容量10，copy不能复制。目标切片大小小于源切片大小，copy就按照目标切片大小复制，不会报错。\n# 二、初始大小和容量\n\n当我们使用make初始化切片的时候，必须给出size。go语言的书上一般都会告诉我们，当切片有足够大小的时候，append操作是非常快的。但是当给出初始大小后，我们得到的实际上是一个含有这个size数量切片类型的空元素，看例子：\n\n```\nfunc main(){\n    var ss=make([]string,10);\n    ss=append(ss,\"last\");\n    print(\"after append\",ss)\n    \n}\n---\nRunning...\n\n[         after append ]    :    length:11    addr:0xc20804c000    isnil:false    content:[          last]\n```\n实际上，此时我们应该先用下标为切片元素负值。但是如果我们既想有好的效率，有想继续使用append函数而不想区分是否有空的元素，此时就要请出make的第三个参数，容量，也就是我们通过传递给make，0的大小和足够大的容量数值就行了。\n\n```\nfunc main(){\n    var ss=make([]string,0,10);\n    ss=append(ss,\"last\");\n    print(\"after append\",ss)\n    \n}\n\n---\nRunning...\n\n[         after append ]    :    length:1    addr:0xc20804a000    isnil:false    content:[last]\n```\n# 三、切片的指针\n1. 当我们用append追加元素到切片时，如果容量不够，go就会创建一个新的切片变量，看下面程序的执行结果：\n\n```\nfunc main() {\n    var sa []string\nfmt.Printf(\"addr:%p \\t\\tlen:%v content:%v\\n\",sa,len(sa),sa);\n    for i:=0;i<10;i++{\n        sa=append(sa,fmt.Sprintf(\"%v\",i))\n        fmt.Printf(\"addr:%p \\t\\tlen:%v content:%v\\n\",sa,len(sa),sa);\n    }\n    fmt.Printf(\"addr:%p \\t\\tlen:%v content:%v\\n\",sa,len(sa),sa);\n\n}\n\n---\nRunning ...\naddr:0x0         len:0 content:[]\naddr:0x1030e0c8         len:1 content:[0]\naddr:0x10328120         len:2 content:[0 1]\naddr:0x10322180         len:3 content:[0 1 2]\naddr:0x10322180         len:4 content:[0 1 2 3]\naddr:0x10342080         len:5 content:[0 1 2 3 4]\naddr:0x10342080         len:6 content:[0 1 2 3 4 5]\naddr:0x10342080         len:7 content:[0 1 2 3 4 5 6]\naddr:0x10342080         len:8 content:[0 1 2 3 4 5 6 7]\naddr:0x10324a00         len:9 content:[0 1 2 3 4 5 6 7 8]\naddr:0x10324a00         len:10 content:[0 1 2 3 4 5 6 7 8 9]\naddr:0x10324a00         len:10 content:[0 1 2 3 4 5 6 7 8 9]\n\n//很明显，切片的地址经过了数次改变。\n```\n2.如果，在make初始化切片的时候给出了足够的容量，append操作不会创建新的切片：\n\n```\nfunc main() {\n    var sa = make ([]string,0,10);\nfmt.Printf(\"addr:%p \\t\\tlen:%v content:%v\\n\",sa,len(sa),sa);\n    for i:=0;i<10;i++{\n        sa=append(sa,fmt.Sprintf(\"%v\",i))\n        fmt.Printf(\"addr:%p \\t\\tlen:%v content:%v\\n\",sa,len(sa),sa);\n    }\n    fmt.Printf(\"addr:%p \\t\\tlen:%v content:%v\\n\",sa,len(sa),sa);\n\n}\naddr:0x10304140         len:0 content:[]\naddr:0x10304140         len:1 content:[0]\naddr:0x10304140         len:2 content:[0 1]\naddr:0x10304140         len:3 content:[0 1 2]\naddr:0x10304140         len:4 content:[0 1 2 3]\naddr:0x10304140         len:5 content:[0 1 2 3 4]\naddr:0x10304140         len:6 content:[0 1 2 3 4 5]\naddr:0x10304140         len:7 content:[0 1 2 3 4 5 6]\naddr:0x10304140         len:8 content:[0 1 2 3 4 5 6 7]\naddr:0x10304140         len:9 content:[0 1 2 3 4 5 6 7 8]\naddr:0x10304140         len:10 content:[0 1 2 3 4 5 6 7 8 9]\naddr:0x10304140         len:10 content:[0 1 2 3 4 5 6 7 8 9]\n\n//可见，切片的地址一直保持不变\n```\n3.如果不能准确预估切片的大小，又不想改变变量（如：为了共享数据的改变），这时候就要请出指针来帮忙了，下面程序中，sa就是osa这个切片的指针，我们共享切片数据和操作切片的时候都使用这个切片地址就ok了，其本质上是：append操作亦然会在需要的时候构造新的切片，不过是将地址都保存到了sa中，因此我们通过该指针始终可以访问到真正的数据。\n\n```\nfunc main() {\n    var osa = make ([]string,0);\n    sa:=&osa;\n    for i:=0;i<10;i++{\n        *sa=append(*sa,fmt.Sprintf(\"%v\",i))\n        fmt.Printf(\"addr of osa:%p,\\taddr:%p \\t content:%v\\n\",osa,sa,sa);\n    }\n    fmt.Printf(\"addr of osa:%p,\\taddr:%p \\t content:%v\\n\",osa,sa,sa);\n   \n}\n\n---\nRunning...\n\naddr of osa:0xc20800a220,    addr:0xc20801e020      content:&[0]\naddr of osa:0xc20801e0a0,    addr:0xc20801e020      content:&[0 1]\naddr of osa:0xc20803e0c0,    addr:0xc20801e020      content:&[0 1 2]\naddr of osa:0xc20803e0c0,    addr:0xc20801e020      content:&[0 1 2 3]\naddr of osa:0xc208050080,    addr:0xc20801e020      content:&[0 1 2 3 4]\naddr of osa:0xc208050080,    addr:0xc20801e020      content:&[0 1 2 3 4 5]\naddr of osa:0xc208050080,    addr:0xc20801e020      content:&[0 1 2 3 4 5 6]\naddr of osa:0xc208050080,    addr:0xc20801e020      content:&[0 1 2 3 4 5 6 7]\naddr of osa:0xc208052000,    addr:0xc20801e020      content:&[0 1 2 3 4 5 6 7 8]\naddr of osa:0xc208052000,    addr:0xc20801e020      content:&[0 1 2 3 4 5 6 7 8 9]\naddr of osa:0xc208052000,    addr:0xc20801e020      content:&[0 1 2 3 4 5 6 7 8 9]\n```\n\n","slug":"slice","published":1,"updated":"2019-02-26T02:29:01.542Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsl5qftx0007k8v3sg1ruvcu","content":"<h1 id=\"一、一般操作\"><a href=\"#一、一般操作\" class=\"headerlink\" title=\"一、一般操作\"></a>一、一般操作</h1><ol>\n<li>声明变量，go自动初始化为nil，长度：0，地址：0，nil</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func main()&#123;</span><br><span class=\"line\">    var ss []string;</span><br><span class=\"line\">    fmt.Printf(&quot;length:%v \\taddr:%p \\tisnil:%v&quot;,len(ss),ss, ss==nil)    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">---</span><br><span class=\"line\">Running...</span><br><span class=\"line\"></span><br><span class=\"line\">length:0     addr:0x0     isnil:true</span><br><span class=\"line\">Success: process exited with code 0.</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<ol start=\"2\">\n<li>切片的追加，删除，插入操作</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func main()&#123;</span><br><span class=\"line\">    var ss []string;</span><br><span class=\"line\">    fmt.Printf(&quot;[ local print ]\\t:\\t length:%v\\taddr:%p\\tisnil:%v\\n&quot;,len(ss),ss, ss==nil)    </span><br><span class=\"line\">    print(&quot;func print&quot;,ss)</span><br><span class=\"line\">    //切片尾部追加元素append elemnt</span><br><span class=\"line\">    for i:=0;i&lt;10;i++&#123;</span><br><span class=\"line\">        ss=append(ss,fmt.Sprintf(&quot;s%d&quot;,i));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fmt.Printf(&quot;[ local print ]\\t:\\tlength:%v\\taddr:%p\\tisnil:%v\\n&quot;,len(ss),ss, ss==nil)    </span><br><span class=\"line\">    print(&quot;after append&quot;,ss)</span><br><span class=\"line\">    //删除切片元素remove element at index</span><br><span class=\"line\">    index:=5;</span><br><span class=\"line\">    ss=append(ss[:index],ss[index+1:]...)</span><br><span class=\"line\">    print(&quot;after delete&quot;,ss)</span><br><span class=\"line\">    //在切片中间插入元素insert element at index;</span><br><span class=\"line\">    //注意：保存后部剩余元素，必须新建一个临时切片</span><br><span class=\"line\">    rear:=append([]string&#123;&#125;,ss[index:]...) </span><br><span class=\"line\">    ss=append(ss[0:index],&quot;inserted&quot;)</span><br><span class=\"line\">    ss=append(ss,rear...)</span><br><span class=\"line\">    print(&quot;after insert&quot;,ss)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">func print(msg string,ss []string)&#123;</span><br><span class=\"line\">    fmt.Printf(&quot;[ %20s ]\\t:\\tlength:%v\\taddr:%p\\tisnil:%v\\tcontent:%v&quot;,msg,len(ss),ss, ss==nil,ss)    </span><br><span class=\"line\">    fmt.Println()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">------</span><br><span class=\"line\">Running...</span><br><span class=\"line\"></span><br><span class=\"line\">[ local print ]    :     length:0    addr:0x0    isnil:true</span><br><span class=\"line\">[           func print ]    :    length:0    addr:0x0    isnil:true    content:[]</span><br><span class=\"line\">[ local print ]    :    length:10    addr:0xc208056000    isnil:false</span><br><span class=\"line\">[         after append ]    :    length:10    addr:0xc208056000    isnil:false    content:[s0 s1 s2 s3 s4 s5 s6 s7 s8 s9]</span><br><span class=\"line\">[         after delete ]    :    length:9    addr:0xc208056000    isnil:false    content:[s0 s1 s2 s3 s4 s6 s7 s8 s9]</span><br><span class=\"line\">[         after insert ]    :    length:10    addr:0xc208056000    isnil:false    content:[s0 s1 s2 s3 s4 inserted s6 s7 s8 s9]</span><br><span class=\"line\"></span><br><span class=\"line\">Success: process exited with code 0.</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>copy的使用</li>\n</ol>\n<p>在使用copy复制切片之前，要保证目标切片有足够的大小，注意是大小，而不是容量，还是看例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    var sa = make ([]string,0);</span><br><span class=\"line\">    for i:=0;i&lt;10;i++&#123;</span><br><span class=\"line\">        sa=append(sa,fmt.Sprintf(&quot;%v&quot;,i))</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var da =make([]string,0,10);</span><br><span class=\"line\">    var cc=0;</span><br><span class=\"line\">    cc= copy(da,sa);</span><br><span class=\"line\">    fmt.Printf(&quot;copy to da(len=%d)\\t%v\\n&quot;,len(da),da)</span><br><span class=\"line\">    da = make([]string,5)</span><br><span class=\"line\">    cc=copy(da,sa);</span><br><span class=\"line\">    fmt.Printf(&quot;copy to da(len=%d)\\tcopied=%d\\t%v\\n&quot;,len(da),cc,da)</span><br><span class=\"line\">     da = make([]string,10)</span><br><span class=\"line\">    cc =copy(da,sa);</span><br><span class=\"line\">    fmt.Printf(&quot;copy to da(len=%d)\\tcopied=%d\\t%v\\n&quot;,len(da),cc,da)</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">---</span><br><span class=\"line\">Running...</span><br><span class=\"line\"></span><br><span class=\"line\">copy to da(len=0)    []</span><br><span class=\"line\">copy to da(len=5)    copied=5    [0 1 2 3 4]</span><br><span class=\"line\">copy to da(len=10)    copied=10    [0 1 2 3 4 5 6 7 8 9]</span><br></pre></td></tr></table></figure>\n<p>从上面运行结果，明显看出，目标切片大小0，容量10，copy不能复制。目标切片大小小于源切片大小，copy就按照目标切片大小复制，不会报错。</p>\n<h1 id=\"二、初始大小和容量\"><a href=\"#二、初始大小和容量\" class=\"headerlink\" title=\"二、初始大小和容量\"></a>二、初始大小和容量</h1><p>当我们使用make初始化切片的时候，必须给出size。go语言的书上一般都会告诉我们，当切片有足够大小的时候，append操作是非常快的。但是当给出初始大小后，我们得到的实际上是一个含有这个size数量切片类型的空元素，看例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func main()&#123;</span><br><span class=\"line\">    var ss=make([]string,10);</span><br><span class=\"line\">    ss=append(ss,&quot;last&quot;);</span><br><span class=\"line\">    print(&quot;after append&quot;,ss)</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">---</span><br><span class=\"line\">Running...</span><br><span class=\"line\"></span><br><span class=\"line\">[         after append ]    :    length:11    addr:0xc20804c000    isnil:false    content:[          last]</span><br></pre></td></tr></table></figure>\n<p>实际上，此时我们应该先用下标为切片元素负值。但是如果我们既想有好的效率，有想继续使用append函数而不想区分是否有空的元素，此时就要请出make的第三个参数，容量，也就是我们通过传递给make，0的大小和足够大的容量数值就行了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func main()&#123;</span><br><span class=\"line\">    var ss=make([]string,0,10);</span><br><span class=\"line\">    ss=append(ss,&quot;last&quot;);</span><br><span class=\"line\">    print(&quot;after append&quot;,ss)</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">---</span><br><span class=\"line\">Running...</span><br><span class=\"line\"></span><br><span class=\"line\">[         after append ]    :    length:1    addr:0xc20804a000    isnil:false    content:[last]</span><br></pre></td></tr></table></figure>\n<h1 id=\"三、切片的指针\"><a href=\"#三、切片的指针\" class=\"headerlink\" title=\"三、切片的指针\"></a>三、切片的指针</h1><ol>\n<li>当我们用append追加元素到切片时，如果容量不够，go就会创建一个新的切片变量，看下面程序的执行结果：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    var sa []string</span><br><span class=\"line\">fmt.Printf(&quot;addr:%p \\t\\tlen:%v content:%v\\n&quot;,sa,len(sa),sa);</span><br><span class=\"line\">    for i:=0;i&lt;10;i++&#123;</span><br><span class=\"line\">        sa=append(sa,fmt.Sprintf(&quot;%v&quot;,i))</span><br><span class=\"line\">        fmt.Printf(&quot;addr:%p \\t\\tlen:%v content:%v\\n&quot;,sa,len(sa),sa);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fmt.Printf(&quot;addr:%p \\t\\tlen:%v content:%v\\n&quot;,sa,len(sa),sa);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">---</span><br><span class=\"line\">Running ...</span><br><span class=\"line\">addr:0x0         len:0 content:[]</span><br><span class=\"line\">addr:0x1030e0c8         len:1 content:[0]</span><br><span class=\"line\">addr:0x10328120         len:2 content:[0 1]</span><br><span class=\"line\">addr:0x10322180         len:3 content:[0 1 2]</span><br><span class=\"line\">addr:0x10322180         len:4 content:[0 1 2 3]</span><br><span class=\"line\">addr:0x10342080         len:5 content:[0 1 2 3 4]</span><br><span class=\"line\">addr:0x10342080         len:6 content:[0 1 2 3 4 5]</span><br><span class=\"line\">addr:0x10342080         len:7 content:[0 1 2 3 4 5 6]</span><br><span class=\"line\">addr:0x10342080         len:8 content:[0 1 2 3 4 5 6 7]</span><br><span class=\"line\">addr:0x10324a00         len:9 content:[0 1 2 3 4 5 6 7 8]</span><br><span class=\"line\">addr:0x10324a00         len:10 content:[0 1 2 3 4 5 6 7 8 9]</span><br><span class=\"line\">addr:0x10324a00         len:10 content:[0 1 2 3 4 5 6 7 8 9]</span><br><span class=\"line\"></span><br><span class=\"line\">//很明显，切片的地址经过了数次改变。</span><br></pre></td></tr></table></figure>\n<p>2.如果，在make初始化切片的时候给出了足够的容量，append操作不会创建新的切片：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    var sa = make ([]string,0,10);</span><br><span class=\"line\">fmt.Printf(&quot;addr:%p \\t\\tlen:%v content:%v\\n&quot;,sa,len(sa),sa);</span><br><span class=\"line\">    for i:=0;i&lt;10;i++&#123;</span><br><span class=\"line\">        sa=append(sa,fmt.Sprintf(&quot;%v&quot;,i))</span><br><span class=\"line\">        fmt.Printf(&quot;addr:%p \\t\\tlen:%v content:%v\\n&quot;,sa,len(sa),sa);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fmt.Printf(&quot;addr:%p \\t\\tlen:%v content:%v\\n&quot;,sa,len(sa),sa);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">addr:0x10304140         len:0 content:[]</span><br><span class=\"line\">addr:0x10304140         len:1 content:[0]</span><br><span class=\"line\">addr:0x10304140         len:2 content:[0 1]</span><br><span class=\"line\">addr:0x10304140         len:3 content:[0 1 2]</span><br><span class=\"line\">addr:0x10304140         len:4 content:[0 1 2 3]</span><br><span class=\"line\">addr:0x10304140         len:5 content:[0 1 2 3 4]</span><br><span class=\"line\">addr:0x10304140         len:6 content:[0 1 2 3 4 5]</span><br><span class=\"line\">addr:0x10304140         len:7 content:[0 1 2 3 4 5 6]</span><br><span class=\"line\">addr:0x10304140         len:8 content:[0 1 2 3 4 5 6 7]</span><br><span class=\"line\">addr:0x10304140         len:9 content:[0 1 2 3 4 5 6 7 8]</span><br><span class=\"line\">addr:0x10304140         len:10 content:[0 1 2 3 4 5 6 7 8 9]</span><br><span class=\"line\">addr:0x10304140         len:10 content:[0 1 2 3 4 5 6 7 8 9]</span><br><span class=\"line\"></span><br><span class=\"line\">//可见，切片的地址一直保持不变</span><br></pre></td></tr></table></figure>\n<p>3.如果不能准确预估切片的大小，又不想改变变量（如：为了共享数据的改变），这时候就要请出指针来帮忙了，下面程序中，sa就是osa这个切片的指针，我们共享切片数据和操作切片的时候都使用这个切片地址就ok了，其本质上是：append操作亦然会在需要的时候构造新的切片，不过是将地址都保存到了sa中，因此我们通过该指针始终可以访问到真正的数据。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    var osa = make ([]string,0);</span><br><span class=\"line\">    sa:=&amp;osa;</span><br><span class=\"line\">    for i:=0;i&lt;10;i++&#123;</span><br><span class=\"line\">        *sa=append(*sa,fmt.Sprintf(&quot;%v&quot;,i))</span><br><span class=\"line\">        fmt.Printf(&quot;addr of osa:%p,\\taddr:%p \\t content:%v\\n&quot;,osa,sa,sa);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fmt.Printf(&quot;addr of osa:%p,\\taddr:%p \\t content:%v\\n&quot;,osa,sa,sa);</span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">---</span><br><span class=\"line\">Running...</span><br><span class=\"line\"></span><br><span class=\"line\">addr of osa:0xc20800a220,    addr:0xc20801e020      content:&amp;[0]</span><br><span class=\"line\">addr of osa:0xc20801e0a0,    addr:0xc20801e020      content:&amp;[0 1]</span><br><span class=\"line\">addr of osa:0xc20803e0c0,    addr:0xc20801e020      content:&amp;[0 1 2]</span><br><span class=\"line\">addr of osa:0xc20803e0c0,    addr:0xc20801e020      content:&amp;[0 1 2 3]</span><br><span class=\"line\">addr of osa:0xc208050080,    addr:0xc20801e020      content:&amp;[0 1 2 3 4]</span><br><span class=\"line\">addr of osa:0xc208050080,    addr:0xc20801e020      content:&amp;[0 1 2 3 4 5]</span><br><span class=\"line\">addr of osa:0xc208050080,    addr:0xc20801e020      content:&amp;[0 1 2 3 4 5 6]</span><br><span class=\"line\">addr of osa:0xc208050080,    addr:0xc20801e020      content:&amp;[0 1 2 3 4 5 6 7]</span><br><span class=\"line\">addr of osa:0xc208052000,    addr:0xc20801e020      content:&amp;[0 1 2 3 4 5 6 7 8]</span><br><span class=\"line\">addr of osa:0xc208052000,    addr:0xc20801e020      content:&amp;[0 1 2 3 4 5 6 7 8 9]</span><br><span class=\"line\">addr of osa:0xc208052000,    addr:0xc20801e020      content:&amp;[0 1 2 3 4 5 6 7 8 9]</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h1 id=\"一、一般操作\"><a href=\"#一、一般操作\" class=\"headerlink\" title=\"一、一般操作\"></a>一、一般操作</h1><ol>\n<li>声明变量，go自动初始化为nil，长度：0，地址：0，nil</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func main()&#123;</span><br><span class=\"line\">    var ss []string;</span><br><span class=\"line\">    fmt.Printf(&quot;length:%v \\taddr:%p \\tisnil:%v&quot;,len(ss),ss, ss==nil)    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">---</span><br><span class=\"line\">Running...</span><br><span class=\"line\"></span><br><span class=\"line\">length:0     addr:0x0     isnil:true</span><br><span class=\"line\">Success: process exited with code 0.</span><br></pre></td></tr></table></figure>","more":"<ol start=\"2\">\n<li>切片的追加，删除，插入操作</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func main()&#123;</span><br><span class=\"line\">    var ss []string;</span><br><span class=\"line\">    fmt.Printf(&quot;[ local print ]\\t:\\t length:%v\\taddr:%p\\tisnil:%v\\n&quot;,len(ss),ss, ss==nil)    </span><br><span class=\"line\">    print(&quot;func print&quot;,ss)</span><br><span class=\"line\">    //切片尾部追加元素append elemnt</span><br><span class=\"line\">    for i:=0;i&lt;10;i++&#123;</span><br><span class=\"line\">        ss=append(ss,fmt.Sprintf(&quot;s%d&quot;,i));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fmt.Printf(&quot;[ local print ]\\t:\\tlength:%v\\taddr:%p\\tisnil:%v\\n&quot;,len(ss),ss, ss==nil)    </span><br><span class=\"line\">    print(&quot;after append&quot;,ss)</span><br><span class=\"line\">    //删除切片元素remove element at index</span><br><span class=\"line\">    index:=5;</span><br><span class=\"line\">    ss=append(ss[:index],ss[index+1:]...)</span><br><span class=\"line\">    print(&quot;after delete&quot;,ss)</span><br><span class=\"line\">    //在切片中间插入元素insert element at index;</span><br><span class=\"line\">    //注意：保存后部剩余元素，必须新建一个临时切片</span><br><span class=\"line\">    rear:=append([]string&#123;&#125;,ss[index:]...) </span><br><span class=\"line\">    ss=append(ss[0:index],&quot;inserted&quot;)</span><br><span class=\"line\">    ss=append(ss,rear...)</span><br><span class=\"line\">    print(&quot;after insert&quot;,ss)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">func print(msg string,ss []string)&#123;</span><br><span class=\"line\">    fmt.Printf(&quot;[ %20s ]\\t:\\tlength:%v\\taddr:%p\\tisnil:%v\\tcontent:%v&quot;,msg,len(ss),ss, ss==nil,ss)    </span><br><span class=\"line\">    fmt.Println()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">------</span><br><span class=\"line\">Running...</span><br><span class=\"line\"></span><br><span class=\"line\">[ local print ]    :     length:0    addr:0x0    isnil:true</span><br><span class=\"line\">[           func print ]    :    length:0    addr:0x0    isnil:true    content:[]</span><br><span class=\"line\">[ local print ]    :    length:10    addr:0xc208056000    isnil:false</span><br><span class=\"line\">[         after append ]    :    length:10    addr:0xc208056000    isnil:false    content:[s0 s1 s2 s3 s4 s5 s6 s7 s8 s9]</span><br><span class=\"line\">[         after delete ]    :    length:9    addr:0xc208056000    isnil:false    content:[s0 s1 s2 s3 s4 s6 s7 s8 s9]</span><br><span class=\"line\">[         after insert ]    :    length:10    addr:0xc208056000    isnil:false    content:[s0 s1 s2 s3 s4 inserted s6 s7 s8 s9]</span><br><span class=\"line\"></span><br><span class=\"line\">Success: process exited with code 0.</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>copy的使用</li>\n</ol>\n<p>在使用copy复制切片之前，要保证目标切片有足够的大小，注意是大小，而不是容量，还是看例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    var sa = make ([]string,0);</span><br><span class=\"line\">    for i:=0;i&lt;10;i++&#123;</span><br><span class=\"line\">        sa=append(sa,fmt.Sprintf(&quot;%v&quot;,i))</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var da =make([]string,0,10);</span><br><span class=\"line\">    var cc=0;</span><br><span class=\"line\">    cc= copy(da,sa);</span><br><span class=\"line\">    fmt.Printf(&quot;copy to da(len=%d)\\t%v\\n&quot;,len(da),da)</span><br><span class=\"line\">    da = make([]string,5)</span><br><span class=\"line\">    cc=copy(da,sa);</span><br><span class=\"line\">    fmt.Printf(&quot;copy to da(len=%d)\\tcopied=%d\\t%v\\n&quot;,len(da),cc,da)</span><br><span class=\"line\">     da = make([]string,10)</span><br><span class=\"line\">    cc =copy(da,sa);</span><br><span class=\"line\">    fmt.Printf(&quot;copy to da(len=%d)\\tcopied=%d\\t%v\\n&quot;,len(da),cc,da)</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">---</span><br><span class=\"line\">Running...</span><br><span class=\"line\"></span><br><span class=\"line\">copy to da(len=0)    []</span><br><span class=\"line\">copy to da(len=5)    copied=5    [0 1 2 3 4]</span><br><span class=\"line\">copy to da(len=10)    copied=10    [0 1 2 3 4 5 6 7 8 9]</span><br></pre></td></tr></table></figure>\n<p>从上面运行结果，明显看出，目标切片大小0，容量10，copy不能复制。目标切片大小小于源切片大小，copy就按照目标切片大小复制，不会报错。</p>\n<h1 id=\"二、初始大小和容量\"><a href=\"#二、初始大小和容量\" class=\"headerlink\" title=\"二、初始大小和容量\"></a>二、初始大小和容量</h1><p>当我们使用make初始化切片的时候，必须给出size。go语言的书上一般都会告诉我们，当切片有足够大小的时候，append操作是非常快的。但是当给出初始大小后，我们得到的实际上是一个含有这个size数量切片类型的空元素，看例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func main()&#123;</span><br><span class=\"line\">    var ss=make([]string,10);</span><br><span class=\"line\">    ss=append(ss,&quot;last&quot;);</span><br><span class=\"line\">    print(&quot;after append&quot;,ss)</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">---</span><br><span class=\"line\">Running...</span><br><span class=\"line\"></span><br><span class=\"line\">[         after append ]    :    length:11    addr:0xc20804c000    isnil:false    content:[          last]</span><br></pre></td></tr></table></figure>\n<p>实际上，此时我们应该先用下标为切片元素负值。但是如果我们既想有好的效率，有想继续使用append函数而不想区分是否有空的元素，此时就要请出make的第三个参数，容量，也就是我们通过传递给make，0的大小和足够大的容量数值就行了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func main()&#123;</span><br><span class=\"line\">    var ss=make([]string,0,10);</span><br><span class=\"line\">    ss=append(ss,&quot;last&quot;);</span><br><span class=\"line\">    print(&quot;after append&quot;,ss)</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">---</span><br><span class=\"line\">Running...</span><br><span class=\"line\"></span><br><span class=\"line\">[         after append ]    :    length:1    addr:0xc20804a000    isnil:false    content:[last]</span><br></pre></td></tr></table></figure>\n<h1 id=\"三、切片的指针\"><a href=\"#三、切片的指针\" class=\"headerlink\" title=\"三、切片的指针\"></a>三、切片的指针</h1><ol>\n<li>当我们用append追加元素到切片时，如果容量不够，go就会创建一个新的切片变量，看下面程序的执行结果：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    var sa []string</span><br><span class=\"line\">fmt.Printf(&quot;addr:%p \\t\\tlen:%v content:%v\\n&quot;,sa,len(sa),sa);</span><br><span class=\"line\">    for i:=0;i&lt;10;i++&#123;</span><br><span class=\"line\">        sa=append(sa,fmt.Sprintf(&quot;%v&quot;,i))</span><br><span class=\"line\">        fmt.Printf(&quot;addr:%p \\t\\tlen:%v content:%v\\n&quot;,sa,len(sa),sa);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fmt.Printf(&quot;addr:%p \\t\\tlen:%v content:%v\\n&quot;,sa,len(sa),sa);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">---</span><br><span class=\"line\">Running ...</span><br><span class=\"line\">addr:0x0         len:0 content:[]</span><br><span class=\"line\">addr:0x1030e0c8         len:1 content:[0]</span><br><span class=\"line\">addr:0x10328120         len:2 content:[0 1]</span><br><span class=\"line\">addr:0x10322180         len:3 content:[0 1 2]</span><br><span class=\"line\">addr:0x10322180         len:4 content:[0 1 2 3]</span><br><span class=\"line\">addr:0x10342080         len:5 content:[0 1 2 3 4]</span><br><span class=\"line\">addr:0x10342080         len:6 content:[0 1 2 3 4 5]</span><br><span class=\"line\">addr:0x10342080         len:7 content:[0 1 2 3 4 5 6]</span><br><span class=\"line\">addr:0x10342080         len:8 content:[0 1 2 3 4 5 6 7]</span><br><span class=\"line\">addr:0x10324a00         len:9 content:[0 1 2 3 4 5 6 7 8]</span><br><span class=\"line\">addr:0x10324a00         len:10 content:[0 1 2 3 4 5 6 7 8 9]</span><br><span class=\"line\">addr:0x10324a00         len:10 content:[0 1 2 3 4 5 6 7 8 9]</span><br><span class=\"line\"></span><br><span class=\"line\">//很明显，切片的地址经过了数次改变。</span><br></pre></td></tr></table></figure>\n<p>2.如果，在make初始化切片的时候给出了足够的容量，append操作不会创建新的切片：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    var sa = make ([]string,0,10);</span><br><span class=\"line\">fmt.Printf(&quot;addr:%p \\t\\tlen:%v content:%v\\n&quot;,sa,len(sa),sa);</span><br><span class=\"line\">    for i:=0;i&lt;10;i++&#123;</span><br><span class=\"line\">        sa=append(sa,fmt.Sprintf(&quot;%v&quot;,i))</span><br><span class=\"line\">        fmt.Printf(&quot;addr:%p \\t\\tlen:%v content:%v\\n&quot;,sa,len(sa),sa);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fmt.Printf(&quot;addr:%p \\t\\tlen:%v content:%v\\n&quot;,sa,len(sa),sa);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">addr:0x10304140         len:0 content:[]</span><br><span class=\"line\">addr:0x10304140         len:1 content:[0]</span><br><span class=\"line\">addr:0x10304140         len:2 content:[0 1]</span><br><span class=\"line\">addr:0x10304140         len:3 content:[0 1 2]</span><br><span class=\"line\">addr:0x10304140         len:4 content:[0 1 2 3]</span><br><span class=\"line\">addr:0x10304140         len:5 content:[0 1 2 3 4]</span><br><span class=\"line\">addr:0x10304140         len:6 content:[0 1 2 3 4 5]</span><br><span class=\"line\">addr:0x10304140         len:7 content:[0 1 2 3 4 5 6]</span><br><span class=\"line\">addr:0x10304140         len:8 content:[0 1 2 3 4 5 6 7]</span><br><span class=\"line\">addr:0x10304140         len:9 content:[0 1 2 3 4 5 6 7 8]</span><br><span class=\"line\">addr:0x10304140         len:10 content:[0 1 2 3 4 5 6 7 8 9]</span><br><span class=\"line\">addr:0x10304140         len:10 content:[0 1 2 3 4 5 6 7 8 9]</span><br><span class=\"line\"></span><br><span class=\"line\">//可见，切片的地址一直保持不变</span><br></pre></td></tr></table></figure>\n<p>3.如果不能准确预估切片的大小，又不想改变变量（如：为了共享数据的改变），这时候就要请出指针来帮忙了，下面程序中，sa就是osa这个切片的指针，我们共享切片数据和操作切片的时候都使用这个切片地址就ok了，其本质上是：append操作亦然会在需要的时候构造新的切片，不过是将地址都保存到了sa中，因此我们通过该指针始终可以访问到真正的数据。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    var osa = make ([]string,0);</span><br><span class=\"line\">    sa:=&amp;osa;</span><br><span class=\"line\">    for i:=0;i&lt;10;i++&#123;</span><br><span class=\"line\">        *sa=append(*sa,fmt.Sprintf(&quot;%v&quot;,i))</span><br><span class=\"line\">        fmt.Printf(&quot;addr of osa:%p,\\taddr:%p \\t content:%v\\n&quot;,osa,sa,sa);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fmt.Printf(&quot;addr of osa:%p,\\taddr:%p \\t content:%v\\n&quot;,osa,sa,sa);</span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">---</span><br><span class=\"line\">Running...</span><br><span class=\"line\"></span><br><span class=\"line\">addr of osa:0xc20800a220,    addr:0xc20801e020      content:&amp;[0]</span><br><span class=\"line\">addr of osa:0xc20801e0a0,    addr:0xc20801e020      content:&amp;[0 1]</span><br><span class=\"line\">addr of osa:0xc20803e0c0,    addr:0xc20801e020      content:&amp;[0 1 2]</span><br><span class=\"line\">addr of osa:0xc20803e0c0,    addr:0xc20801e020      content:&amp;[0 1 2 3]</span><br><span class=\"line\">addr of osa:0xc208050080,    addr:0xc20801e020      content:&amp;[0 1 2 3 4]</span><br><span class=\"line\">addr of osa:0xc208050080,    addr:0xc20801e020      content:&amp;[0 1 2 3 4 5]</span><br><span class=\"line\">addr of osa:0xc208050080,    addr:0xc20801e020      content:&amp;[0 1 2 3 4 5 6]</span><br><span class=\"line\">addr of osa:0xc208050080,    addr:0xc20801e020      content:&amp;[0 1 2 3 4 5 6 7]</span><br><span class=\"line\">addr of osa:0xc208052000,    addr:0xc20801e020      content:&amp;[0 1 2 3 4 5 6 7 8]</span><br><span class=\"line\">addr of osa:0xc208052000,    addr:0xc20801e020      content:&amp;[0 1 2 3 4 5 6 7 8 9]</span><br><span class=\"line\">addr of osa:0xc208052000,    addr:0xc20801e020      content:&amp;[0 1 2 3 4 5 6 7 8 9]</span><br></pre></td></tr></table></figure>"},{"title":"Golang的调度模型概览","date":"2018-08-03T01:38:06.000Z","_content":"\n调度的机制用一句话描述：  \nruntime准备好G,P,M，然后M绑定P，M从各种队列中获取G，切换到G的执行栈上并执行G上的任务函数，调用goexit做清理工作并回到M，如此反复。\n\n### 基本概念\n#### M（machine）\n* M代表着真正的执行计算资源，可以认为它就是os thread（系统线程）。\n* M是真正调度系统的执行者，每个M就像一个勤劳的工作者，总是从各种队列中找到可运行的G，而且这样M的可以同时存在多个。\n* M在绑定有效的P后，进入调度循环，而且M并不保留G状态，这是G可以跨M调度的基础。\n\n<!-- more -->\n\n#### P（processor）\n* P表示逻辑processor，是线程M的执行的上下文。\n* P的最大作用是其拥有的各种G对象队列、链表、cache和状态。\n\n#### G（goroutine）\n* 调度系统的最基本单位goroutine，存储了goroutine的执行stack信息、goroutine状态以及goroutine的任务函数等。\n* 在G的眼中只有P，P就是运行G的“CPU”。\n* 相当于两级线程\n\n#### 线程实现模型\n来自`Go并发编程实战`\n```\n                    +-------+       +-------+      \n                    |  KSE  |       |  KSE  |          \n                    +-------+       +-------+      \n                        |               |                       内核空间\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -        \n                        |               |                       用户空间\n                    +-------+       +-------+\n                    |   M   |       |   M   |\n                    +-------+       +-------+\n                  |          |         |          |\n              +------+   +------+   +------+   +------+            \n              |   P  |   |   P  |   |   P  |   |   P  |\n              +------+   +------+   +------+   +------+   \n           |     |     |     |     |     |     |     |     | \n         +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ \n         | G | | G | | G | | G | | G | | G | | G | | G | | G | \n         +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ \n```\n* KSE（Kernel Scheduling Entity）是内核调度实体           \n* M与P，P与G之前的关联都是动态的，可以变的\n\n### 关系示意图\n来自`golang源码剖析`\n```\n                            +-------------------- sysmon ---------------//------+ \n                            |                                                   |\n                            |                                                   |\n               +---+      +---+-------+                   +--------+          +---+---+\ngo func() ---> | G | ---> | P | local | <=== balance ===> | global | <--//--- | P | M |\n               +---+      +---+-------+                   +--------+          +---+---+\n                            |                                 |                 | \n                            |      +---+                      |                 |\n                            +----> | M | <--- findrunnable ---+--- steal <--//--+\n                                   +---+ \n                                     |\n                                   mstart\n                                     |\n              +--- execute <----- schedule \n              |                      |   \n              |                      |\n              +--> G.fn --> goexit --+ \n\n\n              1. go func() 语气创建G。\n              2. 将G放入P的本地队列（或者平衡到全局全局队列）。\n              3. 唤醒或新建M来执行任务。\n              4. 进入调度循环\n              5. 尽力获取可执行的G，并执行\n              6. 清理现场并且重新进入调度循环\n\n```\n\n\n## GPM的来由\n### 特殊的g0和m0\ng0和m0是在`proc.go`文件中的两个全局变量，m0就是进程启动后的初始线程，g0也是代表着初始线程的stack  \n`asm_amd64.go` --> runtime·rt0_go(SB)\n```go \n\t// 程序刚启动的时候必定有一个线程启动（主线程）\n\t// 将当前的栈和资源保存在g0\n\t// 将该线程保存在m0\n\t// tls: Thread Local Storage\n\t// set the per-goroutine and per-mach \"registers\"\n\tget_tls(BX)\n\tLEAQ\truntime·g0(SB), CX\n\tMOVQ\tCX, g(BX)\n\tLEAQ\truntime·m0(SB), AX\n\n\t// save m->g0 = g0\n\tMOVQ\tCX, m_g0(AX)\n\t// save m0 to g0->m\n\tMOVQ\tAX, g_m(CX)\n```\n\n\n\n### M的一生\n#### M的创建\n`proc.go`\n```go\n// Create a new m. It will start off with a call to fn, or else the scheduler.\n// fn needs to be static and not a heap allocated closure.\n// May run with m.p==nil, so write barriers are not allowed.\n//go:nowritebarrierrec\n// 创建一个新的m，它将从fn或者调度程序开始\nfunc newm(fn func(), _p_ *p) {\n\t// 根据fn和p和绑定一个m对象\n\tmp := allocm(_p_, fn)\n\t// 设置当前m的下一个p为_p_\n\tmp.nextp.set(_p_)\n\tmp.sigmask = initSigmask\n\t...\n\t// 真正的分配os thread\n\tnewm1(mp)\n}\n```\n\n```go\nfunc newm1(mp *m) {\n\t// 对cgo的处理\n\t...\n\texecLock.rlock() // Prevent process clone.\n\t// 创建一个系统线程\n\tnewosproc(mp, unsafe.Pointer(mp.g0.stack.hi))\n\texecLock.runlock()\n}\n```\n#### 状态\n``` \n       mstart\n          |\n          v        找不到可执行任务，gc STW，\n      +------+     任务执行时间过长，系统阻塞等   +------+\n      | spin | ----------------------------> |unspin| \n      +------+          mstop                +------+\n          ^                                      |\n          |                                      v\n      notewakeup <-------------------------  notesleep\n```\n\n#### M的一些问题\nhttps://github.com/golang/go/issues/14592\n\n### P的一生\n#### P的创建\n`proc.go`\n```go\n// Change number of processors. The world is stopped, sched is locked.\n// gcworkbufs are not being modified by either the GC or\n// the write barrier code.\n// Returns list of Ps with local work, they need to be scheduled by the caller.\n// 所有的P都在这个函数分配，不管是最开始的初始化分配，还是后期调整\nfunc procresize(nprocs int32) *p {\n\told := gomaxprocs\n\t// 如果 gomaxprocs <=0 抛出异常\n\tif old < 0 || nprocs <= 0 {\n\t\tthrow(\"procresize: invalid arg\")\n\t}\n  ...\n\t// Grow allp if necessary.\n\tif nprocs > int32(len(allp)) {\n\t\t// Synchronize with retake, which could be running\n\t\t// concurrently since it doesn't run on a P.\n\t\tlock(&allpLock)\n\t\tif nprocs <= int32(cap(allp)) {\n\t\t\tallp = allp[:nprocs]\n\t\t} else {\n\t\t\t// 分配nprocs个*p\n\t\t\tnallp := make([]*p, nprocs)\n\t\t\t// Copy everything up to allp's cap so we\n\t\t\t// never lose old allocated Ps.\n\t\t\tcopy(nallp, allp[:cap(allp)])\n\t\t\tallp = nallp\n\t\t}\n\t\tunlock(&allpLock)\n\t}\n\n\t// initialize new P's\n\tfor i := int32(0); i < nprocs; i++ {\n\t\tpp := allp[i]\n\t\tif pp == nil {\n\t\t\tpp = new(p)\n\t\t\tpp.id = i\n\t\t\tpp.status = _Pgcstop            // 更改状态\n\t\t\tpp.sudogcache = pp.sudogbuf[:0] //将sudogcache指向sudogbuf的起始地址\n\t\t\tfor i := range pp.deferpool {\n\t\t\t\tpp.deferpool[i] = pp.deferpoolbuf[i][:0]\n\t\t\t}\n\t\t\tpp.wbBuf.reset()\n\t\t\t// 将pp保存到allp数组里, allp[i] = pp\n\t\t\tatomicstorep(unsafe.Pointer(&allp[i]), unsafe.Pointer(pp))\n\t\t}\n\t\t...\n\t}\n  ...\n\n\t_g_ := getg()\n\t// 如果当前的M已经绑定P，继续使用，否则将当前的M绑定一个P\n\tif _g_.m.p != 0 && _g_.m.p.ptr().id < nprocs {\n\t\t// continue to use the current P\n\t\t_g_.m.p.ptr().status = _Prunning\n\t} else {\n\t\t// release the current P and acquire allp[0]\n\t\t// 获取allp[0]\n\t\tif _g_.m.p != 0 {\n\t\t\t_g_.m.p.ptr().m = 0\n\t\t}\n\t\t_g_.m.p = 0\n\t\t_g_.m.mcache = nil\n\t\tp := allp[0]\n\t\tp.m = 0\n\t\tp.status = _Pidle\n\t\t// 将当前的m和p绑定\n\t\tacquirep(p)\n\t\tif trace.enabled {\n\t\t\ttraceGoStart()\n\t\t}\n\t}\n\tvar runnablePs *p\n\tfor i := nprocs - 1; i >= 0; i-- {\n\t\tp := allp[i]\n\t\tif _g_.m.p.ptr() == p {\n\t\t\tcontinue\n\t\t}\n\t\tp.status = _Pidle\n\t\tif runqempty(p) { // 将空闲p放入空闲链表\n\t\t\tpidleput(p)\n\t\t} else {\n\t\t\tp.m.set(mget())\n\t\t\tp.link.set(runnablePs)\n\t\t\trunnablePs = p\n\t\t}\n\t}\n\tstealOrder.reset(uint32(nprocs))\n\tvar int32p *int32 = &gomaxprocs // make compiler check that gomaxprocs is an int32\n\tatomic.Store((*uint32)(unsafe.Pointer(int32p)), uint32(nprocs))\n\treturn runnablePs\n}\n```\n所有的P在程序启动的时候就设置好了，并用一个allp slice维护，可以调用runtime.GOMAXPROCS调整P的个数，虽然代价很大\n#### 状态转换\n```\n                                            acquirep(p)        \n                          不需要使用的P       P和M绑定的时候       进入系统调用       procresize()\nnew(p)  -----+        +---------------+     +-----------+     +------------+    +----------+\n            |         |               |     |           |     |            |    |          |\n            |   +------------+    +---v--------+    +---v--------+    +----v-------+    +--v---------+\n            +-->|  _Pgcstop  |    |    _Pidle  |    |  _Prunning |    |  _Psyscall |    |   _Pdead   |\n                +------^-----+    +--------^---+    +--------^---+    +------------+    +------------+\n                       |            |     |            |     |            |\n                       +------------+     +------------+     +------------+\n                           GC结束            releasep()        退出系统调用\n                                            P和M解绑                      \n``` \nP的数量默认等于cpu的个数，很多人认为runtime.GOMAXPROCS可以限制系统线程的数量，但这是错误的，M是按需创建的，和runtime.GOMAXPROCS没有关系。\n### G的一生\n\n#### G的创建\n`proc.go`\n```go\n// Create a new g running fn with siz bytes of arguments.\n// Put it on the queue of g's waiting to run.\n// The compiler turns a go statement into a call to this.\n// Cannot split the stack because it assumes that the arguments\n// are available sequentially after &fn; they would not be\n// copied if a stack split occurred.\n//go:nosplit\n// 新建一个goroutine，\n// 􏳄 用fn + PtrSize 获取第一个参数的地址，也就是argp\n// 用siz - 8 获取pc地址\nfunc newproc(siz int32, fn *funcval) {\n\targp := add(unsafe.Pointer(&fn), sys.PtrSize)\n\tpc := getcallerpc()\n\t// 用g0的栈创建G对象\n\tsystemstack(func() {\n\t\tnewproc1(fn, (*uint8)(argp), siz, pc)\n\t})\n}\n```\n\n```go\n// Create a new g running fn with narg bytes of arguments starting\n// at argp. callerpc is the address of the go statement that created\n// this. The new g is put on the queue of g's waiting to run.\n// 根据函数参数和函数地址，创建一个新的G，然后将这个G加入队列等待运行\nfunc newproc1(fn *funcval, argp *uint8, narg int32, callerpc uintptr) {\n\t_g_ := getg()\n\n\tif fn == nil {\n\t\t_g_.m.throwing = -1 // do not dump full stacks\n\t\tthrow(\"go of nil func value\")\n\t}\n\t_g_.m.locks++ // disable preemption because it can be holding p in a local var\n\tsiz := narg\n\tsiz = (siz + 7) &^ 7\n\n\t// We could allocate a larger initial stack if necessary.\n\t// Not worth it: this is almost always an error.\n\t// 4*sizeof(uintreg): extra space added below\n\t// sizeof(uintreg): caller's LR (arm) or return address (x86, in gostartcall).\n\t// 如果函数的参数大小比2048大的话，直接panic\n\tif siz >= _StackMin-4*sys.RegSize-sys.RegSize {\n\t\tthrow(\"newproc: function arguments too large for new goroutine\")\n\t}\n\n\t// 从m中获取p\n\t_p_ := _g_.m.p.ptr()\n\t// 从gfree list获取g\n\tnewg := gfget(_p_)\n\t// 如果没获取到g，则新建一个\n\tif newg == nil {\n\t\tnewg = malg(_StackMin)\n\t\tcasgstatus(newg, _Gidle, _Gdead) //将g的状态改为_Gdead\n\t\t// 添加到allg数组，防止gc扫描清除掉\n\t\tallgadd(newg) // publishes with a g->status of Gdead so GC scanner doesn't look at uninitialized stack.\n\t}\n\tif newg.stack.hi == 0 {\n\t\tthrow(\"newproc1: newg missing stack\")\n\t}\n\n\tif readgstatus(newg) != _Gdead {\n\t\tthrow(\"newproc1: new g is not Gdead\")\n\t}\n\n\ttotalSize := 4*sys.RegSize + uintptr(siz) + sys.MinFrameSize // extra space in case of reads slightly beyond frame\n\ttotalSize += -totalSize & (sys.SpAlign - 1)                  // align to spAlign\n\tsp := newg.stack.hi - totalSize\n\tspArg := sp\n\tif usesLR {\n\t\t// caller's LR\n\t\t*(*uintptr)(unsafe.Pointer(sp)) = 0\n\t\tprepGoExitFrame(sp)\n\t\tspArg += sys.MinFrameSize\n\t}\n\tif narg > 0 {\n\t\t// copy参数\n\t\tmemmove(unsafe.Pointer(spArg), unsafe.Pointer(argp), uintptr(narg))\n\t\t// This is a stack-to-stack copy. If write barriers\n\t\t// are enabled and the source stack is grey (the\n\t\t// destination is always black), then perform a\n\t\t// barrier copy. We do this *after* the memmove\n\t\t// because the destination stack may have garbage on\n\t\t// it.\n\t\tif writeBarrier.needed && !_g_.m.curg.gcscandone {\n\t\t\tf := findfunc(fn.fn)\n\t\t\tstkmap := (*stackmap)(funcdata(f, _FUNCDATA_ArgsPointerMaps))\n\t\t\t// We're in the prologue, so it's always stack map index 0.\n\t\t\tbv := stackmapdata(stkmap, 0)\n\t\t\tbulkBarrierBitmap(spArg, spArg, uintptr(narg), 0, bv.bytedata)\n\t\t}\n\t}\n\n\tmemclrNoHeapPointers(unsafe.Pointer(&newg.sched), unsafe.Sizeof(newg.sched))\n\tnewg.sched.sp = sp\n\tnewg.stktopsp = sp\n\t// 保存goexit的地址到sched.pc\n\tnewg.sched.pc = funcPC(goexit) + sys.PCQuantum // +PCQuantum so that previous instruction is in same function\n\tnewg.sched.g = guintptr(unsafe.Pointer(newg))\n\tgostartcallfn(&newg.sched, fn)\n\tnewg.gopc = callerpc\n\tnewg.startpc = fn.fn\n\tif _g_.m.curg != nil {\n\t\tnewg.labels = _g_.m.curg.labels\n\t}\n\tif isSystemGoroutine(newg) {\n\t\tatomic.Xadd(&sched.ngsys, +1)\n\t}\n\tnewg.gcscanvalid = false\n\t// 更改当前g的状态为_Grunnable\n\tcasgstatus(newg, _Gdead, _Grunnable)\n\n\tif _p_.goidcache == _p_.goidcacheend {\n\t\t// Sched.goidgen is the last allocated id,\n\t\t// this batch must be [sched.goidgen+1, sched.goidgen+GoidCacheBatch].\n\t\t// At startup sched.goidgen=0, so main goroutine receives goid=1.\n\t\t_p_.goidcache = atomic.Xadd64(&sched.goidgen, _GoidCacheBatch)\n\t\t_p_.goidcache -= _GoidCacheBatch - 1\n\t\t_p_.goidcacheend = _p_.goidcache + _GoidCacheBatch\n\t}\n\t// 生成唯一的goid\n\tnewg.goid = int64(_p_.goidcache)\n\t_p_.goidcache++\n\tif raceenabled {\n\t\tnewg.racectx = racegostart(callerpc)\n\t}\n\tif trace.enabled {\n\t\ttraceGoCreate(newg, newg.startpc)\n\t}\n\t// 将当前新生成的g，放入队列\n\trunqput(_p_, newg, true)\n\n\t// 如果有空闲的p 且 m没有处于自旋状态 且 main goroutine已经启动，那么唤醒某个m来执行任务\n\tif atomic.Load(&sched.npidle) != 0 && atomic.Load(&sched.nmspinning) == 0 && mainStarted {\n\t\twakep()\n\t}\n\t_g_.m.locks--\n\tif _g_.m.locks == 0 && _g_.preempt { // restore the preemption request in case we've cleared it in newstack\n\t\t_g_.stackguard0 = stackPreempt\n\t}\n}\n```\n\n#### G的状态图\n```\n                                                      +------------+\n                                      ready           |            |\n                                  +------------------ |  _Gwaiting |\n                                  |                   |            |\n                                  |                   +------------+\n                                  |                         ^ park_m\n                                  V                         | \n  +------------+            +------------+  execute   +------------+            +------------+    \n  |            |  newproc   |            | ---------> |            |   goexit   |            |\n  |  _Gidle    | ---------> | _Grunnable |  yield     | _Grunning  | ---------> |   _Gdead   |      \n  |            |            |            | <--------- |            |            |            |\n  +------------+            +-----^------+            +------------+            +------------+\n                                  |         entersyscall |      ^ \n                                  |                      V      | existsyscall\n                                  |                   +------------+\n                                  |   existsyscall    |            |\n                                  +------------------ |  _Gsyscall |\n                                                      |            |\n                                                      +------------+\n\n```\n新建的G都是_Grunnable的，新建G的时候优先从gfree list从获取G，这样可以复用G，所以上图的状态不是完整的，_Gdead通过newproc会变为_Grunnable，\n通过go func()的语法新建的G，并不是直接运行，而是放入可运行的队列中，什么时候运行用于并不能决定，而是搞调度系统去自发的运行。\n\n\n","source":"_posts/Golang的调度模型概览.md","raw":"---\ntitle: Golang的调度模型概览\ndate: 2018-8-3 09:38:06\ntags: Go\n---\n\n调度的机制用一句话描述：  \nruntime准备好G,P,M，然后M绑定P，M从各种队列中获取G，切换到G的执行栈上并执行G上的任务函数，调用goexit做清理工作并回到M，如此反复。\n\n### 基本概念\n#### M（machine）\n* M代表着真正的执行计算资源，可以认为它就是os thread（系统线程）。\n* M是真正调度系统的执行者，每个M就像一个勤劳的工作者，总是从各种队列中找到可运行的G，而且这样M的可以同时存在多个。\n* M在绑定有效的P后，进入调度循环，而且M并不保留G状态，这是G可以跨M调度的基础。\n\n<!-- more -->\n\n#### P（processor）\n* P表示逻辑processor，是线程M的执行的上下文。\n* P的最大作用是其拥有的各种G对象队列、链表、cache和状态。\n\n#### G（goroutine）\n* 调度系统的最基本单位goroutine，存储了goroutine的执行stack信息、goroutine状态以及goroutine的任务函数等。\n* 在G的眼中只有P，P就是运行G的“CPU”。\n* 相当于两级线程\n\n#### 线程实现模型\n来自`Go并发编程实战`\n```\n                    +-------+       +-------+      \n                    |  KSE  |       |  KSE  |          \n                    +-------+       +-------+      \n                        |               |                       内核空间\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -        \n                        |               |                       用户空间\n                    +-------+       +-------+\n                    |   M   |       |   M   |\n                    +-------+       +-------+\n                  |          |         |          |\n              +------+   +------+   +------+   +------+            \n              |   P  |   |   P  |   |   P  |   |   P  |\n              +------+   +------+   +------+   +------+   \n           |     |     |     |     |     |     |     |     | \n         +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ \n         | G | | G | | G | | G | | G | | G | | G | | G | | G | \n         +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ \n```\n* KSE（Kernel Scheduling Entity）是内核调度实体           \n* M与P，P与G之前的关联都是动态的，可以变的\n\n### 关系示意图\n来自`golang源码剖析`\n```\n                            +-------------------- sysmon ---------------//------+ \n                            |                                                   |\n                            |                                                   |\n               +---+      +---+-------+                   +--------+          +---+---+\ngo func() ---> | G | ---> | P | local | <=== balance ===> | global | <--//--- | P | M |\n               +---+      +---+-------+                   +--------+          +---+---+\n                            |                                 |                 | \n                            |      +---+                      |                 |\n                            +----> | M | <--- findrunnable ---+--- steal <--//--+\n                                   +---+ \n                                     |\n                                   mstart\n                                     |\n              +--- execute <----- schedule \n              |                      |   \n              |                      |\n              +--> G.fn --> goexit --+ \n\n\n              1. go func() 语气创建G。\n              2. 将G放入P的本地队列（或者平衡到全局全局队列）。\n              3. 唤醒或新建M来执行任务。\n              4. 进入调度循环\n              5. 尽力获取可执行的G，并执行\n              6. 清理现场并且重新进入调度循环\n\n```\n\n\n## GPM的来由\n### 特殊的g0和m0\ng0和m0是在`proc.go`文件中的两个全局变量，m0就是进程启动后的初始线程，g0也是代表着初始线程的stack  \n`asm_amd64.go` --> runtime·rt0_go(SB)\n```go \n\t// 程序刚启动的时候必定有一个线程启动（主线程）\n\t// 将当前的栈和资源保存在g0\n\t// 将该线程保存在m0\n\t// tls: Thread Local Storage\n\t// set the per-goroutine and per-mach \"registers\"\n\tget_tls(BX)\n\tLEAQ\truntime·g0(SB), CX\n\tMOVQ\tCX, g(BX)\n\tLEAQ\truntime·m0(SB), AX\n\n\t// save m->g0 = g0\n\tMOVQ\tCX, m_g0(AX)\n\t// save m0 to g0->m\n\tMOVQ\tAX, g_m(CX)\n```\n\n\n\n### M的一生\n#### M的创建\n`proc.go`\n```go\n// Create a new m. It will start off with a call to fn, or else the scheduler.\n// fn needs to be static and not a heap allocated closure.\n// May run with m.p==nil, so write barriers are not allowed.\n//go:nowritebarrierrec\n// 创建一个新的m，它将从fn或者调度程序开始\nfunc newm(fn func(), _p_ *p) {\n\t// 根据fn和p和绑定一个m对象\n\tmp := allocm(_p_, fn)\n\t// 设置当前m的下一个p为_p_\n\tmp.nextp.set(_p_)\n\tmp.sigmask = initSigmask\n\t...\n\t// 真正的分配os thread\n\tnewm1(mp)\n}\n```\n\n```go\nfunc newm1(mp *m) {\n\t// 对cgo的处理\n\t...\n\texecLock.rlock() // Prevent process clone.\n\t// 创建一个系统线程\n\tnewosproc(mp, unsafe.Pointer(mp.g0.stack.hi))\n\texecLock.runlock()\n}\n```\n#### 状态\n``` \n       mstart\n          |\n          v        找不到可执行任务，gc STW，\n      +------+     任务执行时间过长，系统阻塞等   +------+\n      | spin | ----------------------------> |unspin| \n      +------+          mstop                +------+\n          ^                                      |\n          |                                      v\n      notewakeup <-------------------------  notesleep\n```\n\n#### M的一些问题\nhttps://github.com/golang/go/issues/14592\n\n### P的一生\n#### P的创建\n`proc.go`\n```go\n// Change number of processors. The world is stopped, sched is locked.\n// gcworkbufs are not being modified by either the GC or\n// the write barrier code.\n// Returns list of Ps with local work, they need to be scheduled by the caller.\n// 所有的P都在这个函数分配，不管是最开始的初始化分配，还是后期调整\nfunc procresize(nprocs int32) *p {\n\told := gomaxprocs\n\t// 如果 gomaxprocs <=0 抛出异常\n\tif old < 0 || nprocs <= 0 {\n\t\tthrow(\"procresize: invalid arg\")\n\t}\n  ...\n\t// Grow allp if necessary.\n\tif nprocs > int32(len(allp)) {\n\t\t// Synchronize with retake, which could be running\n\t\t// concurrently since it doesn't run on a P.\n\t\tlock(&allpLock)\n\t\tif nprocs <= int32(cap(allp)) {\n\t\t\tallp = allp[:nprocs]\n\t\t} else {\n\t\t\t// 分配nprocs个*p\n\t\t\tnallp := make([]*p, nprocs)\n\t\t\t// Copy everything up to allp's cap so we\n\t\t\t// never lose old allocated Ps.\n\t\t\tcopy(nallp, allp[:cap(allp)])\n\t\t\tallp = nallp\n\t\t}\n\t\tunlock(&allpLock)\n\t}\n\n\t// initialize new P's\n\tfor i := int32(0); i < nprocs; i++ {\n\t\tpp := allp[i]\n\t\tif pp == nil {\n\t\t\tpp = new(p)\n\t\t\tpp.id = i\n\t\t\tpp.status = _Pgcstop            // 更改状态\n\t\t\tpp.sudogcache = pp.sudogbuf[:0] //将sudogcache指向sudogbuf的起始地址\n\t\t\tfor i := range pp.deferpool {\n\t\t\t\tpp.deferpool[i] = pp.deferpoolbuf[i][:0]\n\t\t\t}\n\t\t\tpp.wbBuf.reset()\n\t\t\t// 将pp保存到allp数组里, allp[i] = pp\n\t\t\tatomicstorep(unsafe.Pointer(&allp[i]), unsafe.Pointer(pp))\n\t\t}\n\t\t...\n\t}\n  ...\n\n\t_g_ := getg()\n\t// 如果当前的M已经绑定P，继续使用，否则将当前的M绑定一个P\n\tif _g_.m.p != 0 && _g_.m.p.ptr().id < nprocs {\n\t\t// continue to use the current P\n\t\t_g_.m.p.ptr().status = _Prunning\n\t} else {\n\t\t// release the current P and acquire allp[0]\n\t\t// 获取allp[0]\n\t\tif _g_.m.p != 0 {\n\t\t\t_g_.m.p.ptr().m = 0\n\t\t}\n\t\t_g_.m.p = 0\n\t\t_g_.m.mcache = nil\n\t\tp := allp[0]\n\t\tp.m = 0\n\t\tp.status = _Pidle\n\t\t// 将当前的m和p绑定\n\t\tacquirep(p)\n\t\tif trace.enabled {\n\t\t\ttraceGoStart()\n\t\t}\n\t}\n\tvar runnablePs *p\n\tfor i := nprocs - 1; i >= 0; i-- {\n\t\tp := allp[i]\n\t\tif _g_.m.p.ptr() == p {\n\t\t\tcontinue\n\t\t}\n\t\tp.status = _Pidle\n\t\tif runqempty(p) { // 将空闲p放入空闲链表\n\t\t\tpidleput(p)\n\t\t} else {\n\t\t\tp.m.set(mget())\n\t\t\tp.link.set(runnablePs)\n\t\t\trunnablePs = p\n\t\t}\n\t}\n\tstealOrder.reset(uint32(nprocs))\n\tvar int32p *int32 = &gomaxprocs // make compiler check that gomaxprocs is an int32\n\tatomic.Store((*uint32)(unsafe.Pointer(int32p)), uint32(nprocs))\n\treturn runnablePs\n}\n```\n所有的P在程序启动的时候就设置好了，并用一个allp slice维护，可以调用runtime.GOMAXPROCS调整P的个数，虽然代价很大\n#### 状态转换\n```\n                                            acquirep(p)        \n                          不需要使用的P       P和M绑定的时候       进入系统调用       procresize()\nnew(p)  -----+        +---------------+     +-----------+     +------------+    +----------+\n            |         |               |     |           |     |            |    |          |\n            |   +------------+    +---v--------+    +---v--------+    +----v-------+    +--v---------+\n            +-->|  _Pgcstop  |    |    _Pidle  |    |  _Prunning |    |  _Psyscall |    |   _Pdead   |\n                +------^-----+    +--------^---+    +--------^---+    +------------+    +------------+\n                       |            |     |            |     |            |\n                       +------------+     +------------+     +------------+\n                           GC结束            releasep()        退出系统调用\n                                            P和M解绑                      \n``` \nP的数量默认等于cpu的个数，很多人认为runtime.GOMAXPROCS可以限制系统线程的数量，但这是错误的，M是按需创建的，和runtime.GOMAXPROCS没有关系。\n### G的一生\n\n#### G的创建\n`proc.go`\n```go\n// Create a new g running fn with siz bytes of arguments.\n// Put it on the queue of g's waiting to run.\n// The compiler turns a go statement into a call to this.\n// Cannot split the stack because it assumes that the arguments\n// are available sequentially after &fn; they would not be\n// copied if a stack split occurred.\n//go:nosplit\n// 新建一个goroutine，\n// 􏳄 用fn + PtrSize 获取第一个参数的地址，也就是argp\n// 用siz - 8 获取pc地址\nfunc newproc(siz int32, fn *funcval) {\n\targp := add(unsafe.Pointer(&fn), sys.PtrSize)\n\tpc := getcallerpc()\n\t// 用g0的栈创建G对象\n\tsystemstack(func() {\n\t\tnewproc1(fn, (*uint8)(argp), siz, pc)\n\t})\n}\n```\n\n```go\n// Create a new g running fn with narg bytes of arguments starting\n// at argp. callerpc is the address of the go statement that created\n// this. The new g is put on the queue of g's waiting to run.\n// 根据函数参数和函数地址，创建一个新的G，然后将这个G加入队列等待运行\nfunc newproc1(fn *funcval, argp *uint8, narg int32, callerpc uintptr) {\n\t_g_ := getg()\n\n\tif fn == nil {\n\t\t_g_.m.throwing = -1 // do not dump full stacks\n\t\tthrow(\"go of nil func value\")\n\t}\n\t_g_.m.locks++ // disable preemption because it can be holding p in a local var\n\tsiz := narg\n\tsiz = (siz + 7) &^ 7\n\n\t// We could allocate a larger initial stack if necessary.\n\t// Not worth it: this is almost always an error.\n\t// 4*sizeof(uintreg): extra space added below\n\t// sizeof(uintreg): caller's LR (arm) or return address (x86, in gostartcall).\n\t// 如果函数的参数大小比2048大的话，直接panic\n\tif siz >= _StackMin-4*sys.RegSize-sys.RegSize {\n\t\tthrow(\"newproc: function arguments too large for new goroutine\")\n\t}\n\n\t// 从m中获取p\n\t_p_ := _g_.m.p.ptr()\n\t// 从gfree list获取g\n\tnewg := gfget(_p_)\n\t// 如果没获取到g，则新建一个\n\tif newg == nil {\n\t\tnewg = malg(_StackMin)\n\t\tcasgstatus(newg, _Gidle, _Gdead) //将g的状态改为_Gdead\n\t\t// 添加到allg数组，防止gc扫描清除掉\n\t\tallgadd(newg) // publishes with a g->status of Gdead so GC scanner doesn't look at uninitialized stack.\n\t}\n\tif newg.stack.hi == 0 {\n\t\tthrow(\"newproc1: newg missing stack\")\n\t}\n\n\tif readgstatus(newg) != _Gdead {\n\t\tthrow(\"newproc1: new g is not Gdead\")\n\t}\n\n\ttotalSize := 4*sys.RegSize + uintptr(siz) + sys.MinFrameSize // extra space in case of reads slightly beyond frame\n\ttotalSize += -totalSize & (sys.SpAlign - 1)                  // align to spAlign\n\tsp := newg.stack.hi - totalSize\n\tspArg := sp\n\tif usesLR {\n\t\t// caller's LR\n\t\t*(*uintptr)(unsafe.Pointer(sp)) = 0\n\t\tprepGoExitFrame(sp)\n\t\tspArg += sys.MinFrameSize\n\t}\n\tif narg > 0 {\n\t\t// copy参数\n\t\tmemmove(unsafe.Pointer(spArg), unsafe.Pointer(argp), uintptr(narg))\n\t\t// This is a stack-to-stack copy. If write barriers\n\t\t// are enabled and the source stack is grey (the\n\t\t// destination is always black), then perform a\n\t\t// barrier copy. We do this *after* the memmove\n\t\t// because the destination stack may have garbage on\n\t\t// it.\n\t\tif writeBarrier.needed && !_g_.m.curg.gcscandone {\n\t\t\tf := findfunc(fn.fn)\n\t\t\tstkmap := (*stackmap)(funcdata(f, _FUNCDATA_ArgsPointerMaps))\n\t\t\t// We're in the prologue, so it's always stack map index 0.\n\t\t\tbv := stackmapdata(stkmap, 0)\n\t\t\tbulkBarrierBitmap(spArg, spArg, uintptr(narg), 0, bv.bytedata)\n\t\t}\n\t}\n\n\tmemclrNoHeapPointers(unsafe.Pointer(&newg.sched), unsafe.Sizeof(newg.sched))\n\tnewg.sched.sp = sp\n\tnewg.stktopsp = sp\n\t// 保存goexit的地址到sched.pc\n\tnewg.sched.pc = funcPC(goexit) + sys.PCQuantum // +PCQuantum so that previous instruction is in same function\n\tnewg.sched.g = guintptr(unsafe.Pointer(newg))\n\tgostartcallfn(&newg.sched, fn)\n\tnewg.gopc = callerpc\n\tnewg.startpc = fn.fn\n\tif _g_.m.curg != nil {\n\t\tnewg.labels = _g_.m.curg.labels\n\t}\n\tif isSystemGoroutine(newg) {\n\t\tatomic.Xadd(&sched.ngsys, +1)\n\t}\n\tnewg.gcscanvalid = false\n\t// 更改当前g的状态为_Grunnable\n\tcasgstatus(newg, _Gdead, _Grunnable)\n\n\tif _p_.goidcache == _p_.goidcacheend {\n\t\t// Sched.goidgen is the last allocated id,\n\t\t// this batch must be [sched.goidgen+1, sched.goidgen+GoidCacheBatch].\n\t\t// At startup sched.goidgen=0, so main goroutine receives goid=1.\n\t\t_p_.goidcache = atomic.Xadd64(&sched.goidgen, _GoidCacheBatch)\n\t\t_p_.goidcache -= _GoidCacheBatch - 1\n\t\t_p_.goidcacheend = _p_.goidcache + _GoidCacheBatch\n\t}\n\t// 生成唯一的goid\n\tnewg.goid = int64(_p_.goidcache)\n\t_p_.goidcache++\n\tif raceenabled {\n\t\tnewg.racectx = racegostart(callerpc)\n\t}\n\tif trace.enabled {\n\t\ttraceGoCreate(newg, newg.startpc)\n\t}\n\t// 将当前新生成的g，放入队列\n\trunqput(_p_, newg, true)\n\n\t// 如果有空闲的p 且 m没有处于自旋状态 且 main goroutine已经启动，那么唤醒某个m来执行任务\n\tif atomic.Load(&sched.npidle) != 0 && atomic.Load(&sched.nmspinning) == 0 && mainStarted {\n\t\twakep()\n\t}\n\t_g_.m.locks--\n\tif _g_.m.locks == 0 && _g_.preempt { // restore the preemption request in case we've cleared it in newstack\n\t\t_g_.stackguard0 = stackPreempt\n\t}\n}\n```\n\n#### G的状态图\n```\n                                                      +------------+\n                                      ready           |            |\n                                  +------------------ |  _Gwaiting |\n                                  |                   |            |\n                                  |                   +------------+\n                                  |                         ^ park_m\n                                  V                         | \n  +------------+            +------------+  execute   +------------+            +------------+    \n  |            |  newproc   |            | ---------> |            |   goexit   |            |\n  |  _Gidle    | ---------> | _Grunnable |  yield     | _Grunning  | ---------> |   _Gdead   |      \n  |            |            |            | <--------- |            |            |            |\n  +------------+            +-----^------+            +------------+            +------------+\n                                  |         entersyscall |      ^ \n                                  |                      V      | existsyscall\n                                  |                   +------------+\n                                  |   existsyscall    |            |\n                                  +------------------ |  _Gsyscall |\n                                                      |            |\n                                                      +------------+\n\n```\n新建的G都是_Grunnable的，新建G的时候优先从gfree list从获取G，这样可以复用G，所以上图的状态不是完整的，_Gdead通过newproc会变为_Grunnable，\n通过go func()的语法新建的G，并不是直接运行，而是放入可运行的队列中，什么时候运行用于并不能决定，而是搞调度系统去自发的运行。\n\n\n","slug":"Golang的调度模型概览","published":1,"updated":"2019-02-26T02:29:01.538Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsl5qfty000ak8v34t3i7gyp","content":"<p>调度的机制用一句话描述：<br>runtime准备好G,P,M，然后M绑定P，M从各种队列中获取G，切换到G的执行栈上并执行G上的任务函数，调用goexit做清理工作并回到M，如此反复。</p>\n<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><h4 id=\"M（machine）\"><a href=\"#M（machine）\" class=\"headerlink\" title=\"M（machine）\"></a>M（machine）</h4><ul>\n<li>M代表着真正的执行计算资源，可以认为它就是os thread（系统线程）。</li>\n<li>M是真正调度系统的执行者，每个M就像一个勤劳的工作者，总是从各种队列中找到可运行的G，而且这样M的可以同时存在多个。</li>\n<li>M在绑定有效的P后，进入调度循环，而且M并不保留G状态，这是G可以跨M调度的基础。</li>\n</ul>\n<a id=\"more\"></a>\n<h4 id=\"P（processor）\"><a href=\"#P（processor）\" class=\"headerlink\" title=\"P（processor）\"></a>P（processor）</h4><ul>\n<li>P表示逻辑processor，是线程M的执行的上下文。</li>\n<li>P的最大作用是其拥有的各种G对象队列、链表、cache和状态。</li>\n</ul>\n<h4 id=\"G（goroutine）\"><a href=\"#G（goroutine）\" class=\"headerlink\" title=\"G（goroutine）\"></a>G（goroutine）</h4><ul>\n<li>调度系统的最基本单位goroutine，存储了goroutine的执行stack信息、goroutine状态以及goroutine的任务函数等。</li>\n<li>在G的眼中只有P，P就是运行G的“CPU”。</li>\n<li>相当于两级线程</li>\n</ul>\n<h4 id=\"线程实现模型\"><a href=\"#线程实现模型\" class=\"headerlink\" title=\"线程实现模型\"></a>线程实现模型</h4><p>来自<code>Go并发编程实战</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">                    +-------+       +-------+      </span><br><span class=\"line\">                    |  KSE  |       |  KSE  |          </span><br><span class=\"line\">                    +-------+       +-------+      </span><br><span class=\"line\">                        |               |                       内核空间</span><br><span class=\"line\">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -        </span><br><span class=\"line\">                        |               |                       用户空间</span><br><span class=\"line\">                    +-------+       +-------+</span><br><span class=\"line\">                    |   M   |       |   M   |</span><br><span class=\"line\">                    +-------+       +-------+</span><br><span class=\"line\">                  |          |         |          |</span><br><span class=\"line\">              +------+   +------+   +------+   +------+            </span><br><span class=\"line\">              |   P  |   |   P  |   |   P  |   |   P  |</span><br><span class=\"line\">              +------+   +------+   +------+   +------+   </span><br><span class=\"line\">           |     |     |     |     |     |     |     |     | </span><br><span class=\"line\">         +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ </span><br><span class=\"line\">         | G | | G | | G | | G | | G | | G | | G | | G | | G | </span><br><span class=\"line\">         +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>KSE（Kernel Scheduling Entity）是内核调度实体           </li>\n<li>M与P，P与G之前的关联都是动态的，可以变的</li>\n</ul>\n<h3 id=\"关系示意图\"><a href=\"#关系示意图\" class=\"headerlink\" title=\"关系示意图\"></a>关系示意图</h3><p>来自<code>golang源码剖析</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">                            +-------------------- sysmon ---------------//------+ </span><br><span class=\"line\">                            |                                                   |</span><br><span class=\"line\">                            |                                                   |</span><br><span class=\"line\">               +---+      +---+-------+                   +--------+          +---+---+</span><br><span class=\"line\">go func() ---&gt; | G | ---&gt; | P | local | &lt;=== balance ===&gt; | global | &lt;--//--- | P | M |</span><br><span class=\"line\">               +---+      +---+-------+                   +--------+          +---+---+</span><br><span class=\"line\">                            |                                 |                 | </span><br><span class=\"line\">                            |      +---+                      |                 |</span><br><span class=\"line\">                            +----&gt; | M | &lt;--- findrunnable ---+--- steal &lt;--//--+</span><br><span class=\"line\">                                   +---+ </span><br><span class=\"line\">                                     |</span><br><span class=\"line\">                                   mstart</span><br><span class=\"line\">                                     |</span><br><span class=\"line\">              +--- execute &lt;----- schedule </span><br><span class=\"line\">              |                      |   </span><br><span class=\"line\">              |                      |</span><br><span class=\"line\">              +--&gt; G.fn --&gt; goexit --+ </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">              1. go func() 语气创建G。</span><br><span class=\"line\">              2. 将G放入P的本地队列（或者平衡到全局全局队列）。</span><br><span class=\"line\">              3. 唤醒或新建M来执行任务。</span><br><span class=\"line\">              4. 进入调度循环</span><br><span class=\"line\">              5. 尽力获取可执行的G，并执行</span><br><span class=\"line\">              6. 清理现场并且重新进入调度循环</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"GPM的来由\"><a href=\"#GPM的来由\" class=\"headerlink\" title=\"GPM的来由\"></a>GPM的来由</h2><h3 id=\"特殊的g0和m0\"><a href=\"#特殊的g0和m0\" class=\"headerlink\" title=\"特殊的g0和m0\"></a>特殊的g0和m0</h3><p>g0和m0是在<code>proc.go</code>文件中的两个全局变量，m0就是进程启动后的初始线程，g0也是代表着初始线程的stack<br><code>asm_amd64.go</code> –&gt; runtime·rt0_go(SB)<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 程序刚启动的时候必定有一个线程启动（主线程）</span></span><br><span class=\"line\"><span class=\"comment\">// 将当前的栈和资源保存在g0</span></span><br><span class=\"line\"><span class=\"comment\">// 将该线程保存在m0</span></span><br><span class=\"line\"><span class=\"comment\">// tls: Thread Local Storage</span></span><br><span class=\"line\"><span class=\"comment\">// set the per-goroutine and per-mach \"registers\"</span></span><br><span class=\"line\">get_tls(BX)</span><br><span class=\"line\">LEAQ\truntime·g0(SB), CX</span><br><span class=\"line\">MOVQ\tCX, g(BX)</span><br><span class=\"line\">LEAQ\truntime·m0(SB), AX</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// save m-&gt;g0 = g0</span></span><br><span class=\"line\">MOVQ\tCX, m_g0(AX)</span><br><span class=\"line\"><span class=\"comment\">// save m0 to g0-&gt;m</span></span><br><span class=\"line\">MOVQ\tAX, g_m(CX)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"M的一生\"><a href=\"#M的一生\" class=\"headerlink\" title=\"M的一生\"></a>M的一生</h3><h4 id=\"M的创建\"><a href=\"#M的创建\" class=\"headerlink\" title=\"M的创建\"></a>M的创建</h4><p><code>proc.go</code><br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Create a new m. It will start off with a call to fn, or else the scheduler.</span></span><br><span class=\"line\"><span class=\"comment\">// fn needs to be static and not a heap allocated closure.</span></span><br><span class=\"line\"><span class=\"comment\">// May run with m.p==nil, so write barriers are not allowed.</span></span><br><span class=\"line\"><span class=\"comment\">//go:nowritebarrierrec</span></span><br><span class=\"line\"><span class=\"comment\">// 创建一个新的m，它将从fn或者调度程序开始</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">newm</span><span class=\"params\">(fn <span class=\"keyword\">func</span>()</span>, _<span class=\"title\">p_</span> *<span class=\"title\">p</span>)</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 根据fn和p和绑定一个m对象</span></span><br><span class=\"line\">\tmp := allocm(_p_, fn)</span><br><span class=\"line\">\t<span class=\"comment\">// 设置当前m的下一个p为_p_</span></span><br><span class=\"line\">\tmp.nextp.set(_p_)</span><br><span class=\"line\">\tmp.sigmask = initSigmask</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t<span class=\"comment\">// 真正的分配os thread</span></span><br><span class=\"line\">\tnewm1(mp)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">newm1</span><span class=\"params\">(mp *m)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 对cgo的处理</span></span><br><span class=\"line\">\t...</span><br><span class=\"line\">\texecLock.rlock() <span class=\"comment\">// Prevent process clone.</span></span><br><span class=\"line\">\t<span class=\"comment\">// 创建一个系统线程</span></span><br><span class=\"line\">\tnewosproc(mp, unsafe.Pointer(mp.g0.stack.hi))</span><br><span class=\"line\">\texecLock.runlock()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"状态\"><a href=\"#状态\" class=\"headerlink\" title=\"状态\"></a>状态</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> mstart</span><br><span class=\"line\">    |</span><br><span class=\"line\">    v        找不到可执行任务，gc STW，</span><br><span class=\"line\">+------+     任务执行时间过长，系统阻塞等   +------+</span><br><span class=\"line\">| spin | ----------------------------&gt; |unspin| </span><br><span class=\"line\">+------+          mstop                +------+</span><br><span class=\"line\">    ^                                      |</span><br><span class=\"line\">    |                                      v</span><br><span class=\"line\">notewakeup &lt;-------------------------  notesleep</span><br></pre></td></tr></table></figure>\n<h4 id=\"M的一些问题\"><a href=\"#M的一些问题\" class=\"headerlink\" title=\"M的一些问题\"></a>M的一些问题</h4><p><a href=\"https://github.com/golang/go/issues/14592\" target=\"_blank\" rel=\"noopener\">https://github.com/golang/go/issues/14592</a></p>\n<h3 id=\"P的一生\"><a href=\"#P的一生\" class=\"headerlink\" title=\"P的一生\"></a>P的一生</h3><h4 id=\"P的创建\"><a href=\"#P的创建\" class=\"headerlink\" title=\"P的创建\"></a>P的创建</h4><p><code>proc.go</code><br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Change number of processors. The world is stopped, sched is locked.</span></span><br><span class=\"line\"><span class=\"comment\">// gcworkbufs are not being modified by either the GC or</span></span><br><span class=\"line\"><span class=\"comment\">// the write barrier code.</span></span><br><span class=\"line\"><span class=\"comment\">// Returns list of Ps with local work, they need to be scheduled by the caller.</span></span><br><span class=\"line\"><span class=\"comment\">// 所有的P都在这个函数分配，不管是最开始的初始化分配，还是后期调整</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">procresize</span><span class=\"params\">(nprocs <span class=\"keyword\">int32</span>)</span> *<span class=\"title\">p</span></span> &#123;</span><br><span class=\"line\">\told := gomaxprocs</span><br><span class=\"line\">\t<span class=\"comment\">// 如果 gomaxprocs &lt;=0 抛出异常</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> old &lt; <span class=\"number\">0</span> || nprocs &lt;= <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tthrow(<span class=\"string\">\"procresize: invalid arg\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">\t<span class=\"comment\">// Grow allp if necessary.</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> nprocs &gt; <span class=\"keyword\">int32</span>(<span class=\"built_in\">len</span>(allp)) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// Synchronize with retake, which could be running</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// concurrently since it doesn't run on a P.</span></span><br><span class=\"line\">\t\tlock(&amp;allpLock)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> nprocs &lt;= <span class=\"keyword\">int32</span>(<span class=\"built_in\">cap</span>(allp)) &#123;</span><br><span class=\"line\">\t\t\tallp = allp[:nprocs]</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 分配nprocs个*p</span></span><br><span class=\"line\">\t\t\tnallp := <span class=\"built_in\">make</span>([]*p, nprocs)</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// Copy everything up to allp's cap so we</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// never lose old allocated Ps.</span></span><br><span class=\"line\">\t\t\t<span class=\"built_in\">copy</span>(nallp, allp[:<span class=\"built_in\">cap</span>(allp)])</span><br><span class=\"line\">\t\t\tallp = nallp</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tunlock(&amp;allpLock)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// initialize new P's</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"keyword\">int32</span>(<span class=\"number\">0</span>); i &lt; nprocs; i++ &#123;</span><br><span class=\"line\">\t\tpp := allp[i]</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> pp == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tpp = <span class=\"built_in\">new</span>(p)</span><br><span class=\"line\">\t\t\tpp.id = i</span><br><span class=\"line\">\t\t\tpp.status = _Pgcstop            <span class=\"comment\">// 更改状态</span></span><br><span class=\"line\">\t\t\tpp.sudogcache = pp.sudogbuf[:<span class=\"number\">0</span>] <span class=\"comment\">//将sudogcache指向sudogbuf的起始地址</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> pp.deferpool &#123;</span><br><span class=\"line\">\t\t\t\tpp.deferpool[i] = pp.deferpoolbuf[i][:<span class=\"number\">0</span>]</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tpp.wbBuf.reset()</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 将pp保存到allp数组里, allp[i] = pp</span></span><br><span class=\"line\">\t\t\tatomicstorep(unsafe.Pointer(&amp;allp[i]), unsafe.Pointer(pp))</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  ...</span><br><span class=\"line\"></span><br><span class=\"line\">\t_g_ := getg()</span><br><span class=\"line\">\t<span class=\"comment\">// 如果当前的M已经绑定P，继续使用，否则将当前的M绑定一个P</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> _g_.m.p != <span class=\"number\">0</span> &amp;&amp; _g_.m.p.ptr().id &lt; nprocs &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// continue to use the current P</span></span><br><span class=\"line\">\t\t_g_.m.p.ptr().status = _Prunning</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// release the current P and acquire allp[0]</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 获取allp[0]</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> _g_.m.p != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t_g_.m.p.ptr().m = <span class=\"number\">0</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t_g_.m.p = <span class=\"number\">0</span></span><br><span class=\"line\">\t\t_g_.m.mcache = <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\tp := allp[<span class=\"number\">0</span>]</span><br><span class=\"line\">\t\tp.m = <span class=\"number\">0</span></span><br><span class=\"line\">\t\tp.status = _Pidle</span><br><span class=\"line\">\t\t<span class=\"comment\">// 将当前的m和p绑定</span></span><br><span class=\"line\">\t\tacquirep(p)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> trace.enabled &#123;</span><br><span class=\"line\">\t\t\ttraceGoStart()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> runnablePs *p</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := nprocs - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i-- &#123;</span><br><span class=\"line\">\t\tp := allp[i]</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> _g_.m.p.ptr() == p &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tp.status = _Pidle</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> runqempty(p) &#123; <span class=\"comment\">// 将空闲p放入空闲链表</span></span><br><span class=\"line\">\t\t\tpidleput(p)</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tp.m.set(mget())</span><br><span class=\"line\">\t\t\tp.link.set(runnablePs)</span><br><span class=\"line\">\t\t\trunnablePs = p</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tstealOrder.reset(<span class=\"keyword\">uint32</span>(nprocs))</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> int32p *<span class=\"keyword\">int32</span> = &amp;gomaxprocs <span class=\"comment\">// make compiler check that gomaxprocs is an int32</span></span><br><span class=\"line\">\tatomic.Store((*<span class=\"keyword\">uint32</span>)(unsafe.Pointer(int32p)), <span class=\"keyword\">uint32</span>(nprocs))</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> runnablePs</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>所有的P在程序启动的时候就设置好了，并用一个allp slice维护，可以调用runtime.GOMAXPROCS调整P的个数，虽然代价很大</p>\n<h4 id=\"状态转换\"><a href=\"#状态转换\" class=\"headerlink\" title=\"状态转换\"></a>状态转换</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">                                            acquirep(p)        </span><br><span class=\"line\">                          不需要使用的P       P和M绑定的时候       进入系统调用       procresize()</span><br><span class=\"line\">new(p)  -----+        +---------------+     +-----------+     +------------+    +----------+</span><br><span class=\"line\">            |         |               |     |           |     |            |    |          |</span><br><span class=\"line\">            |   +------------+    +---v--------+    +---v--------+    +----v-------+    +--v---------+</span><br><span class=\"line\">            +--&gt;|  _Pgcstop  |    |    _Pidle  |    |  _Prunning |    |  _Psyscall |    |   _Pdead   |</span><br><span class=\"line\">                +------^-----+    +--------^---+    +--------^---+    +------------+    +------------+</span><br><span class=\"line\">                       |            |     |            |     |            |</span><br><span class=\"line\">                       +------------+     +------------+     +------------+</span><br><span class=\"line\">                           GC结束            releasep()        退出系统调用</span><br><span class=\"line\">                                            P和M解绑                      </span><br><span class=\"line\">``` </span><br><span class=\"line\">P的数量默认等于cpu的个数，很多人认为runtime.GOMAXPROCS可以限制系统线程的数量，但这是错误的，M是按需创建的，和runtime.GOMAXPROCS没有关系。</span><br><span class=\"line\">### G的一生</span><br><span class=\"line\"></span><br><span class=\"line\">#### G的创建</span><br><span class=\"line\">`proc.go`</span><br><span class=\"line\">```go</span><br><span class=\"line\">// Create a new g running fn with siz bytes of arguments.</span><br><span class=\"line\">// Put it on the queue of g&apos;s waiting to run.</span><br><span class=\"line\">// The compiler turns a go statement into a call to this.</span><br><span class=\"line\">// Cannot split the stack because it assumes that the arguments</span><br><span class=\"line\">// are available sequentially after &amp;fn; they would not be</span><br><span class=\"line\">// copied if a stack split occurred.</span><br><span class=\"line\">//go:nosplit</span><br><span class=\"line\">// 新建一个goroutine，</span><br><span class=\"line\">// 􏳄 用fn + PtrSize 获取第一个参数的地址，也就是argp</span><br><span class=\"line\">// 用siz - 8 获取pc地址</span><br><span class=\"line\">func newproc(siz int32, fn *funcval) &#123;</span><br><span class=\"line\">\targp := add(unsafe.Pointer(&amp;fn), sys.PtrSize)</span><br><span class=\"line\">\tpc := getcallerpc()</span><br><span class=\"line\">\t// 用g0的栈创建G对象</span><br><span class=\"line\">\tsystemstack(func() &#123;</span><br><span class=\"line\">\t\tnewproc1(fn, (*uint8)(argp), siz, pc)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Create a new g running fn with narg bytes of arguments starting</span></span><br><span class=\"line\"><span class=\"comment\">// at argp. callerpc is the address of the go statement that created</span></span><br><span class=\"line\"><span class=\"comment\">// this. The new g is put on the queue of g's waiting to run.</span></span><br><span class=\"line\"><span class=\"comment\">// 根据函数参数和函数地址，创建一个新的G，然后将这个G加入队列等待运行</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">newproc1</span><span class=\"params\">(fn *funcval, argp *<span class=\"keyword\">uint8</span>, narg <span class=\"keyword\">int32</span>, callerpc <span class=\"keyword\">uintptr</span>)</span></span> &#123;</span><br><span class=\"line\">\t_g_ := getg()</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> fn == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t_g_.m.throwing = <span class=\"number\">-1</span> <span class=\"comment\">// do not dump full stacks</span></span><br><span class=\"line\">\t\tthrow(<span class=\"string\">\"go of nil func value\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t_g_.m.locks++ <span class=\"comment\">// disable preemption because it can be holding p in a local var</span></span><br><span class=\"line\">\tsiz := narg</span><br><span class=\"line\">\tsiz = (siz + <span class=\"number\">7</span>) &amp;^ <span class=\"number\">7</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// We could allocate a larger initial stack if necessary.</span></span><br><span class=\"line\">\t<span class=\"comment\">// Not worth it: this is almost always an error.</span></span><br><span class=\"line\">\t<span class=\"comment\">// 4*sizeof(uintreg): extra space added below</span></span><br><span class=\"line\">\t<span class=\"comment\">// sizeof(uintreg): caller's LR (arm) or return address (x86, in gostartcall).</span></span><br><span class=\"line\">\t<span class=\"comment\">// 如果函数的参数大小比2048大的话，直接panic</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> siz &gt;= _StackMin<span class=\"number\">-4</span>*sys.RegSize-sys.RegSize &#123;</span><br><span class=\"line\">\t\tthrow(<span class=\"string\">\"newproc: function arguments too large for new goroutine\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 从m中获取p</span></span><br><span class=\"line\">\t_p_ := _g_.m.p.ptr()</span><br><span class=\"line\">\t<span class=\"comment\">// 从gfree list获取g</span></span><br><span class=\"line\">\tnewg := gfget(_p_)</span><br><span class=\"line\">\t<span class=\"comment\">// 如果没获取到g，则新建一个</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> newg == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tnewg = malg(_StackMin)</span><br><span class=\"line\">\t\tcasgstatus(newg, _Gidle, _Gdead) <span class=\"comment\">//将g的状态改为_Gdead</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 添加到allg数组，防止gc扫描清除掉</span></span><br><span class=\"line\">\t\tallgadd(newg) <span class=\"comment\">// publishes with a g-&gt;status of Gdead so GC scanner doesn't look at uninitialized stack.</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> newg.stack.hi == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tthrow(<span class=\"string\">\"newproc1: newg missing stack\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> readgstatus(newg) != _Gdead &#123;</span><br><span class=\"line\">\t\tthrow(<span class=\"string\">\"newproc1: new g is not Gdead\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\ttotalSize := <span class=\"number\">4</span>*sys.RegSize + <span class=\"keyword\">uintptr</span>(siz) + sys.MinFrameSize <span class=\"comment\">// extra space in case of reads slightly beyond frame</span></span><br><span class=\"line\">\ttotalSize += -totalSize &amp; (sys.SpAlign - <span class=\"number\">1</span>)                  <span class=\"comment\">// align to spAlign</span></span><br><span class=\"line\">\tsp := newg.stack.hi - totalSize</span><br><span class=\"line\">\tspArg := sp</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> usesLR &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// caller's LR</span></span><br><span class=\"line\">\t\t*(*<span class=\"keyword\">uintptr</span>)(unsafe.Pointer(sp)) = <span class=\"number\">0</span></span><br><span class=\"line\">\t\tprepGoExitFrame(sp)</span><br><span class=\"line\">\t\tspArg += sys.MinFrameSize</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> narg &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// copy参数</span></span><br><span class=\"line\">\t\tmemmove(unsafe.Pointer(spArg), unsafe.Pointer(argp), <span class=\"keyword\">uintptr</span>(narg))</span><br><span class=\"line\">\t\t<span class=\"comment\">// This is a stack-to-stack copy. If write barriers</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// are enabled and the source stack is grey (the</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// destination is always black), then perform a</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// barrier copy. We do this *after* the memmove</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// because the destination stack may have garbage on</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// it.</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> writeBarrier.needed &amp;&amp; !_g_.m.curg.gcscandone &#123;</span><br><span class=\"line\">\t\t\tf := findfunc(fn.fn)</span><br><span class=\"line\">\t\t\tstkmap := (*stackmap)(funcdata(f, _FUNCDATA_ArgsPointerMaps))</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// We're in the prologue, so it's always stack map index 0.</span></span><br><span class=\"line\">\t\t\tbv := stackmapdata(stkmap, <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\tbulkBarrierBitmap(spArg, spArg, <span class=\"keyword\">uintptr</span>(narg), <span class=\"number\">0</span>, bv.bytedata)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tmemclrNoHeapPointers(unsafe.Pointer(&amp;newg.sched), unsafe.Sizeof(newg.sched))</span><br><span class=\"line\">\tnewg.sched.sp = sp</span><br><span class=\"line\">\tnewg.stktopsp = sp</span><br><span class=\"line\">\t<span class=\"comment\">// 保存goexit的地址到sched.pc</span></span><br><span class=\"line\">\tnewg.sched.pc = funcPC(goexit) + sys.PCQuantum <span class=\"comment\">// +PCQuantum so that previous instruction is in same function</span></span><br><span class=\"line\">\tnewg.sched.g = guintptr(unsafe.Pointer(newg))</span><br><span class=\"line\">\tgostartcallfn(&amp;newg.sched, fn)</span><br><span class=\"line\">\tnewg.gopc = callerpc</span><br><span class=\"line\">\tnewg.startpc = fn.fn</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> _g_.m.curg != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tnewg.labels = _g_.m.curg.labels</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> isSystemGoroutine(newg) &#123;</span><br><span class=\"line\">\t\tatomic.Xadd(&amp;sched.ngsys, +<span class=\"number\">1</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tnewg.gcscanvalid = <span class=\"literal\">false</span></span><br><span class=\"line\">\t<span class=\"comment\">// 更改当前g的状态为_Grunnable</span></span><br><span class=\"line\">\tcasgstatus(newg, _Gdead, _Grunnable)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> _p_.goidcache == _p_.goidcacheend &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// Sched.goidgen is the last allocated id,</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// this batch must be [sched.goidgen+1, sched.goidgen+GoidCacheBatch].</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// At startup sched.goidgen=0, so main goroutine receives goid=1.</span></span><br><span class=\"line\">\t\t_p_.goidcache = atomic.Xadd64(&amp;sched.goidgen, _GoidCacheBatch)</span><br><span class=\"line\">\t\t_p_.goidcache -= _GoidCacheBatch - <span class=\"number\">1</span></span><br><span class=\"line\">\t\t_p_.goidcacheend = _p_.goidcache + _GoidCacheBatch</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 生成唯一的goid</span></span><br><span class=\"line\">\tnewg.goid = <span class=\"keyword\">int64</span>(_p_.goidcache)</span><br><span class=\"line\">\t_p_.goidcache++</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> raceenabled &#123;</span><br><span class=\"line\">\t\tnewg.racectx = racegostart(callerpc)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> trace.enabled &#123;</span><br><span class=\"line\">\t\ttraceGoCreate(newg, newg.startpc)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 将当前新生成的g，放入队列</span></span><br><span class=\"line\">\trunqput(_p_, newg, <span class=\"literal\">true</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 如果有空闲的p 且 m没有处于自旋状态 且 main goroutine已经启动，那么唤醒某个m来执行任务</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> atomic.Load(&amp;sched.npidle) != <span class=\"number\">0</span> &amp;&amp; atomic.Load(&amp;sched.nmspinning) == <span class=\"number\">0</span> &amp;&amp; mainStarted &#123;</span><br><span class=\"line\">\t\twakep()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t_g_.m.locks--</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> _g_.m.locks == <span class=\"number\">0</span> &amp;&amp; _g_.preempt &#123; <span class=\"comment\">// restore the preemption request in case we've cleared it in newstack</span></span><br><span class=\"line\">\t\t_g_.stackguard0 = stackPreempt</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"G的状态图\"><a href=\"#G的状态图\" class=\"headerlink\" title=\"G的状态图\"></a>G的状态图</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">                                                    +------------+</span><br><span class=\"line\">                                    ready           |            |</span><br><span class=\"line\">                                +------------------ |  _Gwaiting |</span><br><span class=\"line\">                                |                   |            |</span><br><span class=\"line\">                                |                   +------------+</span><br><span class=\"line\">                                |                         ^ park_m</span><br><span class=\"line\">                                V                         | </span><br><span class=\"line\">+------------+            +------------+  execute   +------------+            +------------+    </span><br><span class=\"line\">|            |  newproc   |            | ---------&gt; |            |   goexit   |            |</span><br><span class=\"line\">|  _Gidle    | ---------&gt; | _Grunnable |  yield     | _Grunning  | ---------&gt; |   _Gdead   |      </span><br><span class=\"line\">|            |            |            | &lt;--------- |            |            |            |</span><br><span class=\"line\">+------------+            +-----^------+            +------------+            +------------+</span><br><span class=\"line\">                                |         entersyscall |      ^ </span><br><span class=\"line\">                                |                      V      | existsyscall</span><br><span class=\"line\">                                |                   +------------+</span><br><span class=\"line\">                                |   existsyscall    |            |</span><br><span class=\"line\">                                +------------------ |  _Gsyscall |</span><br><span class=\"line\">                                                    |            |</span><br><span class=\"line\">                                                    +------------+</span><br></pre></td></tr></table></figure>\n<p>新建的G都是_Grunnable的，新建G的时候优先从gfree list从获取G，这样可以复用G，所以上图的状态不是完整的，_Gdead通过newproc会变为_Grunnable，<br>通过go func()的语法新建的G，并不是直接运行，而是放入可运行的队列中，什么时候运行用于并不能决定，而是搞调度系统去自发的运行。</p>\n","site":{"data":{}},"excerpt":"<p>调度的机制用一句话描述：<br>runtime准备好G,P,M，然后M绑定P，M从各种队列中获取G，切换到G的执行栈上并执行G上的任务函数，调用goexit做清理工作并回到M，如此反复。</p>\n<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><h4 id=\"M（machine）\"><a href=\"#M（machine）\" class=\"headerlink\" title=\"M（machine）\"></a>M（machine）</h4><ul>\n<li>M代表着真正的执行计算资源，可以认为它就是os thread（系统线程）。</li>\n<li>M是真正调度系统的执行者，每个M就像一个勤劳的工作者，总是从各种队列中找到可运行的G，而且这样M的可以同时存在多个。</li>\n<li>M在绑定有效的P后，进入调度循环，而且M并不保留G状态，这是G可以跨M调度的基础。</li>\n</ul>","more":"<h4 id=\"P（processor）\"><a href=\"#P（processor）\" class=\"headerlink\" title=\"P（processor）\"></a>P（processor）</h4><ul>\n<li>P表示逻辑processor，是线程M的执行的上下文。</li>\n<li>P的最大作用是其拥有的各种G对象队列、链表、cache和状态。</li>\n</ul>\n<h4 id=\"G（goroutine）\"><a href=\"#G（goroutine）\" class=\"headerlink\" title=\"G（goroutine）\"></a>G（goroutine）</h4><ul>\n<li>调度系统的最基本单位goroutine，存储了goroutine的执行stack信息、goroutine状态以及goroutine的任务函数等。</li>\n<li>在G的眼中只有P，P就是运行G的“CPU”。</li>\n<li>相当于两级线程</li>\n</ul>\n<h4 id=\"线程实现模型\"><a href=\"#线程实现模型\" class=\"headerlink\" title=\"线程实现模型\"></a>线程实现模型</h4><p>来自<code>Go并发编程实战</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">                    +-------+       +-------+      </span><br><span class=\"line\">                    |  KSE  |       |  KSE  |          </span><br><span class=\"line\">                    +-------+       +-------+      </span><br><span class=\"line\">                        |               |                       内核空间</span><br><span class=\"line\">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -        </span><br><span class=\"line\">                        |               |                       用户空间</span><br><span class=\"line\">                    +-------+       +-------+</span><br><span class=\"line\">                    |   M   |       |   M   |</span><br><span class=\"line\">                    +-------+       +-------+</span><br><span class=\"line\">                  |          |         |          |</span><br><span class=\"line\">              +------+   +------+   +------+   +------+            </span><br><span class=\"line\">              |   P  |   |   P  |   |   P  |   |   P  |</span><br><span class=\"line\">              +------+   +------+   +------+   +------+   </span><br><span class=\"line\">           |     |     |     |     |     |     |     |     | </span><br><span class=\"line\">         +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ </span><br><span class=\"line\">         | G | | G | | G | | G | | G | | G | | G | | G | | G | </span><br><span class=\"line\">         +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>KSE（Kernel Scheduling Entity）是内核调度实体           </li>\n<li>M与P，P与G之前的关联都是动态的，可以变的</li>\n</ul>\n<h3 id=\"关系示意图\"><a href=\"#关系示意图\" class=\"headerlink\" title=\"关系示意图\"></a>关系示意图</h3><p>来自<code>golang源码剖析</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">                            +-------------------- sysmon ---------------//------+ </span><br><span class=\"line\">                            |                                                   |</span><br><span class=\"line\">                            |                                                   |</span><br><span class=\"line\">               +---+      +---+-------+                   +--------+          +---+---+</span><br><span class=\"line\">go func() ---&gt; | G | ---&gt; | P | local | &lt;=== balance ===&gt; | global | &lt;--//--- | P | M |</span><br><span class=\"line\">               +---+      +---+-------+                   +--------+          +---+---+</span><br><span class=\"line\">                            |                                 |                 | </span><br><span class=\"line\">                            |      +---+                      |                 |</span><br><span class=\"line\">                            +----&gt; | M | &lt;--- findrunnable ---+--- steal &lt;--//--+</span><br><span class=\"line\">                                   +---+ </span><br><span class=\"line\">                                     |</span><br><span class=\"line\">                                   mstart</span><br><span class=\"line\">                                     |</span><br><span class=\"line\">              +--- execute &lt;----- schedule </span><br><span class=\"line\">              |                      |   </span><br><span class=\"line\">              |                      |</span><br><span class=\"line\">              +--&gt; G.fn --&gt; goexit --+ </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">              1. go func() 语气创建G。</span><br><span class=\"line\">              2. 将G放入P的本地队列（或者平衡到全局全局队列）。</span><br><span class=\"line\">              3. 唤醒或新建M来执行任务。</span><br><span class=\"line\">              4. 进入调度循环</span><br><span class=\"line\">              5. 尽力获取可执行的G，并执行</span><br><span class=\"line\">              6. 清理现场并且重新进入调度循环</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"GPM的来由\"><a href=\"#GPM的来由\" class=\"headerlink\" title=\"GPM的来由\"></a>GPM的来由</h2><h3 id=\"特殊的g0和m0\"><a href=\"#特殊的g0和m0\" class=\"headerlink\" title=\"特殊的g0和m0\"></a>特殊的g0和m0</h3><p>g0和m0是在<code>proc.go</code>文件中的两个全局变量，m0就是进程启动后的初始线程，g0也是代表着初始线程的stack<br><code>asm_amd64.go</code> –&gt; runtime·rt0_go(SB)<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 程序刚启动的时候必定有一个线程启动（主线程）</span></span><br><span class=\"line\"><span class=\"comment\">// 将当前的栈和资源保存在g0</span></span><br><span class=\"line\"><span class=\"comment\">// 将该线程保存在m0</span></span><br><span class=\"line\"><span class=\"comment\">// tls: Thread Local Storage</span></span><br><span class=\"line\"><span class=\"comment\">// set the per-goroutine and per-mach \"registers\"</span></span><br><span class=\"line\">get_tls(BX)</span><br><span class=\"line\">LEAQ\truntime·g0(SB), CX</span><br><span class=\"line\">MOVQ\tCX, g(BX)</span><br><span class=\"line\">LEAQ\truntime·m0(SB), AX</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// save m-&gt;g0 = g0</span></span><br><span class=\"line\">MOVQ\tCX, m_g0(AX)</span><br><span class=\"line\"><span class=\"comment\">// save m0 to g0-&gt;m</span></span><br><span class=\"line\">MOVQ\tAX, g_m(CX)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"M的一生\"><a href=\"#M的一生\" class=\"headerlink\" title=\"M的一生\"></a>M的一生</h3><h4 id=\"M的创建\"><a href=\"#M的创建\" class=\"headerlink\" title=\"M的创建\"></a>M的创建</h4><p><code>proc.go</code><br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Create a new m. It will start off with a call to fn, or else the scheduler.</span></span><br><span class=\"line\"><span class=\"comment\">// fn needs to be static and not a heap allocated closure.</span></span><br><span class=\"line\"><span class=\"comment\">// May run with m.p==nil, so write barriers are not allowed.</span></span><br><span class=\"line\"><span class=\"comment\">//go:nowritebarrierrec</span></span><br><span class=\"line\"><span class=\"comment\">// 创建一个新的m，它将从fn或者调度程序开始</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">newm</span><span class=\"params\">(fn <span class=\"keyword\">func</span>()</span>, _<span class=\"title\">p_</span> *<span class=\"title\">p</span>)</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 根据fn和p和绑定一个m对象</span></span><br><span class=\"line\">\tmp := allocm(_p_, fn)</span><br><span class=\"line\">\t<span class=\"comment\">// 设置当前m的下一个p为_p_</span></span><br><span class=\"line\">\tmp.nextp.set(_p_)</span><br><span class=\"line\">\tmp.sigmask = initSigmask</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t<span class=\"comment\">// 真正的分配os thread</span></span><br><span class=\"line\">\tnewm1(mp)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">newm1</span><span class=\"params\">(mp *m)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 对cgo的处理</span></span><br><span class=\"line\">\t...</span><br><span class=\"line\">\texecLock.rlock() <span class=\"comment\">// Prevent process clone.</span></span><br><span class=\"line\">\t<span class=\"comment\">// 创建一个系统线程</span></span><br><span class=\"line\">\tnewosproc(mp, unsafe.Pointer(mp.g0.stack.hi))</span><br><span class=\"line\">\texecLock.runlock()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"状态\"><a href=\"#状态\" class=\"headerlink\" title=\"状态\"></a>状态</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> mstart</span><br><span class=\"line\">    |</span><br><span class=\"line\">    v        找不到可执行任务，gc STW，</span><br><span class=\"line\">+------+     任务执行时间过长，系统阻塞等   +------+</span><br><span class=\"line\">| spin | ----------------------------&gt; |unspin| </span><br><span class=\"line\">+------+          mstop                +------+</span><br><span class=\"line\">    ^                                      |</span><br><span class=\"line\">    |                                      v</span><br><span class=\"line\">notewakeup &lt;-------------------------  notesleep</span><br></pre></td></tr></table></figure>\n<h4 id=\"M的一些问题\"><a href=\"#M的一些问题\" class=\"headerlink\" title=\"M的一些问题\"></a>M的一些问题</h4><p><a href=\"https://github.com/golang/go/issues/14592\" target=\"_blank\" rel=\"noopener\">https://github.com/golang/go/issues/14592</a></p>\n<h3 id=\"P的一生\"><a href=\"#P的一生\" class=\"headerlink\" title=\"P的一生\"></a>P的一生</h3><h4 id=\"P的创建\"><a href=\"#P的创建\" class=\"headerlink\" title=\"P的创建\"></a>P的创建</h4><p><code>proc.go</code><br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Change number of processors. The world is stopped, sched is locked.</span></span><br><span class=\"line\"><span class=\"comment\">// gcworkbufs are not being modified by either the GC or</span></span><br><span class=\"line\"><span class=\"comment\">// the write barrier code.</span></span><br><span class=\"line\"><span class=\"comment\">// Returns list of Ps with local work, they need to be scheduled by the caller.</span></span><br><span class=\"line\"><span class=\"comment\">// 所有的P都在这个函数分配，不管是最开始的初始化分配，还是后期调整</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">procresize</span><span class=\"params\">(nprocs <span class=\"keyword\">int32</span>)</span> *<span class=\"title\">p</span></span> &#123;</span><br><span class=\"line\">\told := gomaxprocs</span><br><span class=\"line\">\t<span class=\"comment\">// 如果 gomaxprocs &lt;=0 抛出异常</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> old &lt; <span class=\"number\">0</span> || nprocs &lt;= <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tthrow(<span class=\"string\">\"procresize: invalid arg\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">\t<span class=\"comment\">// Grow allp if necessary.</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> nprocs &gt; <span class=\"keyword\">int32</span>(<span class=\"built_in\">len</span>(allp)) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// Synchronize with retake, which could be running</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// concurrently since it doesn't run on a P.</span></span><br><span class=\"line\">\t\tlock(&amp;allpLock)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> nprocs &lt;= <span class=\"keyword\">int32</span>(<span class=\"built_in\">cap</span>(allp)) &#123;</span><br><span class=\"line\">\t\t\tallp = allp[:nprocs]</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 分配nprocs个*p</span></span><br><span class=\"line\">\t\t\tnallp := <span class=\"built_in\">make</span>([]*p, nprocs)</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// Copy everything up to allp's cap so we</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// never lose old allocated Ps.</span></span><br><span class=\"line\">\t\t\t<span class=\"built_in\">copy</span>(nallp, allp[:<span class=\"built_in\">cap</span>(allp)])</span><br><span class=\"line\">\t\t\tallp = nallp</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tunlock(&amp;allpLock)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// initialize new P's</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"keyword\">int32</span>(<span class=\"number\">0</span>); i &lt; nprocs; i++ &#123;</span><br><span class=\"line\">\t\tpp := allp[i]</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> pp == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tpp = <span class=\"built_in\">new</span>(p)</span><br><span class=\"line\">\t\t\tpp.id = i</span><br><span class=\"line\">\t\t\tpp.status = _Pgcstop            <span class=\"comment\">// 更改状态</span></span><br><span class=\"line\">\t\t\tpp.sudogcache = pp.sudogbuf[:<span class=\"number\">0</span>] <span class=\"comment\">//将sudogcache指向sudogbuf的起始地址</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> pp.deferpool &#123;</span><br><span class=\"line\">\t\t\t\tpp.deferpool[i] = pp.deferpoolbuf[i][:<span class=\"number\">0</span>]</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tpp.wbBuf.reset()</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 将pp保存到allp数组里, allp[i] = pp</span></span><br><span class=\"line\">\t\t\tatomicstorep(unsafe.Pointer(&amp;allp[i]), unsafe.Pointer(pp))</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  ...</span><br><span class=\"line\"></span><br><span class=\"line\">\t_g_ := getg()</span><br><span class=\"line\">\t<span class=\"comment\">// 如果当前的M已经绑定P，继续使用，否则将当前的M绑定一个P</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> _g_.m.p != <span class=\"number\">0</span> &amp;&amp; _g_.m.p.ptr().id &lt; nprocs &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// continue to use the current P</span></span><br><span class=\"line\">\t\t_g_.m.p.ptr().status = _Prunning</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// release the current P and acquire allp[0]</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 获取allp[0]</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> _g_.m.p != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t_g_.m.p.ptr().m = <span class=\"number\">0</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t_g_.m.p = <span class=\"number\">0</span></span><br><span class=\"line\">\t\t_g_.m.mcache = <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\tp := allp[<span class=\"number\">0</span>]</span><br><span class=\"line\">\t\tp.m = <span class=\"number\">0</span></span><br><span class=\"line\">\t\tp.status = _Pidle</span><br><span class=\"line\">\t\t<span class=\"comment\">// 将当前的m和p绑定</span></span><br><span class=\"line\">\t\tacquirep(p)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> trace.enabled &#123;</span><br><span class=\"line\">\t\t\ttraceGoStart()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> runnablePs *p</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := nprocs - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i-- &#123;</span><br><span class=\"line\">\t\tp := allp[i]</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> _g_.m.p.ptr() == p &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tp.status = _Pidle</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> runqempty(p) &#123; <span class=\"comment\">// 将空闲p放入空闲链表</span></span><br><span class=\"line\">\t\t\tpidleput(p)</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tp.m.set(mget())</span><br><span class=\"line\">\t\t\tp.link.set(runnablePs)</span><br><span class=\"line\">\t\t\trunnablePs = p</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tstealOrder.reset(<span class=\"keyword\">uint32</span>(nprocs))</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> int32p *<span class=\"keyword\">int32</span> = &amp;gomaxprocs <span class=\"comment\">// make compiler check that gomaxprocs is an int32</span></span><br><span class=\"line\">\tatomic.Store((*<span class=\"keyword\">uint32</span>)(unsafe.Pointer(int32p)), <span class=\"keyword\">uint32</span>(nprocs))</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> runnablePs</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>所有的P在程序启动的时候就设置好了，并用一个allp slice维护，可以调用runtime.GOMAXPROCS调整P的个数，虽然代价很大</p>\n<h4 id=\"状态转换\"><a href=\"#状态转换\" class=\"headerlink\" title=\"状态转换\"></a>状态转换</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">                                            acquirep(p)        </span><br><span class=\"line\">                          不需要使用的P       P和M绑定的时候       进入系统调用       procresize()</span><br><span class=\"line\">new(p)  -----+        +---------------+     +-----------+     +------------+    +----------+</span><br><span class=\"line\">            |         |               |     |           |     |            |    |          |</span><br><span class=\"line\">            |   +------------+    +---v--------+    +---v--------+    +----v-------+    +--v---------+</span><br><span class=\"line\">            +--&gt;|  _Pgcstop  |    |    _Pidle  |    |  _Prunning |    |  _Psyscall |    |   _Pdead   |</span><br><span class=\"line\">                +------^-----+    +--------^---+    +--------^---+    +------------+    +------------+</span><br><span class=\"line\">                       |            |     |            |     |            |</span><br><span class=\"line\">                       +------------+     +------------+     +------------+</span><br><span class=\"line\">                           GC结束            releasep()        退出系统调用</span><br><span class=\"line\">                                            P和M解绑                      </span><br><span class=\"line\">``` </span><br><span class=\"line\">P的数量默认等于cpu的个数，很多人认为runtime.GOMAXPROCS可以限制系统线程的数量，但这是错误的，M是按需创建的，和runtime.GOMAXPROCS没有关系。</span><br><span class=\"line\">### G的一生</span><br><span class=\"line\"></span><br><span class=\"line\">#### G的创建</span><br><span class=\"line\">`proc.go`</span><br><span class=\"line\">```go</span><br><span class=\"line\">// Create a new g running fn with siz bytes of arguments.</span><br><span class=\"line\">// Put it on the queue of g&apos;s waiting to run.</span><br><span class=\"line\">// The compiler turns a go statement into a call to this.</span><br><span class=\"line\">// Cannot split the stack because it assumes that the arguments</span><br><span class=\"line\">// are available sequentially after &amp;fn; they would not be</span><br><span class=\"line\">// copied if a stack split occurred.</span><br><span class=\"line\">//go:nosplit</span><br><span class=\"line\">// 新建一个goroutine，</span><br><span class=\"line\">// 􏳄 用fn + PtrSize 获取第一个参数的地址，也就是argp</span><br><span class=\"line\">// 用siz - 8 获取pc地址</span><br><span class=\"line\">func newproc(siz int32, fn *funcval) &#123;</span><br><span class=\"line\">\targp := add(unsafe.Pointer(&amp;fn), sys.PtrSize)</span><br><span class=\"line\">\tpc := getcallerpc()</span><br><span class=\"line\">\t// 用g0的栈创建G对象</span><br><span class=\"line\">\tsystemstack(func() &#123;</span><br><span class=\"line\">\t\tnewproc1(fn, (*uint8)(argp), siz, pc)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Create a new g running fn with narg bytes of arguments starting</span></span><br><span class=\"line\"><span class=\"comment\">// at argp. callerpc is the address of the go statement that created</span></span><br><span class=\"line\"><span class=\"comment\">// this. The new g is put on the queue of g's waiting to run.</span></span><br><span class=\"line\"><span class=\"comment\">// 根据函数参数和函数地址，创建一个新的G，然后将这个G加入队列等待运行</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">newproc1</span><span class=\"params\">(fn *funcval, argp *<span class=\"keyword\">uint8</span>, narg <span class=\"keyword\">int32</span>, callerpc <span class=\"keyword\">uintptr</span>)</span></span> &#123;</span><br><span class=\"line\">\t_g_ := getg()</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> fn == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t_g_.m.throwing = <span class=\"number\">-1</span> <span class=\"comment\">// do not dump full stacks</span></span><br><span class=\"line\">\t\tthrow(<span class=\"string\">\"go of nil func value\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t_g_.m.locks++ <span class=\"comment\">// disable preemption because it can be holding p in a local var</span></span><br><span class=\"line\">\tsiz := narg</span><br><span class=\"line\">\tsiz = (siz + <span class=\"number\">7</span>) &amp;^ <span class=\"number\">7</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// We could allocate a larger initial stack if necessary.</span></span><br><span class=\"line\">\t<span class=\"comment\">// Not worth it: this is almost always an error.</span></span><br><span class=\"line\">\t<span class=\"comment\">// 4*sizeof(uintreg): extra space added below</span></span><br><span class=\"line\">\t<span class=\"comment\">// sizeof(uintreg): caller's LR (arm) or return address (x86, in gostartcall).</span></span><br><span class=\"line\">\t<span class=\"comment\">// 如果函数的参数大小比2048大的话，直接panic</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> siz &gt;= _StackMin<span class=\"number\">-4</span>*sys.RegSize-sys.RegSize &#123;</span><br><span class=\"line\">\t\tthrow(<span class=\"string\">\"newproc: function arguments too large for new goroutine\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 从m中获取p</span></span><br><span class=\"line\">\t_p_ := _g_.m.p.ptr()</span><br><span class=\"line\">\t<span class=\"comment\">// 从gfree list获取g</span></span><br><span class=\"line\">\tnewg := gfget(_p_)</span><br><span class=\"line\">\t<span class=\"comment\">// 如果没获取到g，则新建一个</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> newg == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tnewg = malg(_StackMin)</span><br><span class=\"line\">\t\tcasgstatus(newg, _Gidle, _Gdead) <span class=\"comment\">//将g的状态改为_Gdead</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 添加到allg数组，防止gc扫描清除掉</span></span><br><span class=\"line\">\t\tallgadd(newg) <span class=\"comment\">// publishes with a g-&gt;status of Gdead so GC scanner doesn't look at uninitialized stack.</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> newg.stack.hi == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tthrow(<span class=\"string\">\"newproc1: newg missing stack\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> readgstatus(newg) != _Gdead &#123;</span><br><span class=\"line\">\t\tthrow(<span class=\"string\">\"newproc1: new g is not Gdead\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\ttotalSize := <span class=\"number\">4</span>*sys.RegSize + <span class=\"keyword\">uintptr</span>(siz) + sys.MinFrameSize <span class=\"comment\">// extra space in case of reads slightly beyond frame</span></span><br><span class=\"line\">\ttotalSize += -totalSize &amp; (sys.SpAlign - <span class=\"number\">1</span>)                  <span class=\"comment\">// align to spAlign</span></span><br><span class=\"line\">\tsp := newg.stack.hi - totalSize</span><br><span class=\"line\">\tspArg := sp</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> usesLR &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// caller's LR</span></span><br><span class=\"line\">\t\t*(*<span class=\"keyword\">uintptr</span>)(unsafe.Pointer(sp)) = <span class=\"number\">0</span></span><br><span class=\"line\">\t\tprepGoExitFrame(sp)</span><br><span class=\"line\">\t\tspArg += sys.MinFrameSize</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> narg &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// copy参数</span></span><br><span class=\"line\">\t\tmemmove(unsafe.Pointer(spArg), unsafe.Pointer(argp), <span class=\"keyword\">uintptr</span>(narg))</span><br><span class=\"line\">\t\t<span class=\"comment\">// This is a stack-to-stack copy. If write barriers</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// are enabled and the source stack is grey (the</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// destination is always black), then perform a</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// barrier copy. We do this *after* the memmove</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// because the destination stack may have garbage on</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// it.</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> writeBarrier.needed &amp;&amp; !_g_.m.curg.gcscandone &#123;</span><br><span class=\"line\">\t\t\tf := findfunc(fn.fn)</span><br><span class=\"line\">\t\t\tstkmap := (*stackmap)(funcdata(f, _FUNCDATA_ArgsPointerMaps))</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// We're in the prologue, so it's always stack map index 0.</span></span><br><span class=\"line\">\t\t\tbv := stackmapdata(stkmap, <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\tbulkBarrierBitmap(spArg, spArg, <span class=\"keyword\">uintptr</span>(narg), <span class=\"number\">0</span>, bv.bytedata)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tmemclrNoHeapPointers(unsafe.Pointer(&amp;newg.sched), unsafe.Sizeof(newg.sched))</span><br><span class=\"line\">\tnewg.sched.sp = sp</span><br><span class=\"line\">\tnewg.stktopsp = sp</span><br><span class=\"line\">\t<span class=\"comment\">// 保存goexit的地址到sched.pc</span></span><br><span class=\"line\">\tnewg.sched.pc = funcPC(goexit) + sys.PCQuantum <span class=\"comment\">// +PCQuantum so that previous instruction is in same function</span></span><br><span class=\"line\">\tnewg.sched.g = guintptr(unsafe.Pointer(newg))</span><br><span class=\"line\">\tgostartcallfn(&amp;newg.sched, fn)</span><br><span class=\"line\">\tnewg.gopc = callerpc</span><br><span class=\"line\">\tnewg.startpc = fn.fn</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> _g_.m.curg != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tnewg.labels = _g_.m.curg.labels</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> isSystemGoroutine(newg) &#123;</span><br><span class=\"line\">\t\tatomic.Xadd(&amp;sched.ngsys, +<span class=\"number\">1</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tnewg.gcscanvalid = <span class=\"literal\">false</span></span><br><span class=\"line\">\t<span class=\"comment\">// 更改当前g的状态为_Grunnable</span></span><br><span class=\"line\">\tcasgstatus(newg, _Gdead, _Grunnable)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> _p_.goidcache == _p_.goidcacheend &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// Sched.goidgen is the last allocated id,</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// this batch must be [sched.goidgen+1, sched.goidgen+GoidCacheBatch].</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// At startup sched.goidgen=0, so main goroutine receives goid=1.</span></span><br><span class=\"line\">\t\t_p_.goidcache = atomic.Xadd64(&amp;sched.goidgen, _GoidCacheBatch)</span><br><span class=\"line\">\t\t_p_.goidcache -= _GoidCacheBatch - <span class=\"number\">1</span></span><br><span class=\"line\">\t\t_p_.goidcacheend = _p_.goidcache + _GoidCacheBatch</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 生成唯一的goid</span></span><br><span class=\"line\">\tnewg.goid = <span class=\"keyword\">int64</span>(_p_.goidcache)</span><br><span class=\"line\">\t_p_.goidcache++</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> raceenabled &#123;</span><br><span class=\"line\">\t\tnewg.racectx = racegostart(callerpc)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> trace.enabled &#123;</span><br><span class=\"line\">\t\ttraceGoCreate(newg, newg.startpc)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 将当前新生成的g，放入队列</span></span><br><span class=\"line\">\trunqput(_p_, newg, <span class=\"literal\">true</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 如果有空闲的p 且 m没有处于自旋状态 且 main goroutine已经启动，那么唤醒某个m来执行任务</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> atomic.Load(&amp;sched.npidle) != <span class=\"number\">0</span> &amp;&amp; atomic.Load(&amp;sched.nmspinning) == <span class=\"number\">0</span> &amp;&amp; mainStarted &#123;</span><br><span class=\"line\">\t\twakep()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t_g_.m.locks--</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> _g_.m.locks == <span class=\"number\">0</span> &amp;&amp; _g_.preempt &#123; <span class=\"comment\">// restore the preemption request in case we've cleared it in newstack</span></span><br><span class=\"line\">\t\t_g_.stackguard0 = stackPreempt</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"G的状态图\"><a href=\"#G的状态图\" class=\"headerlink\" title=\"G的状态图\"></a>G的状态图</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">                                                    +------------+</span><br><span class=\"line\">                                    ready           |            |</span><br><span class=\"line\">                                +------------------ |  _Gwaiting |</span><br><span class=\"line\">                                |                   |            |</span><br><span class=\"line\">                                |                   +------------+</span><br><span class=\"line\">                                |                         ^ park_m</span><br><span class=\"line\">                                V                         | </span><br><span class=\"line\">+------------+            +------------+  execute   +------------+            +------------+    </span><br><span class=\"line\">|            |  newproc   |            | ---------&gt; |            |   goexit   |            |</span><br><span class=\"line\">|  _Gidle    | ---------&gt; | _Grunnable |  yield     | _Grunning  | ---------&gt; |   _Gdead   |      </span><br><span class=\"line\">|            |            |            | &lt;--------- |            |            |            |</span><br><span class=\"line\">+------------+            +-----^------+            +------------+            +------------+</span><br><span class=\"line\">                                |         entersyscall |      ^ </span><br><span class=\"line\">                                |                      V      | existsyscall</span><br><span class=\"line\">                                |                   +------------+</span><br><span class=\"line\">                                |   existsyscall    |            |</span><br><span class=\"line\">                                +------------------ |  _Gsyscall |</span><br><span class=\"line\">                                                    |            |</span><br><span class=\"line\">                                                    +------------+</span><br></pre></td></tr></table></figure>\n<p>新建的G都是_Grunnable的，新建G的时候优先从gfree list从获取G，这样可以复用G，所以上图的状态不是完整的，_Gdead通过newproc会变为_Grunnable，<br>通过go func()的语法新建的G，并不是直接运行，而是放入可运行的队列中，什么时候运行用于并不能决定，而是搞调度系统去自发的运行。</p>"},{"title":"对于 Netty ByteBuf 的零拷贝(Zero Copy) 的理解","date":"2018-08-20T01:04:55.000Z","_content":"\n根据 Wiki 对 Zero-copy 的定义:\n> \"Zero-copy\" describes computer operations in which the CPU does not perform the task of copying data from one memory area to another. This is frequently used to save CPU cycles and memory bandwidth when transmitting a file over a network.\n\n即所谓的 Zero-copy, 就是在操作数据时, 不需要将数据 buffer 从一个内存区域拷贝到另一个内存区域. 因为少了一次内存的拷贝, 因此 CPU 的效率就得到的提升.\n\n在 OS 层面上的 Zero-copy 通常指避免在 用户态(User-space) 与 内核态(Kernel-space) 之间来回拷贝数据. 例如 Linux 提供的 mmap 系统调用, 它可以将一段用户空间内存映射到内核空间, 当映射成功后, 用户对这段内存区域的修改可以直接反映到内核空间; 同样地, 内核空间对这段区域的修改也直接反映用户空间. 正因为有这样的映射关系, 我们就不需要在 用户态(User-space) 与 内核态(Kernel-space) 之间拷贝数据, 提高了数据传输的效率.\n\n而需要注意的是, Netty 中的 Zero-copy 与上面我们所提到到 OS 层面上的 Zero-copy 不太一样, Netty的 Zero-coyp 完全是在用户态(Java 层面)的, 它的 Zero-copy 的更多的是偏向于 优化数据操作 这样的概念.\n\nNetty 的 Zero-copy 体现在如下几个个方面:\n\n- Netty 提供了 CompositeByteBuf 类, 它可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf, 避免了各个 ByteBuf 之间的拷贝.\n- 通过 wrap 操作, 我们可以将 byte[] 数组、ByteBuf、ByteBuffer等包装成一个 Netty ByteBuf 对象, 进而避免了拷贝操作.\n- ByteBuf 支持 slice 操作, 因此可以将 ByteBuf 分解为多个共享同一个存储区域的 ByteBuf, 避免了内存的拷贝.\n- 通过 FileRegion 包装的FileChannel.tranferTo 实现文件传输, 可以直接将文件缓冲区的数据发送到目标 Channel, 避免了传统通过循环 write 方式导致的内存拷贝问题.\n\n下面我们就来简单了解一下这几种常见的零拷贝操作.\n\n<!-- more -->\n\n# 通过 CompositeByteBuf 实现零拷贝\n\n假设我们有一份协议数据, 它由头部和消息体组成, 而头部和消息体是分别存放在两个 ByteBuf 中的, 即:\n```\nByteBuf header = ...\nByteBuf body = ...\n```\n我们在代码处理中, 通常希望将 header 和 body 合并为一个 ByteBuf, 方便处理, 那么通常的做法是:\n```\nByteBuf allBuf = Unpooled.buffer(header.readableBytes() + body.readableBytes());\nallBuf.writeBytes(header);\nallBuf.writeBytes(body);\n```\n可以看到, 我们将 header 和 body 都拷贝到了新的 allBuf 中了, 这无形中增加了两次额外的数据拷贝操作了.\n\n那么有没有更加高效优雅的方式实现相同的目的呢? 我们来看一下 CompositeByteBuf 是如何实现这样的需求的吧.\n```\nByteBuf header = ...\nByteBuf body = ...\n\nCompositeByteBuf compositeByteBuf = Unpooled.compositeBuffer();\ncompositeByteBuf.addComponents(true, header, body);\n```\n上面代码中, 我们定义了一个 CompositeByteBuf 对象, 然后调用\n```\npublic CompositeByteBuf addComponents(boolean increaseWriterIndex, ByteBuf... buffers) {\n...\n}\n```\n不过需要注意的是, 虽然看起来 CompositeByteBuf 是由两个 ByteBuf 组合而成的, 不过在 CompositeByteBuf 内部, 这两个 ByteBuf 都是单独存在的, CompositeByteBuf 只是逻辑上是一个整体.\n\n上面 CompositeByteBuf 代码还以一个地方值得注意的是, 我们调用 addComponents(boolean increaseWriterIndex, ByteBuf... buffers) 来添加两个 ByteBuf, 其中第一个参数是 true, 表示当添加新的 ByteBuf 时, 自动递增 CompositeByteBuf 的 writeIndex.\n如果我们调用的是\n```\ncompositeByteBuf.addComponents(header, body);\n```\n那么其实 compositeByteBuf 的 writeIndex 仍然是0, 因此此时我们就不可能从 compositeByteBuf 中读取到数据, 这一点希望大家要特别注意.\n\n除了上面直接使用 CompositeByteBuf 类外, 我们还可以使用 Unpooled.wrappedBuffer 方法, 它底层封装了 CompositeByteBuf 操作, 因此使用起来更加方便:\n```\nByteBuf header = ...\nByteBuf body = ...\n\nByteBuf allByteBuf = Unpooled.wrappedBuffer(header, body);\n```\n# 通过 wrap 操作实现零拷贝\n例如我们有一个 byte 数组, 我们希望将它转换为一个 ByteBuf 对象, 以便于后续的操作, 那么传统的做法是将此 byte 数组拷贝到 ByteBuf 中, 即:\n```\nbyte[] bytes = ...\nByteBuf byteBuf = Unpooled.buffer();\nbyteBuf.writeBytes(bytes);\n```\n显然这样的方式也是有一个额外的拷贝操作的, 我们可以使用 Unpooled 的相关方法, 包装这个 byte 数组, 生成一个新的 ByteBuf 实例, 而不需要进行拷贝操作. 上面的代码可以改为:\n```\nbyte[] bytes = ...\nByteBuf byteBuf = Unpooled.wrappedBuffer(bytes);\n```\n可以看到, 我们通过 Unpooled.wrappedBuffer 方法来将 bytes 包装成为一个 UnpooledHeapByteBuf 对象, 而在包装的过程中, 是不会有拷贝操作的. 即最后我们生成的生成的 ByteBuf 对象是和 bytes 数组共用了同一个存储空间, 对 bytes 的修改也会反映到 ByteBuf 对象中.\n\nUnpooled 工具类还提供了很多重载的 wrappedBuffer 方法:\n```\npublic static ByteBuf wrappedBuffer(byte[] array)\npublic static ByteBuf wrappedBuffer(byte[] array, int offset, int length)\n\npublic static ByteBuf wrappedBuffer(ByteBuffer buffer)\npublic static ByteBuf wrappedBuffer(ByteBuf buffer)\n\npublic static ByteBuf wrappedBuffer(byte[]... arrays)\npublic static ByteBuf wrappedBuffer(ByteBuf... buffers)\npublic static ByteBuf wrappedBuffer(ByteBuffer... buffers)\n\npublic static ByteBuf wrappedBuffer(int maxNumComponents, byte[]... arrays)\npublic static ByteBuf wrappedBuffer(int maxNumComponents, ByteBuf... buffers)\npublic static ByteBuf wrappedBuffer(int maxNumComponents, ByteBuffer... buffers)\n```\n这些方法可以将一个或多个 buffer 包装为一个 ByteBuf 对象, 从而避免了拷贝操作.\n# 通过 slice 操作实现零拷贝\nslice 操作和 wrap 操作刚好相反, Unpooled.wrappedBuffer 可以将多个 ByteBuf 合并为一个, 而 slice 操作可以将一个 ByteBuf 切片 为多个共享一个存储区域的 ByteBuf 对象.\n\nByteBuf 提供了两个 slice 操作方法:\n```\npublic ByteBuf slice();\npublic ByteBuf slice(int index, int length);\n```\n不带参数的 slice 方法等同于 buf.slice(buf.readerIndex(), buf.readableBytes()) 调用, 即返回 buf 中可读部分的切片. 而 slice(int index, int length) 方法相对就比较灵活了, 我们可以设置不同的参数来获取到 buf 的不同区域的切片.\n\n下面的例子展示了 ByteBuf.slice 方法的简单用法:\n```\nByteBuf byteBuf = ...\nByteBuf header = byteBuf.slice(0, 5);\nByteBuf body = byteBuf.slice(5, 10);\n```\n用 slice 方法产生 header 和 body 的过程是没有拷贝操作的, header 和 body 对象在内部其实是共享了 byteBuf 存储空间的不同部分而已.\n# 通过 FileRegion 实现零拷贝\nNetty 中使用 FileRegion 实现文件传输的零拷贝, 不过在底层 FileRegion 是依赖于 Java NIO FileChannel.transfer 的零拷贝功能.\n\n首先我们从最基础的 Java IO 开始吧. 假设我们希望实现一个文件拷贝的功能, 那么使用传统的方式, 我们有如下实现:\n\n```\npublic static void copyFile(String srcFile, String destFile) throws Exception {\n    byte[] temp = new byte[1024];\n    FileInputStream in = new FileInputStream(srcFile);\n    FileOutputStream out = new FileOutputStream(destFile);\n    int length;\n    while ((length = in.read(temp)) != -1) {\n        out.write(temp, 0, length);\n    }\n\n    in.close();\n    out.close();\n}\n```\n上面是一个典型的读写二进制文件的代码实现了. 不用我说, 大家肯定都知道, 上面的代码中不断中源文件中读取定长数据到 temp 数组中, 然后再将 temp 中的内容写入目的文件, 这样的拷贝操作对于小文件倒是没有太大的影响, 但是如果我们需要拷贝大文件时, 频繁的内存拷贝操作就消耗大量的系统资源了.\n\n下面我们来看一下使用 Java NIO 的 FileChannel 是如何实现零拷贝的:\n```\npublic static void copyFileWithFileChannel(String srcFileName, String destFileName) throws Exception {\n    RandomAccessFile srcFile = new RandomAccessFile(srcFileName, \"r\");\n    FileChannel srcFileChannel = srcFile.getChannel();\n\n    RandomAccessFile destFile = new RandomAccessFile(destFileName, \"rw\");\n    FileChannel destFileChannel = destFile.getChannel();\n\n    long position = 0;\n    long count = srcFileChannel.size();\n\n    srcFileChannel.transferTo(position, count, destFileChannel);\n}\n\n```\n可以看到, 使用了 FileChannel 后, 我们就可以直接将源文件的内容直接拷贝(transferTo) 到目的文件中, 而不需要额外借助一个临时 buffer, 避免了不必要的内存操作.\n\n有了上面的一些理论知识, 我们来看一下在 Netty 中是怎么使用 FileRegion 来实现零拷贝传输一个文件的:\n```\n@Override\npublic void channelRead0(ChannelHandlerContext ctx, String msg) throws Exception {\n    RandomAccessFile raf = null;\n    long length = -1;\n    try {\n        // 1. 通过 RandomAccessFile 打开一个文件.\n        raf = new RandomAccessFile(msg, \"r\");\n        length = raf.length();\n    } catch (Exception e) {\n        ctx.writeAndFlush(\"ERR: \" + e.getClass().getSimpleName() + \": \" + e.getMessage() + '\\n');\n        return;\n    } finally {\n        if (length < 0 && raf != null) {\n            raf.close();\n        }\n    }\n\n    ctx.write(\"OK: \" + raf.length() + '\\n');\n    if (ctx.pipeline().get(SslHandler.class) == null) {\n        // SSL not enabled - can use zero-copy file transfer.\n        // 2. 调用 raf.getChannel() 获取一个 FileChannel.\n        // 3. 将 FileChannel 封装成一个 DefaultFileRegion\n        ctx.write(new DefaultFileRegion(raf.getChannel(), 0, length));\n    } else {\n        // SSL enabled - cannot use zero-copy file transfer.\n        ctx.write(new ChunkedFile(raf));\n    }\n    ctx.writeAndFlush(\"\\n\");\n}\n```\n上面的代码是 Netty 的一个例子, 其源码在 netty/example/src/main/java/io/netty/example/file/FileServerHandler.java\n可以看到, 第一步是通过 RandomAccessFile 打开一个文件, 然后 Netty 使用了 DefaultFileRegion 来封装一个 FileChannel 即:\n```\nnew DefaultFileRegion(raf.getChannel(), 0, length)\n```\n当有了 FileRegion 后, 我们就可以直接通过它将文件的内容直接写入 Channel 中, 而不需要像传统的做法: 拷贝文件内容到临时 buffer, 然后再将 buffer 写入 Channel. 通过这样的零拷贝操作, 无疑对传输大文件很有帮助.\n\n转载出处：https://www.cnblogs.com/xys1228/p/6088805.html\n","source":"_posts/zero-copy.md","raw":"---\ntitle: 对于 Netty ByteBuf 的零拷贝(Zero Copy) 的理解\ndate: 2018-08-20 09:04:55\ntags: Netty\n---\n\n根据 Wiki 对 Zero-copy 的定义:\n> \"Zero-copy\" describes computer operations in which the CPU does not perform the task of copying data from one memory area to another. This is frequently used to save CPU cycles and memory bandwidth when transmitting a file over a network.\n\n即所谓的 Zero-copy, 就是在操作数据时, 不需要将数据 buffer 从一个内存区域拷贝到另一个内存区域. 因为少了一次内存的拷贝, 因此 CPU 的效率就得到的提升.\n\n在 OS 层面上的 Zero-copy 通常指避免在 用户态(User-space) 与 内核态(Kernel-space) 之间来回拷贝数据. 例如 Linux 提供的 mmap 系统调用, 它可以将一段用户空间内存映射到内核空间, 当映射成功后, 用户对这段内存区域的修改可以直接反映到内核空间; 同样地, 内核空间对这段区域的修改也直接反映用户空间. 正因为有这样的映射关系, 我们就不需要在 用户态(User-space) 与 内核态(Kernel-space) 之间拷贝数据, 提高了数据传输的效率.\n\n而需要注意的是, Netty 中的 Zero-copy 与上面我们所提到到 OS 层面上的 Zero-copy 不太一样, Netty的 Zero-coyp 完全是在用户态(Java 层面)的, 它的 Zero-copy 的更多的是偏向于 优化数据操作 这样的概念.\n\nNetty 的 Zero-copy 体现在如下几个个方面:\n\n- Netty 提供了 CompositeByteBuf 类, 它可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf, 避免了各个 ByteBuf 之间的拷贝.\n- 通过 wrap 操作, 我们可以将 byte[] 数组、ByteBuf、ByteBuffer等包装成一个 Netty ByteBuf 对象, 进而避免了拷贝操作.\n- ByteBuf 支持 slice 操作, 因此可以将 ByteBuf 分解为多个共享同一个存储区域的 ByteBuf, 避免了内存的拷贝.\n- 通过 FileRegion 包装的FileChannel.tranferTo 实现文件传输, 可以直接将文件缓冲区的数据发送到目标 Channel, 避免了传统通过循环 write 方式导致的内存拷贝问题.\n\n下面我们就来简单了解一下这几种常见的零拷贝操作.\n\n<!-- more -->\n\n# 通过 CompositeByteBuf 实现零拷贝\n\n假设我们有一份协议数据, 它由头部和消息体组成, 而头部和消息体是分别存放在两个 ByteBuf 中的, 即:\n```\nByteBuf header = ...\nByteBuf body = ...\n```\n我们在代码处理中, 通常希望将 header 和 body 合并为一个 ByteBuf, 方便处理, 那么通常的做法是:\n```\nByteBuf allBuf = Unpooled.buffer(header.readableBytes() + body.readableBytes());\nallBuf.writeBytes(header);\nallBuf.writeBytes(body);\n```\n可以看到, 我们将 header 和 body 都拷贝到了新的 allBuf 中了, 这无形中增加了两次额外的数据拷贝操作了.\n\n那么有没有更加高效优雅的方式实现相同的目的呢? 我们来看一下 CompositeByteBuf 是如何实现这样的需求的吧.\n```\nByteBuf header = ...\nByteBuf body = ...\n\nCompositeByteBuf compositeByteBuf = Unpooled.compositeBuffer();\ncompositeByteBuf.addComponents(true, header, body);\n```\n上面代码中, 我们定义了一个 CompositeByteBuf 对象, 然后调用\n```\npublic CompositeByteBuf addComponents(boolean increaseWriterIndex, ByteBuf... buffers) {\n...\n}\n```\n不过需要注意的是, 虽然看起来 CompositeByteBuf 是由两个 ByteBuf 组合而成的, 不过在 CompositeByteBuf 内部, 这两个 ByteBuf 都是单独存在的, CompositeByteBuf 只是逻辑上是一个整体.\n\n上面 CompositeByteBuf 代码还以一个地方值得注意的是, 我们调用 addComponents(boolean increaseWriterIndex, ByteBuf... buffers) 来添加两个 ByteBuf, 其中第一个参数是 true, 表示当添加新的 ByteBuf 时, 自动递增 CompositeByteBuf 的 writeIndex.\n如果我们调用的是\n```\ncompositeByteBuf.addComponents(header, body);\n```\n那么其实 compositeByteBuf 的 writeIndex 仍然是0, 因此此时我们就不可能从 compositeByteBuf 中读取到数据, 这一点希望大家要特别注意.\n\n除了上面直接使用 CompositeByteBuf 类外, 我们还可以使用 Unpooled.wrappedBuffer 方法, 它底层封装了 CompositeByteBuf 操作, 因此使用起来更加方便:\n```\nByteBuf header = ...\nByteBuf body = ...\n\nByteBuf allByteBuf = Unpooled.wrappedBuffer(header, body);\n```\n# 通过 wrap 操作实现零拷贝\n例如我们有一个 byte 数组, 我们希望将它转换为一个 ByteBuf 对象, 以便于后续的操作, 那么传统的做法是将此 byte 数组拷贝到 ByteBuf 中, 即:\n```\nbyte[] bytes = ...\nByteBuf byteBuf = Unpooled.buffer();\nbyteBuf.writeBytes(bytes);\n```\n显然这样的方式也是有一个额外的拷贝操作的, 我们可以使用 Unpooled 的相关方法, 包装这个 byte 数组, 生成一个新的 ByteBuf 实例, 而不需要进行拷贝操作. 上面的代码可以改为:\n```\nbyte[] bytes = ...\nByteBuf byteBuf = Unpooled.wrappedBuffer(bytes);\n```\n可以看到, 我们通过 Unpooled.wrappedBuffer 方法来将 bytes 包装成为一个 UnpooledHeapByteBuf 对象, 而在包装的过程中, 是不会有拷贝操作的. 即最后我们生成的生成的 ByteBuf 对象是和 bytes 数组共用了同一个存储空间, 对 bytes 的修改也会反映到 ByteBuf 对象中.\n\nUnpooled 工具类还提供了很多重载的 wrappedBuffer 方法:\n```\npublic static ByteBuf wrappedBuffer(byte[] array)\npublic static ByteBuf wrappedBuffer(byte[] array, int offset, int length)\n\npublic static ByteBuf wrappedBuffer(ByteBuffer buffer)\npublic static ByteBuf wrappedBuffer(ByteBuf buffer)\n\npublic static ByteBuf wrappedBuffer(byte[]... arrays)\npublic static ByteBuf wrappedBuffer(ByteBuf... buffers)\npublic static ByteBuf wrappedBuffer(ByteBuffer... buffers)\n\npublic static ByteBuf wrappedBuffer(int maxNumComponents, byte[]... arrays)\npublic static ByteBuf wrappedBuffer(int maxNumComponents, ByteBuf... buffers)\npublic static ByteBuf wrappedBuffer(int maxNumComponents, ByteBuffer... buffers)\n```\n这些方法可以将一个或多个 buffer 包装为一个 ByteBuf 对象, 从而避免了拷贝操作.\n# 通过 slice 操作实现零拷贝\nslice 操作和 wrap 操作刚好相反, Unpooled.wrappedBuffer 可以将多个 ByteBuf 合并为一个, 而 slice 操作可以将一个 ByteBuf 切片 为多个共享一个存储区域的 ByteBuf 对象.\n\nByteBuf 提供了两个 slice 操作方法:\n```\npublic ByteBuf slice();\npublic ByteBuf slice(int index, int length);\n```\n不带参数的 slice 方法等同于 buf.slice(buf.readerIndex(), buf.readableBytes()) 调用, 即返回 buf 中可读部分的切片. 而 slice(int index, int length) 方法相对就比较灵活了, 我们可以设置不同的参数来获取到 buf 的不同区域的切片.\n\n下面的例子展示了 ByteBuf.slice 方法的简单用法:\n```\nByteBuf byteBuf = ...\nByteBuf header = byteBuf.slice(0, 5);\nByteBuf body = byteBuf.slice(5, 10);\n```\n用 slice 方法产生 header 和 body 的过程是没有拷贝操作的, header 和 body 对象在内部其实是共享了 byteBuf 存储空间的不同部分而已.\n# 通过 FileRegion 实现零拷贝\nNetty 中使用 FileRegion 实现文件传输的零拷贝, 不过在底层 FileRegion 是依赖于 Java NIO FileChannel.transfer 的零拷贝功能.\n\n首先我们从最基础的 Java IO 开始吧. 假设我们希望实现一个文件拷贝的功能, 那么使用传统的方式, 我们有如下实现:\n\n```\npublic static void copyFile(String srcFile, String destFile) throws Exception {\n    byte[] temp = new byte[1024];\n    FileInputStream in = new FileInputStream(srcFile);\n    FileOutputStream out = new FileOutputStream(destFile);\n    int length;\n    while ((length = in.read(temp)) != -1) {\n        out.write(temp, 0, length);\n    }\n\n    in.close();\n    out.close();\n}\n```\n上面是一个典型的读写二进制文件的代码实现了. 不用我说, 大家肯定都知道, 上面的代码中不断中源文件中读取定长数据到 temp 数组中, 然后再将 temp 中的内容写入目的文件, 这样的拷贝操作对于小文件倒是没有太大的影响, 但是如果我们需要拷贝大文件时, 频繁的内存拷贝操作就消耗大量的系统资源了.\n\n下面我们来看一下使用 Java NIO 的 FileChannel 是如何实现零拷贝的:\n```\npublic static void copyFileWithFileChannel(String srcFileName, String destFileName) throws Exception {\n    RandomAccessFile srcFile = new RandomAccessFile(srcFileName, \"r\");\n    FileChannel srcFileChannel = srcFile.getChannel();\n\n    RandomAccessFile destFile = new RandomAccessFile(destFileName, \"rw\");\n    FileChannel destFileChannel = destFile.getChannel();\n\n    long position = 0;\n    long count = srcFileChannel.size();\n\n    srcFileChannel.transferTo(position, count, destFileChannel);\n}\n\n```\n可以看到, 使用了 FileChannel 后, 我们就可以直接将源文件的内容直接拷贝(transferTo) 到目的文件中, 而不需要额外借助一个临时 buffer, 避免了不必要的内存操作.\n\n有了上面的一些理论知识, 我们来看一下在 Netty 中是怎么使用 FileRegion 来实现零拷贝传输一个文件的:\n```\n@Override\npublic void channelRead0(ChannelHandlerContext ctx, String msg) throws Exception {\n    RandomAccessFile raf = null;\n    long length = -1;\n    try {\n        // 1. 通过 RandomAccessFile 打开一个文件.\n        raf = new RandomAccessFile(msg, \"r\");\n        length = raf.length();\n    } catch (Exception e) {\n        ctx.writeAndFlush(\"ERR: \" + e.getClass().getSimpleName() + \": \" + e.getMessage() + '\\n');\n        return;\n    } finally {\n        if (length < 0 && raf != null) {\n            raf.close();\n        }\n    }\n\n    ctx.write(\"OK: \" + raf.length() + '\\n');\n    if (ctx.pipeline().get(SslHandler.class) == null) {\n        // SSL not enabled - can use zero-copy file transfer.\n        // 2. 调用 raf.getChannel() 获取一个 FileChannel.\n        // 3. 将 FileChannel 封装成一个 DefaultFileRegion\n        ctx.write(new DefaultFileRegion(raf.getChannel(), 0, length));\n    } else {\n        // SSL enabled - cannot use zero-copy file transfer.\n        ctx.write(new ChunkedFile(raf));\n    }\n    ctx.writeAndFlush(\"\\n\");\n}\n```\n上面的代码是 Netty 的一个例子, 其源码在 netty/example/src/main/java/io/netty/example/file/FileServerHandler.java\n可以看到, 第一步是通过 RandomAccessFile 打开一个文件, 然后 Netty 使用了 DefaultFileRegion 来封装一个 FileChannel 即:\n```\nnew DefaultFileRegion(raf.getChannel(), 0, length)\n```\n当有了 FileRegion 后, 我们就可以直接通过它将文件的内容直接写入 Channel 中, 而不需要像传统的做法: 拷贝文件内容到临时 buffer, 然后再将 buffer 写入 Channel. 通过这样的零拷贝操作, 无疑对传输大文件很有帮助.\n\n转载出处：https://www.cnblogs.com/xys1228/p/6088805.html\n","slug":"zero-copy","published":1,"updated":"2019-02-26T02:29:01.543Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsl5qfu1000bk8v3lh420onx","content":"<p>根据 Wiki 对 Zero-copy 的定义:</p>\n<blockquote>\n<p>“Zero-copy” describes computer operations in which the CPU does not perform the task of copying data from one memory area to another. This is frequently used to save CPU cycles and memory bandwidth when transmitting a file over a network.</p>\n</blockquote>\n<p>即所谓的 Zero-copy, 就是在操作数据时, 不需要将数据 buffer 从一个内存区域拷贝到另一个内存区域. 因为少了一次内存的拷贝, 因此 CPU 的效率就得到的提升.</p>\n<p>在 OS 层面上的 Zero-copy 通常指避免在 用户态(User-space) 与 内核态(Kernel-space) 之间来回拷贝数据. 例如 Linux 提供的 mmap 系统调用, 它可以将一段用户空间内存映射到内核空间, 当映射成功后, 用户对这段内存区域的修改可以直接反映到内核空间; 同样地, 内核空间对这段区域的修改也直接反映用户空间. 正因为有这样的映射关系, 我们就不需要在 用户态(User-space) 与 内核态(Kernel-space) 之间拷贝数据, 提高了数据传输的效率.</p>\n<p>而需要注意的是, Netty 中的 Zero-copy 与上面我们所提到到 OS 层面上的 Zero-copy 不太一样, Netty的 Zero-coyp 完全是在用户态(Java 层面)的, 它的 Zero-copy 的更多的是偏向于 优化数据操作 这样的概念.</p>\n<p>Netty 的 Zero-copy 体现在如下几个个方面:</p>\n<ul>\n<li>Netty 提供了 CompositeByteBuf 类, 它可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf, 避免了各个 ByteBuf 之间的拷贝.</li>\n<li>通过 wrap 操作, 我们可以将 byte[] 数组、ByteBuf、ByteBuffer等包装成一个 Netty ByteBuf 对象, 进而避免了拷贝操作.</li>\n<li>ByteBuf 支持 slice 操作, 因此可以将 ByteBuf 分解为多个共享同一个存储区域的 ByteBuf, 避免了内存的拷贝.</li>\n<li>通过 FileRegion 包装的FileChannel.tranferTo 实现文件传输, 可以直接将文件缓冲区的数据发送到目标 Channel, 避免了传统通过循环 write 方式导致的内存拷贝问题.</li>\n</ul>\n<p>下面我们就来简单了解一下这几种常见的零拷贝操作.</p>\n<a id=\"more\"></a>\n<h1 id=\"通过-CompositeByteBuf-实现零拷贝\"><a href=\"#通过-CompositeByteBuf-实现零拷贝\" class=\"headerlink\" title=\"通过 CompositeByteBuf 实现零拷贝\"></a>通过 CompositeByteBuf 实现零拷贝</h1><p>假设我们有一份协议数据, 它由头部和消息体组成, 而头部和消息体是分别存放在两个 ByteBuf 中的, 即:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ByteBuf header = ...</span><br><span class=\"line\">ByteBuf body = ...</span><br></pre></td></tr></table></figure></p>\n<p>我们在代码处理中, 通常希望将 header 和 body 合并为一个 ByteBuf, 方便处理, 那么通常的做法是:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ByteBuf allBuf = Unpooled.buffer(header.readableBytes() + body.readableBytes());</span><br><span class=\"line\">allBuf.writeBytes(header);</span><br><span class=\"line\">allBuf.writeBytes(body);</span><br></pre></td></tr></table></figure></p>\n<p>可以看到, 我们将 header 和 body 都拷贝到了新的 allBuf 中了, 这无形中增加了两次额外的数据拷贝操作了.</p>\n<p>那么有没有更加高效优雅的方式实现相同的目的呢? 我们来看一下 CompositeByteBuf 是如何实现这样的需求的吧.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ByteBuf header = ...</span><br><span class=\"line\">ByteBuf body = ...</span><br><span class=\"line\"></span><br><span class=\"line\">CompositeByteBuf compositeByteBuf = Unpooled.compositeBuffer();</span><br><span class=\"line\">compositeByteBuf.addComponents(true, header, body);</span><br></pre></td></tr></table></figure></p>\n<p>上面代码中, 我们定义了一个 CompositeByteBuf 对象, 然后调用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public CompositeByteBuf addComponents(boolean increaseWriterIndex, ByteBuf... buffers) &#123;</span><br><span class=\"line\">...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>不过需要注意的是, 虽然看起来 CompositeByteBuf 是由两个 ByteBuf 组合而成的, 不过在 CompositeByteBuf 内部, 这两个 ByteBuf 都是单独存在的, CompositeByteBuf 只是逻辑上是一个整体.</p>\n<p>上面 CompositeByteBuf 代码还以一个地方值得注意的是, 我们调用 addComponents(boolean increaseWriterIndex, ByteBuf… buffers) 来添加两个 ByteBuf, 其中第一个参数是 true, 表示当添加新的 ByteBuf 时, 自动递增 CompositeByteBuf 的 writeIndex.<br>如果我们调用的是<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compositeByteBuf.addComponents(header, body);</span><br></pre></td></tr></table></figure></p>\n<p>那么其实 compositeByteBuf 的 writeIndex 仍然是0, 因此此时我们就不可能从 compositeByteBuf 中读取到数据, 这一点希望大家要特别注意.</p>\n<p>除了上面直接使用 CompositeByteBuf 类外, 我们还可以使用 Unpooled.wrappedBuffer 方法, 它底层封装了 CompositeByteBuf 操作, 因此使用起来更加方便:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ByteBuf header = ...</span><br><span class=\"line\">ByteBuf body = ...</span><br><span class=\"line\"></span><br><span class=\"line\">ByteBuf allByteBuf = Unpooled.wrappedBuffer(header, body);</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"通过-wrap-操作实现零拷贝\"><a href=\"#通过-wrap-操作实现零拷贝\" class=\"headerlink\" title=\"通过 wrap 操作实现零拷贝\"></a>通过 wrap 操作实现零拷贝</h1><p>例如我们有一个 byte 数组, 我们希望将它转换为一个 ByteBuf 对象, 以便于后续的操作, 那么传统的做法是将此 byte 数组拷贝到 ByteBuf 中, 即:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">byte[] bytes = ...</span><br><span class=\"line\">ByteBuf byteBuf = Unpooled.buffer();</span><br><span class=\"line\">byteBuf.writeBytes(bytes);</span><br></pre></td></tr></table></figure></p>\n<p>显然这样的方式也是有一个额外的拷贝操作的, 我们可以使用 Unpooled 的相关方法, 包装这个 byte 数组, 生成一个新的 ByteBuf 实例, 而不需要进行拷贝操作. 上面的代码可以改为:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">byte[] bytes = ...</span><br><span class=\"line\">ByteBuf byteBuf = Unpooled.wrappedBuffer(bytes);</span><br></pre></td></tr></table></figure></p>\n<p>可以看到, 我们通过 Unpooled.wrappedBuffer 方法来将 bytes 包装成为一个 UnpooledHeapByteBuf 对象, 而在包装的过程中, 是不会有拷贝操作的. 即最后我们生成的生成的 ByteBuf 对象是和 bytes 数组共用了同一个存储空间, 对 bytes 的修改也会反映到 ByteBuf 对象中.</p>\n<p>Unpooled 工具类还提供了很多重载的 wrappedBuffer 方法:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static ByteBuf wrappedBuffer(byte[] array)</span><br><span class=\"line\">public static ByteBuf wrappedBuffer(byte[] array, int offset, int length)</span><br><span class=\"line\"></span><br><span class=\"line\">public static ByteBuf wrappedBuffer(ByteBuffer buffer)</span><br><span class=\"line\">public static ByteBuf wrappedBuffer(ByteBuf buffer)</span><br><span class=\"line\"></span><br><span class=\"line\">public static ByteBuf wrappedBuffer(byte[]... arrays)</span><br><span class=\"line\">public static ByteBuf wrappedBuffer(ByteBuf... buffers)</span><br><span class=\"line\">public static ByteBuf wrappedBuffer(ByteBuffer... buffers)</span><br><span class=\"line\"></span><br><span class=\"line\">public static ByteBuf wrappedBuffer(int maxNumComponents, byte[]... arrays)</span><br><span class=\"line\">public static ByteBuf wrappedBuffer(int maxNumComponents, ByteBuf... buffers)</span><br><span class=\"line\">public static ByteBuf wrappedBuffer(int maxNumComponents, ByteBuffer... buffers)</span><br></pre></td></tr></table></figure></p>\n<p>这些方法可以将一个或多个 buffer 包装为一个 ByteBuf 对象, 从而避免了拷贝操作.</p>\n<h1 id=\"通过-slice-操作实现零拷贝\"><a href=\"#通过-slice-操作实现零拷贝\" class=\"headerlink\" title=\"通过 slice 操作实现零拷贝\"></a>通过 slice 操作实现零拷贝</h1><p>slice 操作和 wrap 操作刚好相反, Unpooled.wrappedBuffer 可以将多个 ByteBuf 合并为一个, 而 slice 操作可以将一个 ByteBuf 切片 为多个共享一个存储区域的 ByteBuf 对象.</p>\n<p>ByteBuf 提供了两个 slice 操作方法:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public ByteBuf slice();</span><br><span class=\"line\">public ByteBuf slice(int index, int length);</span><br></pre></td></tr></table></figure></p>\n<p>不带参数的 slice 方法等同于 buf.slice(buf.readerIndex(), buf.readableBytes()) 调用, 即返回 buf 中可读部分的切片. 而 slice(int index, int length) 方法相对就比较灵活了, 我们可以设置不同的参数来获取到 buf 的不同区域的切片.</p>\n<p>下面的例子展示了 ByteBuf.slice 方法的简单用法:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ByteBuf byteBuf = ...</span><br><span class=\"line\">ByteBuf header = byteBuf.slice(0, 5);</span><br><span class=\"line\">ByteBuf body = byteBuf.slice(5, 10);</span><br></pre></td></tr></table></figure></p>\n<p>用 slice 方法产生 header 和 body 的过程是没有拷贝操作的, header 和 body 对象在内部其实是共享了 byteBuf 存储空间的不同部分而已.</p>\n<h1 id=\"通过-FileRegion-实现零拷贝\"><a href=\"#通过-FileRegion-实现零拷贝\" class=\"headerlink\" title=\"通过 FileRegion 实现零拷贝\"></a>通过 FileRegion 实现零拷贝</h1><p>Netty 中使用 FileRegion 实现文件传输的零拷贝, 不过在底层 FileRegion 是依赖于 Java NIO FileChannel.transfer 的零拷贝功能.</p>\n<p>首先我们从最基础的 Java IO 开始吧. 假设我们希望实现一个文件拷贝的功能, 那么使用传统的方式, 我们有如下实现:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void copyFile(String srcFile, String destFile) throws Exception &#123;</span><br><span class=\"line\">    byte[] temp = new byte[1024];</span><br><span class=\"line\">    FileInputStream in = new FileInputStream(srcFile);</span><br><span class=\"line\">    FileOutputStream out = new FileOutputStream(destFile);</span><br><span class=\"line\">    int length;</span><br><span class=\"line\">    while ((length = in.read(temp)) != -1) &#123;</span><br><span class=\"line\">        out.write(temp, 0, length);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    in.close();</span><br><span class=\"line\">    out.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面是一个典型的读写二进制文件的代码实现了. 不用我说, 大家肯定都知道, 上面的代码中不断中源文件中读取定长数据到 temp 数组中, 然后再将 temp 中的内容写入目的文件, 这样的拷贝操作对于小文件倒是没有太大的影响, 但是如果我们需要拷贝大文件时, 频繁的内存拷贝操作就消耗大量的系统资源了.</p>\n<p>下面我们来看一下使用 Java NIO 的 FileChannel 是如何实现零拷贝的:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void copyFileWithFileChannel(String srcFileName, String destFileName) throws Exception &#123;</span><br><span class=\"line\">    RandomAccessFile srcFile = new RandomAccessFile(srcFileName, &quot;r&quot;);</span><br><span class=\"line\">    FileChannel srcFileChannel = srcFile.getChannel();</span><br><span class=\"line\"></span><br><span class=\"line\">    RandomAccessFile destFile = new RandomAccessFile(destFileName, &quot;rw&quot;);</span><br><span class=\"line\">    FileChannel destFileChannel = destFile.getChannel();</span><br><span class=\"line\"></span><br><span class=\"line\">    long position = 0;</span><br><span class=\"line\">    long count = srcFileChannel.size();</span><br><span class=\"line\"></span><br><span class=\"line\">    srcFileChannel.transferTo(position, count, destFileChannel);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到, 使用了 FileChannel 后, 我们就可以直接将源文件的内容直接拷贝(transferTo) 到目的文件中, 而不需要额外借助一个临时 buffer, 避免了不必要的内存操作.</p>\n<p>有了上面的一些理论知识, 我们来看一下在 Netty 中是怎么使用 FileRegion 来实现零拷贝传输一个文件的:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public void channelRead0(ChannelHandlerContext ctx, String msg) throws Exception &#123;</span><br><span class=\"line\">    RandomAccessFile raf = null;</span><br><span class=\"line\">    long length = -1;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        // 1. 通过 RandomAccessFile 打开一个文件.</span><br><span class=\"line\">        raf = new RandomAccessFile(msg, &quot;r&quot;);</span><br><span class=\"line\">        length = raf.length();</span><br><span class=\"line\">    &#125; catch (Exception e) &#123;</span><br><span class=\"line\">        ctx.writeAndFlush(&quot;ERR: &quot; + e.getClass().getSimpleName() + &quot;: &quot; + e.getMessage() + &apos;\\n&apos;);</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125; finally &#123;</span><br><span class=\"line\">        if (length &lt; 0 &amp;&amp; raf != null) &#123;</span><br><span class=\"line\">            raf.close();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ctx.write(&quot;OK: &quot; + raf.length() + &apos;\\n&apos;);</span><br><span class=\"line\">    if (ctx.pipeline().get(SslHandler.class) == null) &#123;</span><br><span class=\"line\">        // SSL not enabled - can use zero-copy file transfer.</span><br><span class=\"line\">        // 2. 调用 raf.getChannel() 获取一个 FileChannel.</span><br><span class=\"line\">        // 3. 将 FileChannel 封装成一个 DefaultFileRegion</span><br><span class=\"line\">        ctx.write(new DefaultFileRegion(raf.getChannel(), 0, length));</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        // SSL enabled - cannot use zero-copy file transfer.</span><br><span class=\"line\">        ctx.write(new ChunkedFile(raf));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ctx.writeAndFlush(&quot;\\n&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面的代码是 Netty 的一个例子, 其源码在 netty/example/src/main/java/io/netty/example/file/FileServerHandler.java<br>可以看到, 第一步是通过 RandomAccessFile 打开一个文件, 然后 Netty 使用了 DefaultFileRegion 来封装一个 FileChannel 即:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new DefaultFileRegion(raf.getChannel(), 0, length)</span><br></pre></td></tr></table></figure></p>\n<p>当有了 FileRegion 后, 我们就可以直接通过它将文件的内容直接写入 Channel 中, 而不需要像传统的做法: 拷贝文件内容到临时 buffer, 然后再将 buffer 写入 Channel. 通过这样的零拷贝操作, 无疑对传输大文件很有帮助.</p>\n<p>转载出处：<a href=\"https://www.cnblogs.com/xys1228/p/6088805.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/xys1228/p/6088805.html</a></p>\n","site":{"data":{}},"excerpt":"<p>根据 Wiki 对 Zero-copy 的定义:</p>\n<blockquote>\n<p>“Zero-copy” describes computer operations in which the CPU does not perform the task of copying data from one memory area to another. This is frequently used to save CPU cycles and memory bandwidth when transmitting a file over a network.</p>\n</blockquote>\n<p>即所谓的 Zero-copy, 就是在操作数据时, 不需要将数据 buffer 从一个内存区域拷贝到另一个内存区域. 因为少了一次内存的拷贝, 因此 CPU 的效率就得到的提升.</p>\n<p>在 OS 层面上的 Zero-copy 通常指避免在 用户态(User-space) 与 内核态(Kernel-space) 之间来回拷贝数据. 例如 Linux 提供的 mmap 系统调用, 它可以将一段用户空间内存映射到内核空间, 当映射成功后, 用户对这段内存区域的修改可以直接反映到内核空间; 同样地, 内核空间对这段区域的修改也直接反映用户空间. 正因为有这样的映射关系, 我们就不需要在 用户态(User-space) 与 内核态(Kernel-space) 之间拷贝数据, 提高了数据传输的效率.</p>\n<p>而需要注意的是, Netty 中的 Zero-copy 与上面我们所提到到 OS 层面上的 Zero-copy 不太一样, Netty的 Zero-coyp 完全是在用户态(Java 层面)的, 它的 Zero-copy 的更多的是偏向于 优化数据操作 这样的概念.</p>\n<p>Netty 的 Zero-copy 体现在如下几个个方面:</p>\n<ul>\n<li>Netty 提供了 CompositeByteBuf 类, 它可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf, 避免了各个 ByteBuf 之间的拷贝.</li>\n<li>通过 wrap 操作, 我们可以将 byte[] 数组、ByteBuf、ByteBuffer等包装成一个 Netty ByteBuf 对象, 进而避免了拷贝操作.</li>\n<li>ByteBuf 支持 slice 操作, 因此可以将 ByteBuf 分解为多个共享同一个存储区域的 ByteBuf, 避免了内存的拷贝.</li>\n<li>通过 FileRegion 包装的FileChannel.tranferTo 实现文件传输, 可以直接将文件缓冲区的数据发送到目标 Channel, 避免了传统通过循环 write 方式导致的内存拷贝问题.</li>\n</ul>\n<p>下面我们就来简单了解一下这几种常见的零拷贝操作.</p>","more":"<h1 id=\"通过-CompositeByteBuf-实现零拷贝\"><a href=\"#通过-CompositeByteBuf-实现零拷贝\" class=\"headerlink\" title=\"通过 CompositeByteBuf 实现零拷贝\"></a>通过 CompositeByteBuf 实现零拷贝</h1><p>假设我们有一份协议数据, 它由头部和消息体组成, 而头部和消息体是分别存放在两个 ByteBuf 中的, 即:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ByteBuf header = ...</span><br><span class=\"line\">ByteBuf body = ...</span><br></pre></td></tr></table></figure></p>\n<p>我们在代码处理中, 通常希望将 header 和 body 合并为一个 ByteBuf, 方便处理, 那么通常的做法是:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ByteBuf allBuf = Unpooled.buffer(header.readableBytes() + body.readableBytes());</span><br><span class=\"line\">allBuf.writeBytes(header);</span><br><span class=\"line\">allBuf.writeBytes(body);</span><br></pre></td></tr></table></figure></p>\n<p>可以看到, 我们将 header 和 body 都拷贝到了新的 allBuf 中了, 这无形中增加了两次额外的数据拷贝操作了.</p>\n<p>那么有没有更加高效优雅的方式实现相同的目的呢? 我们来看一下 CompositeByteBuf 是如何实现这样的需求的吧.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ByteBuf header = ...</span><br><span class=\"line\">ByteBuf body = ...</span><br><span class=\"line\"></span><br><span class=\"line\">CompositeByteBuf compositeByteBuf = Unpooled.compositeBuffer();</span><br><span class=\"line\">compositeByteBuf.addComponents(true, header, body);</span><br></pre></td></tr></table></figure></p>\n<p>上面代码中, 我们定义了一个 CompositeByteBuf 对象, 然后调用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public CompositeByteBuf addComponents(boolean increaseWriterIndex, ByteBuf... buffers) &#123;</span><br><span class=\"line\">...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>不过需要注意的是, 虽然看起来 CompositeByteBuf 是由两个 ByteBuf 组合而成的, 不过在 CompositeByteBuf 内部, 这两个 ByteBuf 都是单独存在的, CompositeByteBuf 只是逻辑上是一个整体.</p>\n<p>上面 CompositeByteBuf 代码还以一个地方值得注意的是, 我们调用 addComponents(boolean increaseWriterIndex, ByteBuf… buffers) 来添加两个 ByteBuf, 其中第一个参数是 true, 表示当添加新的 ByteBuf 时, 自动递增 CompositeByteBuf 的 writeIndex.<br>如果我们调用的是<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compositeByteBuf.addComponents(header, body);</span><br></pre></td></tr></table></figure></p>\n<p>那么其实 compositeByteBuf 的 writeIndex 仍然是0, 因此此时我们就不可能从 compositeByteBuf 中读取到数据, 这一点希望大家要特别注意.</p>\n<p>除了上面直接使用 CompositeByteBuf 类外, 我们还可以使用 Unpooled.wrappedBuffer 方法, 它底层封装了 CompositeByteBuf 操作, 因此使用起来更加方便:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ByteBuf header = ...</span><br><span class=\"line\">ByteBuf body = ...</span><br><span class=\"line\"></span><br><span class=\"line\">ByteBuf allByteBuf = Unpooled.wrappedBuffer(header, body);</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"通过-wrap-操作实现零拷贝\"><a href=\"#通过-wrap-操作实现零拷贝\" class=\"headerlink\" title=\"通过 wrap 操作实现零拷贝\"></a>通过 wrap 操作实现零拷贝</h1><p>例如我们有一个 byte 数组, 我们希望将它转换为一个 ByteBuf 对象, 以便于后续的操作, 那么传统的做法是将此 byte 数组拷贝到 ByteBuf 中, 即:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">byte[] bytes = ...</span><br><span class=\"line\">ByteBuf byteBuf = Unpooled.buffer();</span><br><span class=\"line\">byteBuf.writeBytes(bytes);</span><br></pre></td></tr></table></figure></p>\n<p>显然这样的方式也是有一个额外的拷贝操作的, 我们可以使用 Unpooled 的相关方法, 包装这个 byte 数组, 生成一个新的 ByteBuf 实例, 而不需要进行拷贝操作. 上面的代码可以改为:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">byte[] bytes = ...</span><br><span class=\"line\">ByteBuf byteBuf = Unpooled.wrappedBuffer(bytes);</span><br></pre></td></tr></table></figure></p>\n<p>可以看到, 我们通过 Unpooled.wrappedBuffer 方法来将 bytes 包装成为一个 UnpooledHeapByteBuf 对象, 而在包装的过程中, 是不会有拷贝操作的. 即最后我们生成的生成的 ByteBuf 对象是和 bytes 数组共用了同一个存储空间, 对 bytes 的修改也会反映到 ByteBuf 对象中.</p>\n<p>Unpooled 工具类还提供了很多重载的 wrappedBuffer 方法:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static ByteBuf wrappedBuffer(byte[] array)</span><br><span class=\"line\">public static ByteBuf wrappedBuffer(byte[] array, int offset, int length)</span><br><span class=\"line\"></span><br><span class=\"line\">public static ByteBuf wrappedBuffer(ByteBuffer buffer)</span><br><span class=\"line\">public static ByteBuf wrappedBuffer(ByteBuf buffer)</span><br><span class=\"line\"></span><br><span class=\"line\">public static ByteBuf wrappedBuffer(byte[]... arrays)</span><br><span class=\"line\">public static ByteBuf wrappedBuffer(ByteBuf... buffers)</span><br><span class=\"line\">public static ByteBuf wrappedBuffer(ByteBuffer... buffers)</span><br><span class=\"line\"></span><br><span class=\"line\">public static ByteBuf wrappedBuffer(int maxNumComponents, byte[]... arrays)</span><br><span class=\"line\">public static ByteBuf wrappedBuffer(int maxNumComponents, ByteBuf... buffers)</span><br><span class=\"line\">public static ByteBuf wrappedBuffer(int maxNumComponents, ByteBuffer... buffers)</span><br></pre></td></tr></table></figure></p>\n<p>这些方法可以将一个或多个 buffer 包装为一个 ByteBuf 对象, 从而避免了拷贝操作.</p>\n<h1 id=\"通过-slice-操作实现零拷贝\"><a href=\"#通过-slice-操作实现零拷贝\" class=\"headerlink\" title=\"通过 slice 操作实现零拷贝\"></a>通过 slice 操作实现零拷贝</h1><p>slice 操作和 wrap 操作刚好相反, Unpooled.wrappedBuffer 可以将多个 ByteBuf 合并为一个, 而 slice 操作可以将一个 ByteBuf 切片 为多个共享一个存储区域的 ByteBuf 对象.</p>\n<p>ByteBuf 提供了两个 slice 操作方法:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public ByteBuf slice();</span><br><span class=\"line\">public ByteBuf slice(int index, int length);</span><br></pre></td></tr></table></figure></p>\n<p>不带参数的 slice 方法等同于 buf.slice(buf.readerIndex(), buf.readableBytes()) 调用, 即返回 buf 中可读部分的切片. 而 slice(int index, int length) 方法相对就比较灵活了, 我们可以设置不同的参数来获取到 buf 的不同区域的切片.</p>\n<p>下面的例子展示了 ByteBuf.slice 方法的简单用法:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ByteBuf byteBuf = ...</span><br><span class=\"line\">ByteBuf header = byteBuf.slice(0, 5);</span><br><span class=\"line\">ByteBuf body = byteBuf.slice(5, 10);</span><br></pre></td></tr></table></figure></p>\n<p>用 slice 方法产生 header 和 body 的过程是没有拷贝操作的, header 和 body 对象在内部其实是共享了 byteBuf 存储空间的不同部分而已.</p>\n<h1 id=\"通过-FileRegion-实现零拷贝\"><a href=\"#通过-FileRegion-实现零拷贝\" class=\"headerlink\" title=\"通过 FileRegion 实现零拷贝\"></a>通过 FileRegion 实现零拷贝</h1><p>Netty 中使用 FileRegion 实现文件传输的零拷贝, 不过在底层 FileRegion 是依赖于 Java NIO FileChannel.transfer 的零拷贝功能.</p>\n<p>首先我们从最基础的 Java IO 开始吧. 假设我们希望实现一个文件拷贝的功能, 那么使用传统的方式, 我们有如下实现:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void copyFile(String srcFile, String destFile) throws Exception &#123;</span><br><span class=\"line\">    byte[] temp = new byte[1024];</span><br><span class=\"line\">    FileInputStream in = new FileInputStream(srcFile);</span><br><span class=\"line\">    FileOutputStream out = new FileOutputStream(destFile);</span><br><span class=\"line\">    int length;</span><br><span class=\"line\">    while ((length = in.read(temp)) != -1) &#123;</span><br><span class=\"line\">        out.write(temp, 0, length);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    in.close();</span><br><span class=\"line\">    out.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面是一个典型的读写二进制文件的代码实现了. 不用我说, 大家肯定都知道, 上面的代码中不断中源文件中读取定长数据到 temp 数组中, 然后再将 temp 中的内容写入目的文件, 这样的拷贝操作对于小文件倒是没有太大的影响, 但是如果我们需要拷贝大文件时, 频繁的内存拷贝操作就消耗大量的系统资源了.</p>\n<p>下面我们来看一下使用 Java NIO 的 FileChannel 是如何实现零拷贝的:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void copyFileWithFileChannel(String srcFileName, String destFileName) throws Exception &#123;</span><br><span class=\"line\">    RandomAccessFile srcFile = new RandomAccessFile(srcFileName, &quot;r&quot;);</span><br><span class=\"line\">    FileChannel srcFileChannel = srcFile.getChannel();</span><br><span class=\"line\"></span><br><span class=\"line\">    RandomAccessFile destFile = new RandomAccessFile(destFileName, &quot;rw&quot;);</span><br><span class=\"line\">    FileChannel destFileChannel = destFile.getChannel();</span><br><span class=\"line\"></span><br><span class=\"line\">    long position = 0;</span><br><span class=\"line\">    long count = srcFileChannel.size();</span><br><span class=\"line\"></span><br><span class=\"line\">    srcFileChannel.transferTo(position, count, destFileChannel);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到, 使用了 FileChannel 后, 我们就可以直接将源文件的内容直接拷贝(transferTo) 到目的文件中, 而不需要额外借助一个临时 buffer, 避免了不必要的内存操作.</p>\n<p>有了上面的一些理论知识, 我们来看一下在 Netty 中是怎么使用 FileRegion 来实现零拷贝传输一个文件的:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public void channelRead0(ChannelHandlerContext ctx, String msg) throws Exception &#123;</span><br><span class=\"line\">    RandomAccessFile raf = null;</span><br><span class=\"line\">    long length = -1;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        // 1. 通过 RandomAccessFile 打开一个文件.</span><br><span class=\"line\">        raf = new RandomAccessFile(msg, &quot;r&quot;);</span><br><span class=\"line\">        length = raf.length();</span><br><span class=\"line\">    &#125; catch (Exception e) &#123;</span><br><span class=\"line\">        ctx.writeAndFlush(&quot;ERR: &quot; + e.getClass().getSimpleName() + &quot;: &quot; + e.getMessage() + &apos;\\n&apos;);</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125; finally &#123;</span><br><span class=\"line\">        if (length &lt; 0 &amp;&amp; raf != null) &#123;</span><br><span class=\"line\">            raf.close();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ctx.write(&quot;OK: &quot; + raf.length() + &apos;\\n&apos;);</span><br><span class=\"line\">    if (ctx.pipeline().get(SslHandler.class) == null) &#123;</span><br><span class=\"line\">        // SSL not enabled - can use zero-copy file transfer.</span><br><span class=\"line\">        // 2. 调用 raf.getChannel() 获取一个 FileChannel.</span><br><span class=\"line\">        // 3. 将 FileChannel 封装成一个 DefaultFileRegion</span><br><span class=\"line\">        ctx.write(new DefaultFileRegion(raf.getChannel(), 0, length));</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        // SSL enabled - cannot use zero-copy file transfer.</span><br><span class=\"line\">        ctx.write(new ChunkedFile(raf));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ctx.writeAndFlush(&quot;\\n&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面的代码是 Netty 的一个例子, 其源码在 netty/example/src/main/java/io/netty/example/file/FileServerHandler.java<br>可以看到, 第一步是通过 RandomAccessFile 打开一个文件, 然后 Netty 使用了 DefaultFileRegion 来封装一个 FileChannel 即:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new DefaultFileRegion(raf.getChannel(), 0, length)</span><br></pre></td></tr></table></figure></p>\n<p>当有了 FileRegion 后, 我们就可以直接通过它将文件的内容直接写入 Channel 中, 而不需要像传统的做法: 拷贝文件内容到临时 buffer, 然后再将 buffer 写入 Channel. 通过这样的零拷贝操作, 无疑对传输大文件很有帮助.</p>\n<p>转载出处：<a href=\"https://www.cnblogs.com/xys1228/p/6088805.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/xys1228/p/6088805.html</a></p>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjsl5qftn0002k8v3hw7c3711","tag_id":"cjsl5qfts0004k8v3njdb6zww","_id":"cjsl5qfty0009k8v3tg309aep"},{"post_id":"cjsl5qftr0003k8v3l5270meg","tag_id":"cjsl5qfty0008k8v3pzh2zxfd","_id":"cjsl5qfu3000dk8v3sxgqa9f8"},{"post_id":"cjsl5qftu0005k8v32khn41t7","tag_id":"cjsl5qfu3000ck8v39h4o7yyg","_id":"cjsl5qfu5000fk8v38akhpstb"},{"post_id":"cjsl5qftw0006k8v3hrp050s1","tag_id":"cjsl5qfty0008k8v3pzh2zxfd","_id":"cjsl5qfu6000hk8v3foepxhvu"},{"post_id":"cjsl5qftx0007k8v3sg1ruvcu","tag_id":"cjsl5qfu3000ck8v39h4o7yyg","_id":"cjsl5qfu7000jk8v3c4lknjlj"},{"post_id":"cjsl5qfty000ak8v34t3i7gyp","tag_id":"cjsl5qfu3000ck8v39h4o7yyg","_id":"cjsl5qfu8000lk8v3o37legki"},{"post_id":"cjsl5qfu1000bk8v3lh420onx","tag_id":"cjsl5qfu8000kk8v3f2br11pq","_id":"cjsl5qfu9000mk8v3kgg0x4mt"},{"post_id":"cjsl5qftg0000k8v30i0kcs5q","tag_id":"cjsl5vqz90000kkv3k7hplgjs","_id":"cjsl5vqzg0001kkv3basugt96"}],"Tag":[{"name":"Java","_id":"cjsl5qfts0004k8v3njdb6zww"},{"name":"Docker","_id":"cjsl5qfty0008k8v3pzh2zxfd"},{"name":"Go","_id":"cjsl5qfu3000ck8v39h4o7yyg"},{"name":"Netty","_id":"cjsl5qfu8000kk8v3f2br11pq"},{"name":"Mysql","_id":"cjsl5vqz90000kkv3k7hplgjs"}]}}